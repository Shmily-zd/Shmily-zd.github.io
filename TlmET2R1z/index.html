<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="1">
<meta name="theme-color" content="#868e96">
<title>MySQL_06_索引 | zd_blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1648647335749">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/atom-one-dark.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="MySQL_06_索引" />
  <meta name="keywords" content="MySQL" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>zd_blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">等风来 or 追风去</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top/archives" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top/tags" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">zd</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">12</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">2</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB">1. 索引的分类</a></li>
<li><a href="#2-%E6%B5%8B%E8%AF%95%E7%B4%A2%E5%BC%95">2. 测试索引</a></li>
<li><a href="#3-%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99">3. 索引原则</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://zdblog.top/TlmET2R1z/"> MySQL_06_索引 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-03-30 21:30:52">2022-03-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://zdblog.top/MySQL/">
        <span>MySQL</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >6<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >1394<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/TlmET2R1z/"
      data-flag-title="MySQL_06_索引"
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <p><a href="https://www.cnblogs.com/zsql/p/13808417.html">MySQL索引</a></p>
<p><a href="https://blog.codinglabs.org/articles/theory-of-mysql-index.html">索引的数据结构和算法</a></p>
<blockquote>
<p>Msql官方对索引的定义为：<strong>索引（index）是帮助MySQL高效获取数据的数据结构</strong></p>
<p>索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针</p>
<p>提取句子主干，就可以得到索引的本质：索引是数据结构</p>
<p>索引大大提高了查询速度，同时却会降低更新表的速度</p>
</blockquote>
<h2 id="1-索引的分类">1. 索引的分类</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html">MySQL索引官网</a></p>
<blockquote>
<p>在一个表中，主键索引只能有一个，唯一索引可以有多个</p>
</blockquote>
<ul>
<li>主键索引（primary key）
<ul>
<li>唯一的标识，主键不可重复，只能有一个列作为主键</li>
</ul>
</li>
<li>唯一索引 （unique key）
<ul>
<li>避免重复的列出现，可以重复，多个列都可以标示为唯一索引</li>
</ul>
</li>
<li>常规索引（key/index）
<ul>
<li>默认的 index 或者 key关键字来设置</li>
</ul>
</li>
<li>全文索引（FullText ）
<ul>
<li>在特定的数据库引擎下才有，myisam</li>
<li>快速定位数据</li>
</ul>
</li>
</ul>
<p>基础语法</p>
<pre><code class="language-sql">-- 索引的使用

-- 1.在创建表的时候给字段增加索引
-- 2.创建完毕后，增加索引

-- 显示所有的索引信息
SHOW INDEX FROM student;

-- 新增一个索引 (索引名) 列名

ALTER TABLE `student` ADD UNIQUE KEY `UK_IDENTITY_CARD` (`identity_card`);
ALTER TABLE `student` ADD KEY `K_STUDENT_NAME`(`student_name`);

ALTER TABLE `student`  ADD FULLTEXT INDEX `FI_PHONE` (`phone`);

-- explain 分析sql执行的状况

EXPLAIN SELECT * FROM student; -- 非全文索引

EXPLAIN SELECT * FROM student WHERE MATCH(`phone`) AGAINST('138'); -- 全文索引
</code></pre>
<p><a href="https://blog.csdn.net/jiadajing267/article/details/81269067">【MySQL优化】——看懂explain</a></p>
<hr>
<h2 id="2-测试索引">2. 测试索引</h2>
<pre><code class="language-sql">CREATE TABLE app_user (
    `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'ID',
    `name` VARCHAR(50)  DEFAULT '' COMMENT '用户昵称',
    `email` VARCHAR(50)  NOT NULL COMMENT '用户邮箱',
    `phone` VARCHAR(20)  DEFAULT '' COMMENT '手机号',
    `gender` TINYINT(4)  UNSIGNED DEFAULT '0' COMMENT '性别（0：男  1：女）',
    `password` VARCHAR(100)  NOT NULL COMMENT '密码',
    `age` TINYINT(4)  DEFAULT '0' COMMENT '年龄',
    `create_time` DATETIME  DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT='app用户表'


-- 插入100万数据b (函数)

DELIMITER $$ -- 写函数之前必须要写，标志
CREATE FUNCTION mock_data()
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE num INT DEFAULT 1000000;
    DECLARE i INT DEFAULT 0;
    WHILE i&lt;num DO
        INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`)
        VALUES(CONCAT('用户',i),'123345@qq.com',CONCAT('18',FLOOR(RAND()*((999999999-100000000)+100000000))),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100));
        SET i = i+1;
    END WHILE;
    RETURN i;
END;

-- 执行函数
SELECT mock_data();

SELECT * FROM app_user;
</code></pre>
<p>测试</p>
<pre><code class="language-sql">-- 加索引前
SELECT * FROM app_user WHERE `name` = '用户9999'; -- 0.440 sec
EXPLAIN SELECT * FROM app_user WHERE `name` = '用户9999';

-- 创建索引
-- id_表名_字段名  索引名
-- CREATE INDEX 索引名 ON 表名(`字段名`);
CREATE INDEX id_app_user_name ON app_user(`name`);
 -- 加索引后
SELECT * FROM app_user WHERE `name` = '用户9999'; -- 0.002 sec
EXPLAIN SELECT * FROM app_user WHERE `name` = '用户9999';
</code></pre>
<p>加索引前</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704114603590.png" alt="image-20210704114603590" loading="lazy"></figure>
<p>加索引后</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704114402938.png" alt="image-20210704114402938" loading="lazy"></figure>
<p><strong>索引在小数据量的时候，用处不大，但是再大数据的时候，区分十分明显</strong></p>
<hr>
<h2 id="3-索引原则">3. 索引原则</h2>
<ul>
<li><strong>索引并非越多越好</strong>
<ul>
<li>占用磁盘空间</li>
<li>影响INSERT、DELETE、UPDATE等语句的性能</li>
</ul>
</li>
<li>避免对经常更新的表进行过多的索引，而对<strong>经常用于查询的字段应该创建索引</strong></li>
<li><strong>数据量小的表最好不要使用索引</strong></li>
<li>在条件表达式中经常用到的<strong>不同值较多的列上建立索引</strong>，在不同值很少的列上不要建立索引
<ul>
<li>严重降低数据更新速度</li>
</ul>
</li>
<li>当<strong>唯一性是某种数据本身的特征时，指定唯一索引</strong>。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度</li>
<li>在<strong>频繁进行排序或分组</strong>（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上<strong>建立组合索引</strong></li>
<li>最适合索引的列是出现在<strong>WHERE子句中的列，或连接子句中指定的列</strong>，而不是出现在SELECT关键字后的选择列表中的列</li>
<li><strong>使用短索引</strong>。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。
<ul>
<li>能够节省大量索引空间</li>
<li>可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值</li>
</ul>
</li>
<li><strong>利用最左前缀</strong>。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。</li>
<li>对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的<strong>主键</strong>，则按照主键顺序保存。如果没有主键，但是有<strong>唯一索引</strong>，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个<strong>内部列</strong>，按照这个列的<strong>顺序保存</strong>。按照主键或者内部列进行的访问是最快的，所以InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主<strong>键要尽可能选择较短的数据类型</strong>，可以有效地减少索引的磁盘占用，提高索引的缓存效果</li>
</ul>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      zd
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://zdblog.top/TlmET2R1z/" title="MySQL_06_索引">https://zdblog.top/TlmET2R1z/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://zdblog.top/MySQL/"># MySQL</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="MySQL_07_权限管理和备份" href="https://zdblog.top/YMrTb0F0C/">MySQL_07_权限管理和备份</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="MySQL_07_权限管理和备份" href="https://zdblog.top/YMrTb0F0C/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="MySQL_05_事务" href="https://zdblog.top/kEulxZRW3/">MySQL_05_事务</a>
        <a class="nav-mobile-next" title="MySQL_05_事务" href="https://zdblog.top/kEulxZRW3/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'E4xhzIEKDmAtoVnapYU5F67t-gzGzoHsz',
    appKey: 'Q1txwwJSaEmLcu4Oo8cHshbP',
    avatar: '',
    placeholder: '',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'true',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="\media\images\wallhaven-j5p6v5.jpg" />
              </div>
              
                
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/uLsqXSo3q/"" data-c="
          &lt;h2 id=&#34;1-数据库驱动和jdbc&#34;&gt;1. 数据库驱动和JDBC&lt;/h2&gt;
&lt;h3 id=&#34;数据库驱动&#34;&gt;数据库驱动&lt;/h3&gt;
&lt;p&gt;驱动：声卡，显卡，数据库&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/29/ho7KxS4Q5e6zHaj.png&#34; alt=&#34;MySQL驱动.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们的程序会通过数据库驱动，和数据库打交道！&lt;/p&gt;
&lt;h3 id=&#34;jdbc&#34;&gt;JDBC&lt;/h3&gt;
&lt;p&gt;SUN公司为了简化开发人员的（对数据库的统一）操作，提供了一个（java操作数据库的）规范，俗称JDBC&lt;/p&gt;
&lt;p&gt;这些规范的实现由具体的厂商去做~&lt;/p&gt;
&lt;p&gt;对于开发人员来说，我们只需要掌握JDBC接口的操作即可！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/29/KlqWwSMETmivyGX.png&#34; alt=&#34;JDBC接口.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;java.sql&lt;/p&gt;
&lt;p&gt;javax.sql&lt;/p&gt;
&lt;p&gt;还需要导入一个数据库驱动包 mysql-connector-java-8.0.28.jar&lt;/p&gt;
&lt;h2 id=&#34;2-第一个jdbc程序&#34;&gt;2. 第一个JDBC程序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;创建测试数据库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE jdbcstudy CHARACTER SET utf8 COLLATE utf8_general_ci;

USE jdbcstudy;

CREATE TABLE users(
  `id` INT PRIMARY KEY,
  `name` VARCHAR(40),
  `password` VARCHAR(40),
  `email` VARCHAR(60),
  `birthday` DATE
);

INSERT INTO users(`id`,`name`,`password`,`email`,`birthday`)
VALUES(1,&#39;张三&#39;,&#39;123456&#39;,&#39;zs@sina.com&#39;,&#39;1980-12-04&#39;),
(2,&#39;李四&#39;,&#39;123456&#39;,&#39;lisi@sina.com&#39;,&#39;1981-12-04&#39;),
(3,&#39;王五&#39;,&#39;123456&#39;,&#39;wangwu@sina.com&#39;,&#39;1982-12-04&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建一个普通项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导入数据库驱动（jar包）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写测试代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zd.test01;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

// 我的第一个JDBC程序
public class JdbcFirstDemo {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        // 1. 加载驱动
        Class.forName(&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;);

        // 2. 连接数据库
        String url = &amp;quot;jdbc:mysql://124.2...:3306/jdbcstudy?useUnicode = true &amp;amp; characterEncoding = utf8 &amp;amp; useSSL = false&amp;quot;;
        String username = &amp;quot;root&amp;quot;;
        String password = &amp;quot;******&amp;quot;;

        Connection connection = DriverManager.getConnection(url, username, password);

        // 3. 执行SQL的对象
        Statement statement = connection.createStatement();

        // 4. 获得返回的结果集
        String sql = &amp;quot;SELECT * FROM users&amp;quot;;

        ResultSet resultSet = statement.executeQuery(sql);

        while(resultSet.next()){
            System.out.println(&amp;quot;id = &amp;quot; + resultSet.getObject(&amp;quot;id&amp;quot;));
            System.out.println(&amp;quot;name = &amp;quot; + resultSet.getObject(&amp;quot;name&amp;quot;));
            System.out.println(&amp;quot;password = &amp;quot; + resultSet.getObject(&amp;quot;password&amp;quot;));
            System.out.println(&amp;quot;email = &amp;quot; + resultSet.getObject(&amp;quot;email&amp;quot;));
            System.out.println(&amp;quot;birthday = &amp;quot; + resultSet.getObject(&amp;quot;birthday&amp;quot;));
            System.out.println(&amp;quot;======================&amp;quot;);
        }

        // 5. 释放连接
        resultSet.close();
        statement.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;步骤总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载驱动&lt;/li&gt;
&lt;li&gt;连接数据库DriverManager&lt;/li&gt;
&lt;li&gt;获取执行SQL的对象 Statement&lt;/li&gt;
&lt;li&gt;获得返回的结果集&lt;/li&gt;
&lt;li&gt;释放连接&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-jdbc中对象解释&#34;&gt;3. JDBC中对象解释&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;DriverManager&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. 加载驱动
// Drivermanager.registerDriver(new com.mysql.cj.jdbc.Driver);
// Class.forName() 方法初始化给定的类
Class.forName(&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;URL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String url = &amp;quot;jdbc:mysql://127....:3306/jdbcstudy?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&amp;quot;;

// mysql默认端口3306
// 协议://主机地址:端口号/数据库名?参数1&amp;amp;参数2&amp;amp;参数3
// oracle默认端口1521
// jdbc:oracle:thin:@localhost:1521:sid
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Connection&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Connection connection = DriverManager.getConnection(url, userName, passWord);   // connection代表数据库

connection.setAutoCommit(true); // 数据库设置自动提交
connection.commit();            // 事务提交
connection.rollback();          // 事务回滚
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Statement 执行sql对象  、  PreparedStatement 执行sql对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String sql = &amp;quot;SELECT * FROM users&amp;quot;;//编写SQL

statement.executeQuery();//执行查询 返回ResultSet
statement.executeUpdate();//新增，删除，修改，都用这个，返回受影响的行数
statement.execute();//执行任何SQL
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;ResultSet 查询的结果集，封装了所有的查询结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获得指定的数据类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//在不知道列类型的情况下使用
resultSet.getObject();
//如果知道列类型，就使用指定的类型
resultSet.getString();
resultSet.getInt();
resultSet.getDouble();
resultSet.getBigDecimal();
resultSet.getFloat();
resultSet.getDate();
//...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历，指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;resultSet.beforeFirst();    //移动到最前面
resultSet.afterLast();      //移动到最后面
resultSet.next();           //移动到下一个数据
resultSet.previous();       //移动到前一行
resultSet.absolute(row);    //移动到指定行
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;释放资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;resultSet.close();
statement.close();
connection.close();//消耗资源
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-statement对象详解&#34;&gt;4. statement对象详解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Statement对象的executeUpdate方法，用于向数据库发送增、删、改的SQL语句，executeUpdate执行完后，将会返回一个整数（即增删改语句导致了数据库几行数据发送了变化）&lt;/p&gt;
&lt;p&gt;Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的ResultSet对象&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CRUD操作-create&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用executeUpdate(String sql)方法完成数据添加操作，示例操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Statement statement = connection.createStatement();
String sql = &amp;quot;insert into user(...) values(...)&amp;quot;;
int num = statement.executeUpdate(sql);
if (num &amp;gt; 0) {
    System.out.println(&amp;quot;插入成功~&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;CRUD操作-delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Statement statement = connection.createStatement();
String sql = &amp;quot;delete from user where id=1&amp;quot;;
int num = statement.executeUpdate(sql);
if (num &amp;gt; 0) {
    System.out.println(&amp;quot;删除成功~&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;CRUD操作-update&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Statement statement = connection.createStatement();
String sql = &amp;quot;update user set name=&#39;&#39; where name =&#39;&#39;&amp;quot;;
int num = statement.executeUpdate(sql);
if (num &amp;gt; 0) {
    System.out.println(&amp;quot;修改成功~&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;CRUD操作-read&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Statement statement = connection.createStatement();
String sql = &amp;quot;SELECT * FROM users&amp;quot;;
ResultSet resultSet = statement.executeQuery(sql);
while (resultSet.next()) {
    //根据获取列的数据类型，分别调用resultSet的相应方法映射到java对象中
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提取工具类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zd.test02.utils;

import java.io.InputStream;
import java.sql.*;
import java.util.Properties;

public class JdbcUtils {

    private static String driver = null;
    private static String url = null;
    private static String username = null;
    private static String password = null;

    static{

        try {
            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&amp;quot;db.properties&amp;quot;);
            Properties properties = new Properties();
            properties.load(in);

            driver = properties.getProperty(&amp;quot;driver&amp;quot;);
            url = properties.getProperty(&amp;quot;url&amp;quot;);
            username = properties.getProperty(&amp;quot;username&amp;quot;);
            password = properties.getProperty(&amp;quot;password&amp;quot;);

            Class.forName(driver);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 获取连接
    public static Connection getConnect() throws SQLException {
        return DriverManager.getConnection(url, username, password);
    }

    // 释放资源
    public static void release(Connection conn, Statement st, ResultSet rs) {
        if (rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (st != null) {
            try {
                st.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置文件db.properties&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt; driver = com.mysql.cj.jdbc.Driver
 url = jdbc:mysql://124.223.57.6:3306/jdbcstudy?useUnicode=true &amp;amp; characterEncoding=utf8 &amp;amp; useSSL=true
 username = zd
 password = zd111
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写增删改的方法: &lt;code&gt;executeUpdate&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// TestInsert.java
package com.zd.test02;

import com.zd.test02.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestInsert {
    public static void main(String[] args) {

        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;

        try {
            conn = JdbcUtils.getConnect(); // 连接数据库
            st = conn.createStatement(); // 执行SQL的对象

            // 执行sql语句，返回受影响的行数
            String sql = &amp;quot;INSERT INTO users(`id`, `name`, `password`, `email`, `birthday`)&amp;quot;
                    + &amp;quot;VALUES(4, &#39;赵六&#39;, &#39;234243&#39;, &#39;234242@qq.com&#39;, &#39;2001-01-02&#39;)&amp;quot;;
            int i = st.executeUpdate(sql);
            if (i &amp;gt; 0) {
                System.out.println(&amp;quot;插入数据成功！&amp;quot;);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.release(conn, st, rs); // 释放资源
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zd.test02;

import com.zd.test02.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestInsert {
    public static void main(String[] args){

        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;

        try {
            conn = JdbcUtils.getConnect();
            st = conn.createStatement();

            String sql = &amp;quot;DELETE FROM users WHERE `id`=4&amp;quot;;
            int i = st.executeUpdate(sql);
            if (i&amp;gt;0){
                System.out.println(&amp;quot;删除数据成功！&amp;quot;);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.release(conn, st, rs);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zd.test02;

import com.zd.test02.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestInsert {
    public static void main(String[] args){

        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;

        try {
            conn = JdbcUtils.getConnect();
            st = conn.createStatement();

            String sql = &amp;quot;UPDATE users SET birthday=&#39;1990-12-01&#39; WHERE id=1&amp;quot;;
            int i = st.executeUpdate(sql);
            if (i&amp;gt;0){
                System.out.println(&amp;quot;插入数据成功！&amp;quot;);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.release(conn, st, rs);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zd.test02;

import com.zd.test02.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestSelect {
    public static void main(String[] args) {
        Connection coon = null;
        Statement st = null;
        ResultSet rs = null;

        {
            try {
                coon = JdbcUtils.getConnect();
                st = coon.createStatement();

                String sql = &amp;quot;SELECT * FROM users;&amp;quot;;
                rs = st.executeQuery(sql);

                while (rs.next()) {
                    System.out.println(&amp;quot;id = &amp;quot; + rs.getInt(&amp;quot;id&amp;quot;));
                    System.out.println(&amp;quot;name = &amp;quot; + rs.getString(&amp;quot;name&amp;quot;));
                    System.out.println(&amp;quot;password = &amp;quot; + rs.getString(&amp;quot;password&amp;quot;));
                    System.out.println(&amp;quot;email = &amp;quot; + rs.getString(&amp;quot;email&amp;quot;));
                    System.out.println(&amp;quot;birthday = &amp;quot; + rs.getString(&amp;quot;birthday&amp;quot;));
                    System.out.println(&amp;quot;========================&amp;quot;);
                }

            } catch (SQLException e) {
                e.printStackTrace();
            } finally {
                JdbcUtils.release(coon, st, rs);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sql注入问题&#34;&gt;sql注入问题&lt;/h3&gt;
&lt;p&gt;ql存在漏洞，会被攻击导致数据泄露 &lt;strong&gt;SQL会被拼接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导致结果：错误的用户名或者密码可以获取到全部的用户信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ackage com.zd.test02;

import com.zd.test02.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class SQLQustion {
    public static void main(String[] args) {
        // 正常登录
        // SELECT * FROM users WHERE `name` = &#39;张三&#39; AND `password` = &#39;123456&#39; 
//        login(&amp;quot;张三&amp;quot;, &amp;quot;123456&amp;quot;);

        // 非法登录
        // SELECT * FROM users WHERE `name` = &#39;&#39; OR &#39;1=1&#39; AND `password` = &#39;&#39; OR &#39;1=1&#39; ,sql语句被拼接
        login(&amp;quot;&#39; or &#39;1 = 1&amp;quot;, &amp;quot;&#39; or &#39;1 = 1&amp;quot;);
        // 张三
        // 123456
        // ==================
        // 李四
        // 123456
        // ==================
        // 王五
        // 123456
        // ==================
        // 赵六
        // 234243
        // ==================
    }

    // 登录业务
    public static void login(String userName, String password) {
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;

        try {
            conn = JdbcUtils.getConnect();
            st = conn.createStatement();


            String sql = &amp;quot;SELECT * FROM users WHERE `name` = &#39;&amp;quot; + userName + &amp;quot;&#39; AND `password` = &#39;&amp;quot; + password + &amp;quot;&#39;&amp;quot;;
            rs = st.executeQuery(sql);

            while(rs.next()) {
                System.out.println(rs.getString(&amp;quot;name&amp;quot;));
                System.out.println(rs.getString(&amp;quot;password&amp;quot;));
                System.out.println(&amp;quot;==================&amp;quot;);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.release(conn, st, rs);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-preparedstatement对象&#34;&gt;5. PreparedStatement对象&lt;/h2&gt;
&lt;p&gt;preparedStatement 可以防止sql注入，效率更高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;增/删/改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zd.test03;

import com.zd.test02.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TestInsert {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;

        try {
            conn = JdbcUtils.getConnect();

            // PreparedStatement 区别
            // 先预编译sql语句，使用？占位符代替参数
            String sql = &amp;quot;INSERT INTO users(`id`, `name`, `password`, `email`, `birthday`) VALUES(?,?,?,?,?);&amp;quot;;

            pst = conn.prepareStatement(sql);

            // 手动给参数赋值
            pst.setInt(1, 5);
            pst.setString(2, &amp;quot;钱七&amp;quot;);
            pst.setString(3, &amp;quot;134141&amp;quot;);
            pst.setString(4, &amp;quot;3242523@qq.com&amp;quot;);

            // 注意：sql.Date()  数据库
            //       util.Date()  java  获得时间戳
            // pst.setDate(5, Date.valueOf(&amp;quot;2003-03-03&amp;quot;));
            pst.setDate(5, new java.sql.Date(new java.util.Date().getTime()));

            int i = pst.executeUpdate();

            if (i &amp;gt; 0) {
                System.out.println(&amp;quot;插入数据成功！&amp;quot;);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.release(conn, pst, null);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;查&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zd.test03;

import com.zd.test02.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class TestSelect {
    public static void main(String[] args) {
        Connection con = null;
        PreparedStatement pst = null;
        ResultSet rs = null;
        try {
            con = JdbcUtils.getConnect();

            String sql = &amp;quot;SELECT * FROM users WHERE id=?&amp;quot;;

            pst = con.prepareStatement(sql);

            pst.setInt(1, 1);
            rs = pst.executeQuery();
            while (rs.next()) {
                System.out.println(&amp;quot;id=&amp;quot;+rs.getInt(&amp;quot;id&amp;quot;));
                System.out.println(&amp;quot;name=&amp;quot;+rs.getString(&amp;quot;name&amp;quot;));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.release(con, pst, rs);
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;防止sql注入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PreparedStatement 防止sql注入的本质，把传递进来的参数当作字符&lt;/p&gt;
&lt;p&gt;若其中有转义字符，比如&lt;code&gt;&#39;&lt;/code&gt;会被直接转义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zd.test03;

import com.zd.test02.utils.JdbcUtils;

import java.sql.*;

public class SQLQustion {
    public static void main(String[] args) {
        // 正常登录
        // SELECT * FROM users WHERE `name` = &#39;张三&#39; AND `password` = &#39;123456&#39;
//        login(&amp;quot;张三&amp;quot;, &amp;quot;123456&amp;quot;);

        // 非法登录
        // SELECT * FROM users WHERE `name` = &#39;&#39; OR &#39;1=1&#39; AND `password` = &#39;&#39; OR &#39;1=1&#39; ,sql语句被拼接
        login(&amp;quot;&#39;&#39; or 1 = 1&amp;quot;, &amp;quot;&#39;&#39; or 1 = 1&amp;quot;);
        // 执行成功 没有返回
    }

    // 登录业务
    public static void login(String userName, String password) {
        Connection conn = null;
        PreparedStatement pst = null;
        ResultSet rs = null;

        try {
            conn = JdbcUtils.getConnect();

            String sql = &amp;quot;SELECT * FROM users WHERE `name` = ? AND `password` = ?&amp;quot;;

            pst = conn.prepareStatement(sql);

            pst.setString(1, userName);
            pst.setString(2, password);

            rs = pst.executeQuery();

            while(rs.next()) {
                System.out.println(rs.getString(&amp;quot;name&amp;quot;));
                System.out.println(rs.getString(&amp;quot;password&amp;quot;));
                System.out.println(&amp;quot;==================&amp;quot;);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.release(conn, pst, rs);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6-事务的jdbc实现&#34;&gt;6. 事务的JDBC实现&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;创建表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE account(
`id` INT AUTO_INCREMENT,
`name` VARCHAR(40),
`money` FLOAT,
PRIMARY KEY(`id`)
);

INSERT INTO account(`name`, `money`)
VALUES
(&#39;A&#39;,1000),(&#39;B&#39;,2000),(&#39;C&#39;,3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// success
package com.zd.test04;

import com.zd.test02.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TestTransaction {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;

        try {
            conn = JdbcUtils.getConnect();

            // 关闭自动提交，会自动开启事务
            conn.setAutoCommit(false);

            String sql1 = &amp;quot;UPDATE account SET `money` = `money` - 100 WHERE `name` = &#39;A&#39;&amp;quot;;
            pst = conn.prepareStatement(sql1);
            pst.executeUpdate();

            // int x = 1 / 0; // 失败，回滚

            String sql2 = &amp;quot;UPDATE account SET `money` = `money` + 100 WHERE `name` = &#39;B&#39;&amp;quot;;
            pst = conn.prepareStatement(sql2);
            pst.executeUpdate();

            // 业务完毕，提交事务
            conn.commit();
            System.out.println(&amp;quot;success&amp;quot;);
        } catch (SQLException e) {
            try {
                conn.rollback(); // 失败，默认回滚，可以不写
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
            e.printStackTrace();
        } finally {
            JdbcUtils.release(conn, pst, null);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;7-数据库连接池&#34;&gt;7. 数据库连接池&lt;/h2&gt;
&lt;p&gt;数据库连接 -- 执行完毕 -- 释放&lt;/p&gt;
&lt;p&gt;连接-- 释放  是十分浪费系统资源的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;池化技术：准备一些预先的资源，过来就连接预先准备好的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最小连接数：10(常用连接)&lt;/p&gt;
&lt;p&gt;最大连接数：100 （业务最高承载上线）&lt;/p&gt;
&lt;p&gt;等待超时：100ms&lt;/p&gt;
&lt;p&gt;编写连接池，实现一个接口DataSource&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;开源数据源实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DBCP&lt;/p&gt;
&lt;p&gt;C3p0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Druid:阿里巴巴&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用了这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了&lt;/p&gt;
">MySQL_09_JDBC</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/ZIAPXpmk6/"" data-c="
          &lt;h2 id=&#34;1-为什么需要设计&#34;&gt;1. 为什么需要设计&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;当数据库比较复杂的时候，我们就需要设计了&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;糟糕的数据库设计&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据冗余，浪费空间&lt;/li&gt;
&lt;li&gt;数据库插入和删除都会麻烦、异常（屏蔽使用物理外键）&lt;/li&gt;
&lt;li&gt;程序的性能差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;良好的数据库设计&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节省内存空间&lt;/li&gt;
&lt;li&gt;保证数据库的完整性&lt;/li&gt;
&lt;li&gt;方便我们开发系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;软件开发中，关于数据库的设计&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析需求，分析业务和需要处理的数据库的需求&lt;/li&gt;
&lt;li&gt;概要设计：设计关系图E-R图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设计数据库的步骤（个人博客）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;收集信息，分析需求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户表（用户登录注销，用户的个人信息，写博客，创建分类）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704162821445.png&#34; alt=&#34;image-20210704162821445&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类表（文章分类，谁创建的）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704163120753.png&#34; alt=&#34;image-20210704163120753&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文章表（文章信息）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704164131400.png&#34; alt=&#34;image-20210704164131400&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评论表&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704164555263.png&#34; alt=&#34;image-20210704164555263&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;友链表（友情链接信息）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704164938625.png&#34; alt=&#34;image-20210704164938625&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义表（系统信息，某个关键的字，或者一些主字段） &lt;code&gt;key:value&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关注表(粉丝数)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704165556127.png&#34; alt=&#34;image-20210704165556127&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;说说表（发表心情， id...content...create_time）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识实体（把需求落到每个字段）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识实体之间的关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写博客：user --&amp;gt; blog&lt;/li&gt;
&lt;li&gt;创建分类：user --&amp;gt; category&lt;/li&gt;
&lt;li&gt;关注：user --&amp;gt; user&lt;/li&gt;
&lt;li&gt;友链：links&lt;/li&gt;
&lt;li&gt;评论：user --&amp;gt; user --&amp;gt; blog&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-数据库三大范式了解&#34;&gt;2. 数据库三大范式（了解）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么需要数据规范化？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息重复&lt;/li&gt;
&lt;li&gt;更新异常&lt;/li&gt;
&lt;li&gt;插入异常
&lt;ul&gt;
&lt;li&gt;无法正常显示信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除异常
&lt;ul&gt;
&lt;li&gt;丢失有效的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;三大范式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;第一范式1nf&#34;&gt;&lt;strong&gt;第一范式（1NF）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;原子性：保证每一列不可再分&lt;/p&gt;
&lt;h3 id=&#34;第二范式2nf&#34;&gt;&lt;strong&gt;第二范式（2NF）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;前提：满足第一范式&lt;/p&gt;
&lt;p&gt;第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。&lt;/p&gt;
&lt;p&gt;每张表只描述一件事情&lt;/p&gt;
&lt;h3 id=&#34;第三范式3nf&#34;&gt;&lt;strong&gt;第三范式（3NF）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;前提：满足第一范式和第二范式&lt;/p&gt;
&lt;p&gt;第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。&lt;/p&gt;
&lt;p&gt;规范数据库的设计&lt;/p&gt;
&lt;h3 id=&#34;规范性和性能的问题&#34;&gt;&lt;strong&gt;规范性和性能的问题&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;关联查询的表不得超过三张表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑商业化的需求和目标（成本，用户体验）数据库的性能更加重要&lt;/li&gt;
&lt;li&gt;在规范性能的问题的时候，需要适当的考虑一下规范性&lt;/li&gt;
&lt;li&gt;故意给某些表增加一些冗余的字段。（从多表查询中变为单表查询）&lt;/li&gt;
&lt;li&gt;故意增加一些计算列（从大数据库降低为小数据量的查询：索引）&lt;/li&gt;
&lt;/ul&gt;
">MySQL_08_规范数据库设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/YMrTb0F0C/"" data-c="
          &lt;h2 id=&#34;1-权限管理&#34;&gt;1. 权限管理&lt;/h2&gt;
&lt;h3 id=&#34;sql-yog-可视化管理&#34;&gt;sql yog 可视化管理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704145840971.png&#34; alt=&#34;image-20210704145840971&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;sql-命令操作&#34;&gt;sql 命令操作&lt;/h3&gt;
&lt;p&gt;用户表：mysql.user&lt;/p&gt;
&lt;p&gt;本质:读这张表进行增删改查&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 创建用户
CREATE USER aa IDENTIFIED BY &#39;123456&#39;;

-- 修改密码(修改当前用户密码)
SET PASSWORD = PASSWORD(&#39;123456&#39;);

-- 修改密码(修改指定用户密码)
SET PASSWORD FOR aa = PASSWORD(&#39;123456&#39;);


-- 重命名  RENAME 原名子 aa TO 新名字;
RENAME USER aa TO newaa;


-- 用户授权  ALL PRIVILEGES 全部的权限，库.表

-- ALL PRIVILEGES 除了给别人授权不行，其他都能干

GRANT ALL PRIVILEGES ON *.* TO newaa;

-- 查询权限

SHOW GRANTS FOR newaa; -- 查看指定用户的权限

SHOW GRANTS FOR root@localhost; -- 查看root用户的权限

-- 撤销权限   REVOKE哪些权限，在哪个库，给谁撤销
REVOKE ALL PRIVILEGES ON *.* FROM newaa;

-- 删除用户
DROP USER newaa;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-mysql备份&#34;&gt;2. MySQL备份&lt;/h2&gt;
&lt;p&gt;为什么要备份？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证重要的数据不丢失&lt;/li&gt;
&lt;li&gt;数据转移&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mysql数据库备份的方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接拷贝物理文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在sqlyog这种可视化工具中手动导出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在想要导出的表或者库中，右键，&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704155338509.png&#34; alt=&#34;image-20210704155338509&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用命令行导出 mysqldump 命令行使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 一张表 mysqldump -h主机 -u用户名 -p密码 数据库 表名 &amp;gt;物理磁盘位置/文件名
mysqldump -hlocalhost -uroot -p123456 school student &amp;gt;D:/a.sql

# 多张表 mysqldump -h主机 -u用户名 -p密码 数据库 表名1 表名2 &amp;gt;物理磁盘位置/文件名
mysqldump -hlocalhost -uroot -p123456 school student result &amp;gt;D:/a.sql

# 数据库 mysqldump -h主机 -u用户名 -p密码 数据库 &amp;gt;物理磁盘位置/文件名
mysqldump -hlocalhost -uroot -p123456 school &amp;gt;D:/a.sql

# 导入
# 登录的情况下，切换到指定的数据库
# source 备份文件
# 也可以这样
mysql -u用户名 -p密码 库名&amp;lt;备份文件
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704161230594.png&#34; alt=&#34;image-20210704161230594&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设你要备份数据库，防止数据丢失。&lt;/p&gt;
&lt;p&gt;把数据库给别人，直接给sql即可。&lt;/p&gt;
">MySQL_07_权限管理和备份</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/TlmET2R1z/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zsql/p/13808417.html&#34;&gt;MySQL索引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.codinglabs.org/articles/theory-of-mysql-index.html&#34;&gt;索引的数据结构和算法&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Msql官方对索引的定义为：&lt;strong&gt;索引（index）是帮助MySQL高效获取数据的数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针&lt;/p&gt;
&lt;p&gt;提取句子主干，就可以得到索引的本质：索引是数据结构&lt;/p&gt;
&lt;p&gt;索引大大提高了查询速度，同时却会降低更新表的速度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-索引的分类&#34;&gt;1. 索引的分类&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/create-index.html&#34;&gt;MySQL索引官网&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个表中，主键索引只能有一个，唯一索引可以有多个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主键索引（primary key）
&lt;ul&gt;
&lt;li&gt;唯一的标识，主键不可重复，只能有一个列作为主键&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;唯一索引 （unique key）
&lt;ul&gt;
&lt;li&gt;避免重复的列出现，可以重复，多个列都可以标示为唯一索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常规索引（key/index）
&lt;ul&gt;
&lt;li&gt;默认的 index 或者 key关键字来设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全文索引（FullText ）
&lt;ul&gt;
&lt;li&gt;在特定的数据库引擎下才有，myisam&lt;/li&gt;
&lt;li&gt;快速定位数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基础语法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 索引的使用

-- 1.在创建表的时候给字段增加索引
-- 2.创建完毕后，增加索引

-- 显示所有的索引信息
SHOW INDEX FROM student;

-- 新增一个索引 (索引名) 列名

ALTER TABLE `student` ADD UNIQUE KEY `UK_IDENTITY_CARD` (`identity_card`);
ALTER TABLE `student` ADD KEY `K_STUDENT_NAME`(`student_name`);

ALTER TABLE `student`  ADD FULLTEXT INDEX `FI_PHONE` (`phone`);

-- explain 分析sql执行的状况

EXPLAIN SELECT * FROM student; -- 非全文索引

EXPLAIN SELECT * FROM student WHERE MATCH(`phone`) AGAINST(&#39;138&#39;); -- 全文索引
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiadajing267/article/details/81269067&#34;&gt;【MySQL优化】——看懂explain&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-测试索引&#34;&gt;2. 测试索引&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE app_user (
    `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,
    `name` VARCHAR(50)  DEFAULT &#39;&#39; COMMENT &#39;用户昵称&#39;,
    `email` VARCHAR(50)  NOT NULL COMMENT &#39;用户邮箱&#39;,
    `phone` VARCHAR(20)  DEFAULT &#39;&#39; COMMENT &#39;手机号&#39;,
    `gender` TINYINT(4)  UNSIGNED DEFAULT &#39;0&#39; COMMENT &#39;性别（0：男  1：女）&#39;,
    `password` VARCHAR(100)  NOT NULL COMMENT &#39;密码&#39;,
    `age` TINYINT(4)  DEFAULT &#39;0&#39; COMMENT &#39;年龄&#39;,
    `create_time` DATETIME  DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
    `update_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,
    PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;app用户表&#39;


-- 插入100万数据b (函数)

DELIMITER $$ -- 写函数之前必须要写，标志
CREATE FUNCTION mock_data()
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE num INT DEFAULT 1000000;
    DECLARE i INT DEFAULT 0;
    WHILE i&amp;lt;num DO
        INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`)
        VALUES(CONCAT(&#39;用户&#39;,i),&#39;123345@qq.com&#39;,CONCAT(&#39;18&#39;,FLOOR(RAND()*((999999999-100000000)+100000000))),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100));
        SET i = i+1;
    END WHILE;
    RETURN i;
END;

-- 执行函数
SELECT mock_data();

SELECT * FROM app_user;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 加索引前
SELECT * FROM app_user WHERE `name` = &#39;用户9999&#39;; -- 0.440 sec
EXPLAIN SELECT * FROM app_user WHERE `name` = &#39;用户9999&#39;;

-- 创建索引
-- id_表名_字段名  索引名
-- CREATE INDEX 索引名 ON 表名(`字段名`);
CREATE INDEX id_app_user_name ON app_user(`name`);
 -- 加索引后
SELECT * FROM app_user WHERE `name` = &#39;用户9999&#39;; -- 0.002 sec
EXPLAIN SELECT * FROM app_user WHERE `name` = &#39;用户9999&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加索引前&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704114603590.png&#34; alt=&#34;image-20210704114603590&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;加索引后&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/zhayuyao/img/raw/master/zhayuyao/img/image-20210704114402938.png&#34; alt=&#34;image-20210704114402938&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;索引在小数据量的时候，用处不大，但是再大数据的时候，区分十分明显&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-索引原则&#34;&gt;3. 索引原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;索引并非越多越好&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;占用磁盘空间&lt;/li&gt;
&lt;li&gt;影响INSERT、DELETE、UPDATE等语句的性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免对经常更新的表进行过多的索引，而对&lt;strong&gt;经常用于查询的字段应该创建索引&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据量小的表最好不要使用索引&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在条件表达式中经常用到的&lt;strong&gt;不同值较多的列上建立索引&lt;/strong&gt;，在不同值很少的列上不要建立索引
&lt;ul&gt;
&lt;li&gt;严重降低数据更新速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;唯一性是某种数据本身的特征时，指定唯一索引&lt;/strong&gt;。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;频繁进行排序或分组&lt;/strong&gt;（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上&lt;strong&gt;建立组合索引&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最适合索引的列是出现在&lt;strong&gt;WHERE子句中的列，或连接子句中指定的列&lt;/strong&gt;，而不是出现在SELECT关键字后的选择列表中的列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用短索引&lt;/strong&gt;。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。
&lt;ul&gt;
&lt;li&gt;能够节省大量索引空间&lt;/li&gt;
&lt;li&gt;可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用最左前缀&lt;/strong&gt;。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。&lt;/li&gt;
&lt;li&gt;对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的&lt;strong&gt;主键&lt;/strong&gt;，则按照主键顺序保存。如果没有主键，但是有&lt;strong&gt;唯一索引&lt;/strong&gt;，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个&lt;strong&gt;内部列&lt;/strong&gt;，按照这个列的&lt;strong&gt;顺序保存&lt;/strong&gt;。按照主键或者内部列进行的访问是最快的，所以InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主&lt;strong&gt;键要尽可能选择较短的数据类型&lt;/strong&gt;，可以有效地减少索引的磁盘占用，提高索引的缓存效果&lt;/li&gt;
&lt;/ul&gt;
">MySQL_06_索引</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/kEulxZRW3/"" data-c="
          &lt;h2 id=&#34;1-事务的相关概念&#34;&gt;1. 事务的相关概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;要么都成功，要么都失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一组sql放到一个批次中去执行&lt;/p&gt;
&lt;h3 id=&#34;事务原则acid原则-原子性-一致性-隔离性-持久性-脏读幻读&#34;&gt;事务原则：ACID原则 原子性 、一致性、隔离性、持久性     （脏读，幻读。。。）&lt;/h3&gt;
&lt;p&gt;参考博客链接：&lt;a href=&#34;https://blog.csdn.net/dengjili/article/details/82468576&#34;&gt;事务ACID理解&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/27/I8RZDmGrpOKo6ug.png&#34; alt=&#34;事务转账例子.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要么都成功，要么都失败&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务前后的数据完整性要保持一致&lt;/p&gt;
&lt;p&gt;下图操作前和操作后的总和都是1000&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;持久性（Durability）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务一旦移交不可逆，被持久化到数据库中&lt;/p&gt;
&lt;h3 id=&#34;隔离所导致的一些问题&#34;&gt;隔离所导致的一些问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;脏读&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、在事务A执行过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据。&lt;/p&gt;
&lt;p&gt;2、由于某些原因，事务A并没有完成提交，发生了RollBack操作，则事务B读取的数据就是脏数据。&lt;/p&gt;
&lt;p&gt;这种&lt;strong&gt;读取到另一个事务未提交的数据的现象就是脏读(Dirty Read)。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/27/GJyRnpCUImgwrb3.png&#34; alt=&#34;脏读.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。&lt;/p&gt;
&lt;p&gt;这种&lt;strong&gt;在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/27/G34RZp6F79PfAbW.png&#34; alt=&#34;不可重复读.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚读(幻读)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。&lt;/p&gt;
&lt;p&gt;幻读和不可重复读有些类似，但是&lt;strong&gt;幻读强调的是集合的增减，而不是单条数据的更新。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/27/OsMQfZEclhkRCnX.png&#34; alt=&#34;幻读.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一类更新丢失&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务A和事务B都对数据进行更新，但是事务A由于某种原因事务回滚了，把已经提交的事务B的更新数据给覆盖了。这种现象就是第一类更新丢失。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/27/jZB4nTvHPIg8w6o.png&#34; alt=&#34;第一类更新丢失.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第二类更新丢失&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实跟第一类更新丢失有点类似，也是两个事务同时对数据进行更新，但是事务A的更新把已提交的事务B的更新数据给覆盖了。这种现象就是第二类更新丢失。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/27/yv8CMOAlKTr73Yo.png&#34; alt=&#34;第二类更新丢失.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;事务隔离级别&#34;&gt;事务隔离级别&lt;/h3&gt;
&lt;p&gt;为了解决以上的问题，主流的关系型数据库都会提供四种事务的隔离级别。事务隔离级别从低到高分别是：读未提交，读已提交，可重复读，串行化。事务隔离级别越高，越能保证数据的一致性和完整性，但是执行效率也越低，所以在设置数据库的事务隔离级别时需要做一下权衡，mysql默认是可重复读&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读未提交(Read Uncommitted)，是最低的隔离级别，**所有的事务都可以看到其他未提交的事务的执行结果。**只能防止第一类更新丢失，不能解决脏读，可重复读，幻读，所以很少应用于实际项目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读已提交&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读已提交(Read Committed)，在该隔离级别下，**一个事务的更新操作只有在该事务提交之后，另外一个事务才可能读取到同一笔数据更新后的结果。**可以防止脏读和第一类更新丢失，但是不能解决可重复和幻读的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重复读（重要）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可重复读(Repeatable Read)，mysql默认的隔离级别。在该隔离级别下，&lt;strong&gt;一个事务多次读同一个数据，在这个事务还没有结束时，其他事务不能访问该数据（包括了读写）&lt;/strong&gt;，这样就可以在同一个事务内两次读到的数据是一样的。可以防止脏读、不可重复读、第一类更新丢失，第二类更新丢失的问题，不过还是会出现幻读。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串行化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;串行化(Serializable)，这是最高的隔离级别。它要求事务序列化执行，事务只能一个接着一个的执行，不能并发执行。在这个级别，可以解决上面提到的所有并发问题，但是可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;th&gt;第一类更新丢失&lt;/th&gt;
&lt;th&gt;第二类更新丢失&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Read Uncommitted&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Read Committed&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Repeatable Read&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Serializable&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-扩展回滚机制&#34;&gt;2. 扩展：回滚机制&lt;/h2&gt;
&lt;p&gt;在mysql中，恢复机制是通过回滚日志（undo log）实现的，所有的事务进行的修改都会先记录到这个回滚日志中，然后在堆数据库中的对应进行写入。&lt;/p&gt;
&lt;p&gt;mysql的事务是由redo和undo的，redo操作的所有信息都是记录到重做日志（redo_log）中，也就是说当一个事务做commit操作时，需要先把这个事务的操作写到redo_log中，然后在把这些操作flush到磁盘上，当出现故障时，只需要读取redo_log，然后在重新flush到磁盘就行了。&lt;/p&gt;
&lt;p&gt;而对于undo就比较麻烦，mysql在处理事务时，会在数据共享表空间里申请一个段就做segment段，用保存undo信息，当在处理rollback，不是完完全全的物理undo，而是逻辑undo，也就是说会之前的操作进行反操作（对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。），但是这些共享表空间是不进行回收的。这些表空间的回收需要由mysql的master thread进程进行回收。&lt;/p&gt;
&lt;h2 id=&#34;3-事务实例&#34;&gt;3. 事务实例&lt;/h2&gt;
&lt;h3 id=&#34;执行事务操作&#34;&gt;执行事务操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;
-- 事务
-- mysql 是默认开启事务自动提交

-- 关闭
SET autocommit = 0; 
-- 开启（默认的）
SET autocommit = 1;

-- 手动处理事务

SET autocommit = 0;  -- 关闭自动提交

-- 事务开启
START TRANSACTION;  -- 标记一个事务的开始，从这个之后的sql都在同一个事务内

INSERT XX
INSERT XX

-- 提交 ： 持久化
COMMIT;
-- 回滚 ： 回到的原来的样子（失败）
ROLLBACK;
-- 事务结束
SET autocommit = 1; -- 开启自动提交

-- 了解
SAVEPOINT 保存点名 -- 设置一个事务的保存点
ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点
RELEASE SAVEPOINT 保存点名 -- 撤销保存点
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模拟转账场景&#34;&gt;模拟转账场景&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 转账

-- 创建数据库
CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci;

-- 使用shop数据库
USER `shop`;


-- 建表
CREATE TABLE `account`(
  `id` INT(3) NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(100) NOT NULL,
  `money` DECIMAL(9,2) NOT NULL,
  PRIMARY KEY (`id`)
)ENGINE=INNODB DEFAULT CHARSET=utf8;

-- 初始化数据
INSERT INTO account(`name`,`money`)
VALUES(&#39;A&#39;,2000.00),
(&#39;B&#39;,10000.00);

-- 模拟转账
SET autocommit = 0; -- 关闭自动提交

START TRANSACTION; -- 开启事务 （一组事务）

UPDATE account SET `money`=`money`-500 WHERE `name`=&#39;A&#39;; -- A减500
UPDATE account SET `money`=`money`+500 WHERE `name`=&#39;B&#39;; -- B加500

COMMIT; -- 提交事务，就会被持久化了

ROLLBACK; -- 回滚

SET autocommit = 1; -- 恢复自动提交
&lt;/code&gt;&lt;/pre&gt;
">MySQL_05_事务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/1c5B254lO/"" data-c="
          &lt;p&gt;官网：&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/built-in-function-reference.html&#34;&gt;内置函数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;菜鸟教程：&lt;a href=&#34;https://www.runoob.com/mysql/mysql-functions.html&#34;&gt;MySQL函数&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-常用函数&#34;&gt;1. 常用函数&lt;/h2&gt;
&lt;h3 id=&#34;数学运算&#34;&gt;数学运算&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT ABS(-8)	-- 绝对值，8

SELECT CEILING(9.4)  -- 向上取整，10

SELECT FLOOR(9.4)  -- 向下取整，9

SELECT RAND()  -- 返回一个0~1之间的随机数

SELECT SIGN(-2)  -- 判断值的符号，正数返回1，零返回0，附属返回-1，-1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;字符串函数&#34;&gt;字符串函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT CHAR_LENGTH(&#39;返回字符串长度&#39;) -- 返回字符串长度，7

SELECT CONCAT(&#39;hello&#39;,&#39; &#39;,&#39;My&#39;,&#39;SQL&#39;)  -- 拼接字符串，hello MySQL

SELECT INSERT(&#39;我爱MySQL&#39;,2,1,&#39;超级热爱&#39;); -- 插入/替换，我超级热爱MySQL

SELECT LOWER(&#39;ILoveMySQL&#39;) -- 返回小写，ilovemysql

SELECT UPPER(&#39;ILoveMySQL&#39;) -- 返回大写，ILOVEMYSQL

SELECT REPLACE(&#39;I Love Love MySQL&#39;,&#39;Love&#39;,&#39;Hate&#39;)  -- 用指定字符串替换出现的字符串，I Hate Hate MySQL

SELECT INSTR(&#39;I Love Love MySQL&#39;,&#39;Love&#39;)  -- 返回第一次出现的子串的索引，3

SELECT SUBSTR(&#39;I Love Love MySQL&#39;,8,17)  -- 返回指定索引的字符串，Love MySQL

SELECT REVERSE(&#39;你是心中的恋爱&#39;)  -- 反转，爱恋的中心是你
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;时间和日期&#34;&gt;时间和日期&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT CURRENT_DATE()  -- 返回当前日期，YYYY-MM-DD

SELECT CURDATE()  -- 返回当前日期，YYYY-MM-DD

SELECT NOW() -- 返回当前时间，YYYY-MM-DD hh:mm:ss

SELECT LOCALTIME() -- 返回本地时间，YYYY-MM-DD hh:mm:ss

SELECT SYSDATE() -- 返回系统时间，YYYY-MM-DD hh:mm:ss

SELECT YEAR(NOW())
SELECT MONTH(NOW())
SELECT DAY(NOW())
SELECT HOUR(NOW())
SELECT MINUTE(NOW())
SELECT SECOND(NOW())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;系统&#34;&gt;系统&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT SYSTEM_USER()

SELECT USER()

SELECT VERSION()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-聚合函数常用&#34;&gt;2. 聚合函数（常用）&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;count()&lt;/td&gt;
&lt;td&gt;计数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sum()&lt;/td&gt;
&lt;td&gt;求和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;avg()&lt;/td&gt;
&lt;td&gt;平均值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max()&lt;/td&gt;
&lt;td&gt;最大值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;min()&lt;/td&gt;
&lt;td&gt;最小值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 聚合函数
-- 都能统计 表中数据

-- count(字段) 会忽略所有的null值(想查询一个表中有多少个记录，就使用这个count())
SELECT COUNT(student_name) FROM student;
-- COUNT(*) 不会忽略所有的null值 本质计算行数
SELECT COUNT(*) FROM student;
-- COUNT(1) 不会忽略所有的null值 本质计算行数
SELECT COUNT(1) FROM student;


SELECT SUM(student_result) AS &#39;总和&#39; FROM result;
SELECT AVG(student_result) AS &#39;平均分&#39; FROM result;
SELECT MAX(student_result) AS &#39;最高分&#39; FROM result;
SELECT MIN(student_result) AS &#39;最低分&#39; FROM result;

-- 查询不同课程的平均分，最高分，最低分
SELECT sub.subject_name AS &#39;课程&#39;,
AVG(res.student_result) AS &#39;平均分&#39;,
MAX(res.student_result) AS &#39;最高分&#39;,
MIN(res.student_result) AS &#39;最低分&#39;
FROM result res
INNER JOIN `subject` sub
ON res.`subject_no`=sub.`subject_no`
GROUP BY res.`subject_no`
HAVING AVG(res.student_result) &amp;gt;80;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-数据库级别的md5加密拓展&#34;&gt;3. 数据库级别的MD5加密（拓展）&lt;/h2&gt;
&lt;p&gt;MD5：增加算法复杂度和不可逆性。&lt;/p&gt;
&lt;p&gt;MD5不可逆，具体的值的md5是一样的&lt;/p&gt;
&lt;p&gt;MD5破解网站的原理，背后有一个字典，MD5加密后的值，加密前的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE `testmd5`(
    `id` INT(4) NOT NULL,
    `name` VARCHAR(20) NOT NULL,
    `pwd` VARCHAR(50) NOT NULL,
    PRIMARY KEY (`id`)
)ENGINE=INNODB DEFAULT CHARSET=utf8;

-- 明文密码
INSERT INTO `testmd5`(`id`,`name`,`pwd`)
VALUES
(1,&#39;张三&#39;,&#39;111111&#39;),
(2,&#39;李四&#39;,&#39;123456&#39;),
(3,&#39;王五&#39;,&#39;123456&#39;);


SELECT * FROM `testmd5`;

-- 加密
UPDATE testmd5 SET pwd=MD5(pwd) 
WHERE id=2;

-- 插入的时候加密
INSERT INTO `testmd5`(`id`,`name`,`pwd`)
VALUES
(4,&#39;小明&#39;,MD5(&#39;123456&#39;));

-- 如何校验，将用户传递进来的密码，进行MD5加密，然后比对加密后的值

SELECT * FROM `testmd5`
WHERE `name`=&#39;小明&#39;
AND pwd = MD5(&#39;123456&#39;);
&lt;/code&gt;&lt;/pre&gt;
">MySQL_04_函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/lwJF2vSoV/"" data-c="
          &lt;p&gt;DQL(Date Query Language):数据查询语言&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select 语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT [ALL | DISTINCT]
{* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]}
FROM table_name [as table_alias]
    [left | right | inner join table_name2]  -- 联合查询
    [WHERE ...]  -- 指定结果需满足的条件
    [GROUP BY ...]  -- 指定结果按照哪几个字段来分组
    [HAVING ...]  -- 过滤分组的记录必须满足的次要条件
    [ORDER BY ...]  -- 指定查询记录按一个或多个条件排序
    [LIMIT {[offset,]row_count | row_countOFFSET offset}]; --  指定查询的记录从哪条至哪条
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：[]括号代表可选的，{}括号代表必选的&lt;/p&gt;
&lt;h2 id=&#34;1-指定查询字段&#34;&gt;1. 指定查询字段&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DROP DATABASE IF EXISTS `school`;
-- 创建一个school数据库
CREATE DATABASE IF NOT EXISTS `school`;
-- 使用school数据库
USE `school`;
-- 创建学生表
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student`(
    `student_no` INT(4) NOT NULL COMMENT &#39;学号&#39;,
    `login_pwd` VARCHAR(20) DEFAULT NULL,
    `student_name` VARCHAR(20) DEFAULT NULL COMMENT &#39;学生姓名&#39;,
    `sex` TINYINT(1) DEFAULT NULL COMMENT &#39;性别，0或1&#39;,
    `grade_id` INT(11) DEFAULT NULL COMMENT &#39;年级编号&#39;,
    `phone` VARCHAR(50) NOT NULL COMMENT &#39;联系电话&#39;,
    `address` VARCHAR(255) NOT NULL COMMENT &#39;地址&#39;,
    `born_date` DATETIME DEFAULT NULL COMMENT &#39;出生时间&#39;,
    `email` VARCHAR (50) NOT NULL COMMENT &#39;邮箱账号&#39;,
    `identity_card` VARCHAR(18) DEFAULT NULL COMMENT &#39;身份证号&#39;,
    PRIMARY KEY (`student_no`)
)ENGINE=INNODB DEFAULT CHARSET=utf8;

-- 创建年级表
DROP TABLE IF EXISTS `grade`;
CREATE TABLE `grade`(
  `grade_id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &#39;年级编号&#39;,
  `grade_name` VARCHAR(50) NOT NULL COMMENT &#39;年级名称&#39;,
   PRIMARY KEY (`grade_id`)
) ENGINE=INNODB DEFAULT CHARSET = utf8;

-- 创建科目表
DROP TABLE IF EXISTS `subject`;
CREATE TABLE `subject`(
  `subject_no`INT(11) NOT NULL AUTO_INCREMENT COMMENT &#39;课程编号&#39;,
  `subject_name` VARCHAR(50) DEFAULT NULL COMMENT &#39;课程名称&#39;,
  `class_hour` INT(4) DEFAULT NULL COMMENT &#39;学时&#39;,
  `grade_id` INT(4) DEFAULT NULL COMMENT &#39;年级编号&#39;,
   PRIMARY KEY (`subject_no`)
)ENGINE = INNODB  DEFAULT CHARSET = utf8;

-- 创建成绩表
DROP TABLE IF EXISTS `result`;
CREATE TABLE `result`(
  `student_no` INT(4) NOT NULL COMMENT &#39;学号&#39;,
  `subject_no` INT(4) NOT NULL COMMENT &#39;课程编号&#39;,
  `exam_date` DATETIME NOT NULL COMMENT &#39;考试日期&#39;,
  `student_result` INT (4) NOT NULL COMMENT &#39;考试成绩&#39;
  )ENGINE = INNODB DEFAULT CHARSET = utf8;
  
-- 插入学生数据 其余自行添加 这里只添加了2行
INSERT INTO `student` (`student_no`,`login_pwd`,`student_name`,`sex`,`grade_id`,`phone`,`address`,`born_date`,`email`,`identity_card`)
VALUES
(1000,&#39;123456&#39;,&#39;张伟&#39;,0,2,&#39;13800001234&#39;,&#39;北京朝阳&#39;,&#39;1980-1-1&#39;,&#39;text123@qq.com&#39;,&#39;123456198001011234&#39;),
(1001,&#39;123456&#39;,&#39;赵强&#39;,1,3,&#39;13800002222&#39;,&#39;广东深圳&#39;,&#39;1990-1-1&#39;,&#39;text111@qq.com&#39;,&#39;123456199001011233&#39;);

-- 插入年级数据
INSERT INTO `grade` (`grade_id`,`grade_name`) VALUES(1,&#39;大一&#39;),(2,&#39;大二&#39;),(3,&#39;大三&#39;),(4,&#39;大四&#39;),(5,&#39;预科班&#39;);

-- 插入科目数据
INSERT INTO `subject`(`subject_no`,`subject_name`,`class_hour`,`grade_id`)VALUES
(1,&#39;高等数学-1&#39;,110,1),
(2,&#39;高等数学-2&#39;,110,2),
(3,&#39;高等数学-3&#39;,100,3),
(4,&#39;高等数学-4&#39;,130,4),
(5,&#39;C语言-1&#39;,110,1),
(6,&#39;C语言-2&#39;,110,2),
(7,&#39;C语言-3&#39;,100,3),
(8,&#39;C语言-4&#39;,130,4),
(9,&#39;Java程序设计-1&#39;,110,1),
(10,&#39;Java程序设计-2&#39;,110,2),
(11,&#39;Java程序设计-3&#39;,100,3),
(12,&#39;Java程序设计-4&#39;,130,4),
(13,&#39;数据库结构-1&#39;,110,1),
(14,&#39;数据库结构-2&#39;,110,2),
(15,&#39;数据库结构-3&#39;,100,3),
(16,&#39;数据库结构-4&#39;,130,4),
(17,&#39;C#基础&#39;,130,1);

-- 插入成绩数据  这里仅插入了一组，其余自行添加
INSERT INTO `result`(`student_no`,`subject_no`,`exam_date`,`student_result`)
VALUES
(1000,1,&#39;2013-11-11 16:00:00&#39;,85),
(1000,2,&#39;2013-11-12 16:00:00&#39;,70),
(1000,3,&#39;2013-11-11 09:00:00&#39;,68),
(1000,4,&#39;2013-11-13 16:00:00&#39;,98),
(1000,5,&#39;2013-11-14 16:00:00&#39;,58);

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  -- 查询全部的学生   SELECT 字段 FROM 表名;
  SELECT * FROM student;
  
  -- 查询指定字段
  SELECT student_name, student_no FROM student;
  
  -- 别名，给结果起一个名字 AS  可以给字段起别名，也可以给表起别名
  
  SELECT student_name AS &#39;学号&#39;, student_no AS &#39;姓名&#39; FROM student;
  
  -- 函数 concat(a,b)
  SELECT CONCAT(&#39;姓名：&#39;, student_no)  AS &#39;新姓名&#39; FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;有的时候，列表名不是那么见名知意，我们可以使用别名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;去重-distinct&#34;&gt;去重 distinct&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  -- 查询全部的考试成绩
  SELECT * FROM result;
  -- 查询有哪些同学参加了考试
  SELECT `student_no` FROM result;
  -- 发现重复数据，去重
  SELECT DISTINCT `student_no` FROM result;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据库的列表达式&#34;&gt;数据库的列（表达式）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 查询系统版本（函数）
SELECT VERSION();

-- 用来计算（表达式）
SELECT 100*3 -1 ;

-- 查询自增的步长（变量）
SELECT @@auto_increment_increment;

-- 学员考试成绩 +1 查看
SELECT `student_no`,`student_result` + 1 AS &#39;提分后&#39; FROM result;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据库中的表达式： 文本值，列，Null，函数，计算表达式，系统变量&lt;/p&gt;
&lt;p&gt;select `表达式` from 表名&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-where条件子句-select-中的使用&#34;&gt;2. WHERE条件子句 SELECT 中的使用&lt;/h2&gt;
&lt;p&gt;作用：检索数据中&lt;strong&gt;符合条件&lt;/strong&gt;的值&lt;/p&gt;
&lt;p&gt;搜索的条件由一个或多个表达式组成，结果返回布尔值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 查询考试成绩在 95 ~ 100分之间

SELECT student_no,student_result FROM result;

-- and
SELECT student_no,student_result FROM result
WHERE student_result&amp;gt;=80 AND student_result&amp;lt;=100;
-- &amp;amp;&amp;amp; 
SELECT student_no,student_result FROM result
WHERE student_result&amp;gt;=80 &amp;amp;&amp;amp; student_result&amp;lt;=100;

-- 模糊查询（区间）
SELECT student_no,student_result FROM result
WHERE student_result BETWEEN 80 AND 100;

-- 除了1000号学生之外的学生的成绩
-- !=
SELECT student_no,student_result FROM result
WHERE student_result BETWEEN 80 AND 100
AND student_result!=98;
-- not
SELECT student_no,student_result FROM result
WHERE student_result BETWEEN 80 AND 100
AND NOT student_result=98;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模糊查询比较运算符&#34;&gt;模糊查询：比较运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IS NULL&lt;/td&gt;
&lt;td&gt;a is null&lt;/td&gt;
&lt;td&gt;如果操作符为null，结果为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IS NOT NULL&lt;/td&gt;
&lt;td&gt;a is not null&lt;/td&gt;
&lt;td&gt;如果操作符不为null，结果为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BWTWEEN...AND...&lt;/td&gt;
&lt;td&gt;a between b and c&lt;/td&gt;
&lt;td&gt;若a在b和c之间，则结果为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;LIKE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a like b&lt;/td&gt;
&lt;td&gt;SQL匹配，如果a匹配b,则结果为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;a in (a1,a2,a3,...)&lt;/td&gt;
&lt;td&gt;假设a在a1或者a2或者a3,...其中的某一个，则结果为真&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;
-- 查询姓刘的同学

-- like 结合 
--   %（代表0到任意个字符）
--   _（代表1）

-- 查询姓刘的同学
SELECT `student_no`,`student_name` FROM `student`
WHERE `student_name` LIKE &#39;刘%&#39;;

-- 查询姓刘的同学，名字后面只有一个字的
SELECT `student_no`,`student_name` FROM `student`
WHERE `student_name` LIKE &#39;刘_&#39;;

-- 查询姓刘的同学，名字后面有两个字的
SELECT `student_no`,`student_name` FROM `student`
WHERE `student_name` LIKE &#39;刘__&#39;;

-- 查询名字中间有嘉字的同学
SELECT `student_no`,`student_name` FROM `student`
WHERE `student_name` LIKE &#39;%嘉%&#39;;


-- in (具体的一个或者多个值)
-- 查询学号1001,1002,1003号学号
SELECT `student_no`,`student_name` FROM `student`
WHERE student_no IN (&#39;1001&#39;,&#39;1002&#39;,&#39;1003&#39;);
-- 查询在北京的学生
SELECT `student_no`,`student_name` FROM `student`
WHERE `address` IN (&#39;北京&#39;);


-- null
-- 查询地址为空的学生
SELECT `student_no`,`student_name` FROM `student`
WHERE `address` = &#39;&#39; OR address IS NULL;

-- not null
-- 查询有出生日期的同学 不为空
SELECT `student_no`,`student_name` FROM `student`
WHERE `born_date` IS NOT NULL;

-- 查询没有出生日期的同学 为空
SELECT `student_no`,`student_name` FROM `student`
WHERE `born_date` IS NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-联表查询join&#34;&gt;3. 联表查询（join）&lt;/h2&gt;
&lt;h3 id=&#34;七种join对比&#34;&gt;七种join对比&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/26/B4vuxsynzr5RL9j.png&#34; alt=&#34;joins.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;MySQL中没有&lt;code&gt;... FULL OUTER JOIN ...&lt;/code&gt;操作，用&lt;code&gt;union&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 全连接（左连接 union 右连接）
SELECT &amp;lt;select_list&amp;gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key
union
SELECT &amp;lt;select_list&amp;gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;

-- A、B各自独有的
SELECT &amp;lt;select_list&amp;gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL
union
SELECT &amp;lt;select_list&amp;gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;--   =========连表查询==================

-- 查询参加了考试的同学（学号，姓名，科目编号，分数）
SELECT * FROM student;
SELECT * FROM result;

-- join on 连接查询
-- where 等值查询

-- inner join
SELECT st.`student_no`,st.`student_name`,re.`subject_no`,re.`student_result` 
FROM student AS st
INNER JOIN result AS re 
ON st.`student_no`=re.`student_no`;

-- right join
SELECT st.`student_no`,st.`student_name`,re.`subject_no`,re.`student_result` 
FROM student st
RIGHT JOIN result re 
ON st.`student_no`=re.`student_no`;

-- left join
SELECT st.`student_no`,st.`student_name`,re.`subject_no`,re.`student_result` 
FROM student st
LEFT JOIN result re
ON st.`student_no`=re.`student_no`;

-- 查询缺考的同学
SELECT st.`student_no`,st.`student_name`,re.`subject_no`,re.`student_result` 
FROM student st
LEFT JOIN result re ON 
st.`student_no`=re.`student_no`
WHERE re.`student_result` IS NULL;

-- 查询了参加考试的同学信息（学号，学生姓名，科目名称，分数）
SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`
FROM `student` stu
RIGHT JOIN `result` res 
ON res.`student_no`=stu.`student_no`
INNER JOIN `subject` sub
ON res.`subject_no`=sub.`subject_no`;

-- 查询学员所属的年级（学号，学生的姓名，年级名称）
SELECT `student_no`,`student_name`,`grade_name`
FROM student stu
INNER JOIN `grade` gra
ON stu.`grade_id`=gra.`grade_id`;

-- 查询了参加数据结构-1考试的同学信息（学号，学生姓名，科目名称，分数）
SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`
FROM student stu
INNER JOIN `result` res
ON stu.`student_no` = res.`student_no`
INNER JOIN `subject` sub
ON res.`subject_no`=sub.`subject_no`
WHERE sub.`subject_name`=&#39;数据结构-1&#39;;


-- 要查询哪些数据 select ...
-- 从哪几个表中查 from 表 XXX join 连接的表 on 交叉条件
-- 假设存在一种多张表查询，慢慢来，先查询两张表然后再慢慢增加
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;inner join&lt;/td&gt;
&lt;td&gt;如果表中至少有一个匹配，就返回行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;left join&lt;/td&gt;
&lt;td&gt;会从左边中返回所有的值，即使右表中没有匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;right join&lt;/td&gt;
&lt;td&gt;会从右边中返回所有的值，即使左表中没有匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;自连接&#34;&gt;自连接&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;自连接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自己的表和自己的表连接，核心：&lt;strong&gt;一张表拆为两张一样的表即可&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 创建表
-- unsigned 无符号
-- auto_increment=9 自增的起始值
DROP TABLE IF EXISTS `category` ;
CREATE TABLE `category` (
  `category_id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;主题id&#39;,
  `pid` INT(10) NOT NULL COMMENT &#39;父id&#39;,
  `category_name` VARCHAR(50) NOT NULL COMMENT &#39;主题名字&#39;,
  PRIMARY KEY (`category_id`)
) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- 插入值
INSERT INTO `category`(`category_id`,`pid`,`category_name`)
VALUES(&#39;2&#39;,&#39;1&#39;,&#39;信息技术&#39;),
(&#39;3&#39;,&#39;1&#39;,&#39;软件开发&#39;),
(&#39;4&#39;,&#39;3&#39;,&#39;数据库&#39;),
(&#39;5&#39;,&#39;1&#39;,&#39;美术设计&#39;),
(&#39;6&#39;,&#39;3&#39;,&#39;web开发&#39;),
(&#39;7&#39;,&#39;5&#39;,&#39;ps技术&#39;),
(&#39;8&#39;,&#39;2&#39;,&#39;办公信息&#39;);

SELECT * FROM `category`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;pid&lt;/th&gt;
&lt;th&gt;category_id&lt;/th&gt;
&lt;th&gt;category_name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;信息技术&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;软件开发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;美术设计&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;子类&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;pid&lt;/th&gt;
&lt;th&gt;category_id&lt;/th&gt;
&lt;th&gt;category_name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;办公信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;web开发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;ps技术&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;操作：查询父类对应的子类关系&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;父类&lt;/th&gt;
&lt;th&gt;子类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;信息技术&lt;/td&gt;
&lt;td&gt;办公信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;软件开发&lt;/td&gt;
&lt;td&gt;数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;软件开发&lt;/td&gt;
&lt;td&gt;web开发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;美术设计&lt;/td&gt;
&lt;td&gt;ps技术&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 查询父子信息，把一张表看为两个一模一样的表
SELECT a.`category_name` AS &#39;父栏目&#39;,b.`category_name` AS &#39;子栏目&#39;
FROM `category` AS a, `category` AS b
WHERE a.`category_id`=b.`pid`;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-分页和排序&#34;&gt;4. 分页和排序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 排序： 升序 ASC  降序 DESC
-- ORDER BY 通过那个字段排序，怎么排
-- 查询的结果根据成绩降序 排序
SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`
FROM student stu
INNER JOIN `result` res
ON stu.`student_no` = res.`student_no`
INNER JOIN `subject` sub
ON res.`subject_no`=sub.`subject_no`
WHERE sub.`subject_name`=&#39;数据结构-1&#39;
ORDER BY `student_result` DESC;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 100w
-- 为什么要分页？
-- 缓解数据库压力，给人更好的体验   瀑布流
-- 分页，每页只显示五条数据
-- 语法 ： limit 起始值，页面的大小
-- 网页应用：当前页，总的页数，每页大小
-- LIMIT 0,5    1~5
-- LIMIT 1,5    2~6
-- LIMIT 6,5
SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`
FROM student stu
INNER JOIN `result` res
ON stu.`student_no` = res.`student_no`
INNER JOIN `subject` sub
ON res.`subject_no`=sub.`subject_no`
WHERE sub.`subject_name`=&#39;数据结构-1&#39;
ORDER BY `student_result` DESC
LIMIT 1,5;
-- 第一页 limit 0,5    (1-1)*5
-- 第二页 limit 5,5    (2-1)*5
-- 第三页 limit 10,5   (3-1)*5
-- 第N页 limit (n-1)*5,5    (n-1)*pageSize,pageSize
-- pageSize,页面大小
-- (n-1)*pageSize，起始值
-- n，当前页
-- 总页数 = (数据总数%页面大小==0)? (数据总数/页面大小) : (数据总数/页面大小 + 1)

-- 查询科目高等数学-2，课程成绩排名前十的学生，并且分数要大于60的学生信息（学号，姓名，课程名称，分数）
SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`
FROM student stu
INNER JOIN `subject` sub
ON stu.`grade_id`=sub.`grade_id`
INNER JOIN `result` res
ON sub.`subject_no`=res.`subject_no`
WHERE sub.`subject_name`=&#39;高等数学-2&#39;
AND res.`student_result`&amp;gt;60
ORDER BY res.`student_result` DESC
LIMIT 0,10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;语法： &lt;code&gt;limit 查询起始下标,页面大小&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-子查询&#34;&gt;5. 子查询&lt;/h2&gt;
&lt;p&gt;where（这个值是计算出来的）&lt;/p&gt;
&lt;p&gt;本质：&lt;code&gt;在where语句中嵌套一个子查询语句&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;
-- 1.查询数据库结构-1的所有考试结果（学号，科目名，成绩），降序排列
-- 方式1：使用连接查询
SELECT res.`student_no`,res.`subject_no`,res.`student_result`
FROM `result` res
INNER JOIN `subject` sub
ON res.`subject_no`=sub.`subject_no`
WHERE sub.`subject_name`=&#39;高等数学-2&#39;
ORDER BY res.`student_result` DESC;


-- 使用子查询(由里及外)
SELECT res.`student_no`,res.`subject_no`,res.`student_result`
FROM `result` res
WHERE res.`subject_no` = (
    SELECT sub.`subject_no`
    FROM `subject` sub
    WHERE sub.`subject_name`=&#39;高等数学-2&#39;
)
ORDER BY res.`student_result` DESC;

-- 分数不小于80分的学生的学号和姓名

SELECT DISTINCT stu.`student_no`,stu.`student_name`
FROM student stu
INNER JOIN result res
ON stu.`student_no`=res.`student_no`
WHERE res.`student_result` &amp;gt; 80;


-- 在这个基础上增加一个科目，查询课程为高等数学-2，且分数不小于80分的学生的学号和姓名
SELECT DISTINCT stu.`student_no`,stu.`student_name`
FROM student stu
INNER JOIN result res
ON stu.`student_no`=res.`student_no`
WHERE res.`student_result` &amp;gt; 80
AND res.`subject_no`=(
SELECT sub.`subject_no` FROM `subject` sub
WHERE sub.`subject_name`=&#39;高等数学-2&#39;
);


SELECT DISTINCT stu.`student_no`,stu.`student_name`
FROM student stu
INNER JOIN result res
ON stu.`student_no`=res.`student_no`
INNER JOIN `subject` sub
ON res.`subject_no`=sub.`subject_no`
WHERE sub.`subject_name`=&#39;高等数学-2&#39;
AND res.`student_result` &amp;gt; 80;

--  子查询（由里及外）
SELECT DISTINCT `student_no`,`student_name` 
FROM student 
WHERE student_no IN (
    SELECT student_no 
    FROM result 
    WHERE `student_result` &amp;gt; 80 
    AND subject_no = (
        SELECT subject_no 
        FROM `subject` 
        WHERE `subject_name`=&#39;高等数学-2&#39;
    )
);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6-分组和过滤&#34;&gt;6. 分组和过滤&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;[GROUP BY ...]  -- 指定结果按照哪几个字段来分组
[HAVING ...]  -- 过滤分组的记录必须满足的次要条件

-- 查询不同课程的平均分，最高分，最低分
SELECT sub.subject_name AS &#39;课程&#39;,
AVG(res.student_result) AS &#39;平均分&#39;,
MAX(res.student_result) AS &#39;最高分&#39;,
MIN(res.student_result) AS &#39;最低分&#39;
FROM result res
INNER JOIN `subject` sub
ON res.`subject_no`=sub.`subject_no`
GROUP BY res.`subject_no`
HAVING AVG(res.student_result) &amp;gt;80;
&lt;/code&gt;&lt;/pre&gt;
">MySQL_03_DQL查询数据语言</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/9N5dMuR4p/"" data-c="
          &lt;h2 id=&#34;1-外键了解&#34;&gt;1. 外键（了解）&lt;/h2&gt;
&lt;h3 id=&#34;方式一在创建表的时候增加外键约束&#34;&gt;方式一：在创建表的时候，增加外键约束&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 学生表students的 gradeid 字段要去引用年级表的 gradeid 字段

CREATE TABLE IF NOT EXISTS `students`(
    `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,
    `name` VARCHAR(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,
    `password` VARCHAR(10) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,
    `sex` VARCHAR(2) NOT NULL DEFAULT &#39;女&#39; COMMENT &#39;性别&#39;,
    `birthday` DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,
    `gradeid` INT(10) NOT NULL COMMENT &#39;学生的年纪&#39;,
    `address` VARCHAR(110) DEFAULT NULL COMMENT &#39;家庭地址&#39;,
    `email` VARCHAR(50) DEFAULT NULL COMMENT &#39;电子邮箱&#39;,
    PRIMARY KEY(`id`),
    KEY `FK_gradeid`(`gradeid`),    -- 定义外键key
    CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`)    -- 给这个外键添加约束（执行引用）  references引用
)ENGINE = INNODB DEFAULT CHARSET = utf8;

CREATE TABLE IF NOT EXISTS `grade`(
    `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;年级id&#39;,
    `gradename` VARCHAR(50) NOT NULL COMMENT &#39;年级名称&#39;,
    PRIMARY KEY(`gradeid`)
)ENGINE = INNODB DEFAULT CHARSET = utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方式二创建表后添加外键约束&#34;&gt;方式二：创建表后，添加外键约束&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- ALTER TABLE `表名` ADD CONSTRAINT `约束名` FOREIGN KEY (`作为外键的字段`) REFERENCES `哪个表` (`哪个字段`);

ALTER TABLE `students` ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除有外键关系的表，必须先删除引用的表（从表），在删除被引用的表（主表）&lt;/p&gt;
&lt;p&gt;以上操作都是物理外键，数据库级别的外键，不建议使用&lt;/p&gt;
&lt;p&gt;最佳实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库就当作单纯的表，只用来存数据，只有行（数据）和列（字段）&lt;/li&gt;
&lt;li&gt;用程序（应用层）去实现多张表的使用、外键&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-dml语言&#34;&gt;2. DML语言&lt;/h2&gt;
&lt;p&gt;数据库意义：数据存储和数据管理&lt;/p&gt;
&lt;p&gt;DML语言：数据操作语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Insert&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-插入数据insert&#34;&gt;3. 插入数据（Insert）&lt;/h2&gt;
&lt;h3 id=&#34;插入语句添加&#34;&gt;插入语句（添加）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;INSERT INTO&lt;/code&gt;表名&lt;code&gt;([&lt;/code&gt;字段1&lt;code&gt;,&lt;/code&gt;字段2&lt;code&gt;,&lt;/code&gt;字段3&lt;code&gt;,...]) VALUES (值1,值2,值3,...);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INSERT INTO&lt;/code&gt;grade&lt;code&gt;(&lt;/code&gt;gradename&lt;code&gt;) VALUES (&#39;大四&#39;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;主键自增可以省略&lt;/p&gt;
&lt;p&gt;如果不写表的字段，会一一匹配&lt;/p&gt;
&lt;h3 id=&#34;插入多个数据&#34;&gt;插入多个数据&lt;/h3&gt;
&lt;p&gt;INSERT INTO &lt;code&gt;grade&lt;/code&gt;(&lt;code&gt;gradename&lt;/code&gt;) VALUES (&#39;大四&#39;),(&#39;大三&#39;);&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字段可以省略，后面的值必须一一对应&lt;/li&gt;
&lt;li&gt;可以同时插入多条数据&lt;code&gt;VALUES (),(),...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-修改数据update&#34;&gt;4. 修改数据(update)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 修改一行数据的一个字段
UPDATE `students` SET `name` = &#39;zd&#39; WHERE id = 2;

-- 修改一行的多个字段
UPDATE `students` SET `name` = &#39;aaa&#39;, `password` = &#39;1223434&#39; WHERE id = 2;

-- 通过多个条件定位数据
UPDATE `students` SET `name` = &#39;aaa&#39; WHERE id = 2 AND `sex` = &#39;男&#39;;

-- 格式：
UPDATE `table_name` SET `colnum_name` = new_value[, `colnum_name1 = new_value1...]  [WHERE 子句];

-- 不带[WHERE 子句]修改表中所有该字段
UPDATE `students` SET `name` = &#39;aaa&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE `table_name` SET `colnum_name` = new_value[, `colnum_name1 = new_value1...]  [WHERE 子句];
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;WHERE 子句，筛选的条件&lt;/li&gt;
&lt;li&gt;new_value，可以是设置具体的值，也可以是一个变量如 CURRENT_TIME&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-删除数据&#34;&gt;5. 删除数据&lt;/h2&gt;
&lt;h3 id=&#34;delete命令&#34;&gt;delete命令&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DELETE FROM `table_name` [WHERE 子句];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不带[WHERE 子句]会把对应表数据全部删除&lt;/p&gt;
&lt;h3 id=&#34;truncate命令&#34;&gt;truncate命令&lt;/h3&gt;
&lt;p&gt;作用：完全清空一个数据库表，标的结构和索引约束不会变&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;TRUNCATE [TABLE] `table_name`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;delete 和 truncate 的异同:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同点：都能删除数据，不会删除表结构&lt;/li&gt;
&lt;li&gt;不同点：
&lt;ul&gt;
&lt;li&gt;truncate 会重新设置自增列，计数器归零，delete不会&lt;/li&gt;
&lt;li&gt;truncate 不会影响事务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DELETE删除的问题，&lt;strong&gt;重启数据库&lt;/strong&gt;，现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB：自增列会重新从1开始（存在在内存当中，断电即失）&lt;/li&gt;
&lt;li&gt;MyISAM：自增列从上一个自增量开始（存在在文件中，不会丢失）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;子句&#34;&gt;子句&lt;/h2&gt;
&lt;h3 id=&#34;where子句&#34;&gt;WHERE子句&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;操作符&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;实例(A=2,B=4,C=5)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;=&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;等于，相等返回true&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A=B,false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;&amp;gt; 或 !=&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不等于，不等返回true&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A!=B,true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大于&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&amp;gt;B,false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;小于&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&amp;lt;B,false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;gt;=&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大于等于&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&amp;gt;=B,false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;=&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;小于等于&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&amp;lt;=B,true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;BETWEEN...AND...&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;范围内，闭区间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;BETWEEN A AND B,[2,4]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AND&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;与，多个条件同时成立返回true&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&amp;lt;B AND B&amp;lt;C,true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;或，多个条件成立一个返回true&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&amp;gt;B OR A&amp;lt;C,true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">MySQL_02_mysql数据管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/XjkFHqdpf/"" data-c="
          &lt;h2 id=&#34;0-什么是数据库&#34;&gt;0. 什么是数据库&lt;/h2&gt;
&lt;p&gt;数据库（DB,database）&lt;/p&gt;
&lt;p&gt;概念：数据仓库，软件，安装在操作系统(window,linux,mac...)之上。SQL，可以存储大量的数据&lt;/p&gt;
&lt;p&gt;作用：存储数据，管理数据&lt;/p&gt;
&lt;h3 id=&#34;数据库分类&#34;&gt;数据库分类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;关系型数据库：(SQL)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL、oracle、SqlServer、DB2、SqlLite&lt;/li&gt;
&lt;li&gt;通过表和表之间，行和列之间的关系进行数据的存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;非关系型数据库：(NoSQL) not only&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis、mongodb&lt;/li&gt;
&lt;li&gt;非关系型数据库，对象存储，通过对象的自身的属性来决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;DBMS(数据库管理系统)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库的管理软件，科学有效的管理我们的数据，维护和获取数据&lt;/li&gt;
&lt;li&gt;MySQL，数据库管理系统&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-操作数据库&#34;&gt;1. 操作数据库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE IF NOT EXISTS `westos`;
CREATE DATABASE `school` CHARACTER SET utf8 COLLATE utf8_general_ci;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;删除数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DROP DATABASE IF EXISTS westos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE westos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SHOW DATABASES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DDL 数据库&lt;strong&gt;定义&lt;/strong&gt;语言&lt;/p&gt;
&lt;p&gt;DML 数据库&lt;strong&gt;操作&lt;/strong&gt;语言&lt;/p&gt;
&lt;p&gt;DQL 数据库&lt;strong&gt;查询&lt;/strong&gt;语言&lt;/p&gt;
&lt;p&gt;DCL 数据库&lt;strong&gt;控制&lt;/strong&gt;语言&lt;/p&gt;
&lt;h2 id=&#34;2-数据库的列类型&#34;&gt;2. 数据库的列类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tinyint:   十分小的数据  ,  1字节&lt;/li&gt;
&lt;li&gt;smallint:  较小的数据     , 2字节&lt;/li&gt;
&lt;li&gt;mediumint: 中等大小的数据，3字节&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int&lt;/strong&gt;：标准的整数，4字节&lt;/li&gt;
&lt;li&gt;bigint：较大的数据，8字节&lt;/li&gt;
&lt;li&gt;float：浮点数，4字节&lt;/li&gt;
&lt;li&gt;double：浮点数，8字节&lt;/li&gt;
&lt;li&gt;decimal：字符串类型的浮点数，金融计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char：字符串固定大小，0~255&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;varchar&lt;/strong&gt;：可变字符串，0~65536（常用的变量，String）&lt;/li&gt;
&lt;li&gt;tinytext：微型文本，2^8-1&lt;/li&gt;
&lt;li&gt;text：文本串，2^16-1(保存大的文本)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间日期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;date：YYYY-MM-DD，日期格式&lt;/li&gt;
&lt;li&gt;time：HH:mm:ss，时间格式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;datetime：YYYY-MM-DD HH:mm:ss 最常用的格式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;timestamp：时间戳，1970.1.1到现在的毫秒数&lt;/li&gt;
&lt;li&gt;year：年份表示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;null&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有值，未知&lt;/li&gt;
&lt;li&gt;不要用null进行运算，结果为null，无意义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-数据库的字段属性重点&#34;&gt;3. 数据库的字段属性（重点）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Unsigned：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无符号整数&lt;/li&gt;
&lt;li&gt;声明该列不能为负数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zerofill&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0填充的&lt;/li&gt;
&lt;li&gt;不足位数的，使用0来填充，int(3)， 5-----005&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自增&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动在上一条记录的基础上+1（默认）&lt;/li&gt;
&lt;li&gt;通常用来设计唯一主键~ index，必须是整型&lt;/li&gt;
&lt;li&gt;可以自定义设计主键自增的起始值和步长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非空（null和not null）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假如设置为not null，不赋值就会报错&lt;/li&gt;
&lt;li&gt;设置为null，不赋值，默认就是null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置默认的值！&lt;/li&gt;
&lt;li&gt;eg: SEX 默认设置为 女&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拓展：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*
每个表，都必须存在以下五个字段  未来做项目用的，表示一个记录存在的意义

id          主键
version     乐观锁
is_delete   伪删除
gmt_create  创建时间
gmt_update  修改时间

*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-创建数据库表&#34;&gt;4. 创建数据库表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE IF NOT EXISTS `students`(
    `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,
    `name` VARCHAR(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,
    `password` VARCHAR(10) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,
    `sex` VARCHAR(2) NOT NULL DEFAULT &#39;女&#39; COMMENT &#39;性别&#39;,
    `birthday` DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,
    `address` VARCHAR(110) DEFAULT NULL COMMENT &#39;家庭地址&#39;,
    `email` VARCHAR(50) DEFAULT NULL COMMENT &#39;电子邮箱&#39;,
    PRIMARY KEY(`id`)
)ENGINE = INNODB DEFAULT CHARSET = utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等效于：&lt;br&gt;
&lt;img src=&#34;https://s2.loli.net/2022/03/24/ZNB57MK9ntmHfCv.png&#34; alt=&#34;创建表.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE [IF NOT EXISTS] `表名`(
    `字段名` 列类型 [属性] [索引] [注释],
    `字段名` 列类型 [属性] [索引] [注释],
    ......
    `字段名` 列类型 [属性] [索引] [注释],
    [PRIMARY KEY(`字段名`)]
)[表类型][字符集类型][注释]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SHOW CREATE DATABASE school; -- 查看创建school数据库的语句
SHOW CREATE TABLE students; -- 查看创建students表的语句
DESC students; -- 显示表的结构
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-数据表的类型&#34;&gt;5. 数据表的类型&lt;/h2&gt;
&lt;h3 id=&#34;数据库引擎&#34;&gt;数据库引擎&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB: 现在默认使用，安全性高，事务的处理，多表多用户操作&lt;/li&gt;
&lt;li&gt;MyISAM: 早些年使用，节约空间，速度较快&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;MyISAM&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;InnoDB&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;事务支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据行锁定&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持，表锁&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;外键约束&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;全文索引&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表空间大小&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;较小&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;较大，约为2倍&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html&#34;&gt;MyISAM和InnoDB区别&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据库表的字符集编码&#34;&gt;数据库表的字符集编码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CHARSET = utf8;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不设置的话，会是MySQL默认的字符集编码Latin1（不支持中文）&lt;/p&gt;
&lt;p&gt;设置方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创表时设置&lt;code&gt;CHARSET = utf8;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更改默认的编码：
&lt;ul&gt;
&lt;li&gt;Windows：&lt;code&gt;my.ini&lt;/code&gt;中配置&lt;code&gt;character-set-server=utf8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Linux：&lt;code&gt;my.cnf&lt;/code&gt;中配置&lt;code&gt;default-character-set=utf8&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;修改删除表&#34;&gt;修改删除表&lt;/h2&gt;
&lt;h3 id=&#34;修改表&#34;&gt;修改表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;修改表名：&lt;code&gt;ALTER TABLE 旧表名 RENAME AS 新表名;&lt;/code&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE students RENAME AS students1;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;增加表的字段：&lt;code&gt;ALTER TABLE 表名 ADD 字段名 列属性;&lt;/code&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE students1 ADD age INT(3);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;修改表的字段（重命名，修改约束）：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ALTER TABLE 表名 MODIFY 字段名 列属性[];&lt;/code&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE students1 MODIFY age VARCHAR(3);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[];&lt;/code&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE students1 CHANGE age age1 INT(1);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除表的字段：&lt;code&gt;ALTER TABLE 表名 DROP 字段名;&lt;/code&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE students1 DROP age1;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;删除表&#34;&gt;删除表&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DROP TABLE [IF EXISTS] students;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;`` 字段名，表名尽量使用&lt;/li&gt;
&lt;li&gt;注释：-- 或 /* ... */&lt;/li&gt;
&lt;li&gt;sql关键字大小写不敏感&lt;/li&gt;
&lt;/ul&gt;
">MySQL_01_mysql操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/shu-ju-jie-gou/"" data-c="
          &lt;h2 id=&#34;枚举enumeration&#34;&gt;枚举(Enumeration)&lt;/h2&gt;
&lt;p&gt;枚举接口本身不属于数据结构&lt;/p&gt;
&lt;p&gt;枚举接口定义了一种从数据结构中取回连续元素的方法&lt;/p&gt;
&lt;p&gt;已被迭代器取代&lt;/p&gt;
&lt;p&gt;Enumeration声明的方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;boolean hasMoreElements()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测试此枚举是否包含更多的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Object nextElements()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.Vector;
import java.util.Enumeration;
 
public class EnumerationTester {
 
   public static void main(String args[]) {
      Enumeration&amp;lt;String&amp;gt; days;
      Vector&amp;lt;String&amp;gt; dayNames = new Vector&amp;lt;String&amp;gt;();
      dayNames.add(&amp;quot;Sunday&amp;quot;);
      dayNames.add(&amp;quot;Monday&amp;quot;);
      dayNames.add(&amp;quot;Tuesday&amp;quot;);
      dayNames.add(&amp;quot;Wednesday&amp;quot;);
      dayNames.add(&amp;quot;Thursday&amp;quot;);
      dayNames.add(&amp;quot;Friday&amp;quot;);
      dayNames.add(&amp;quot;Saturday&amp;quot;);
      days = dayNames.elements();
      while (days.hasMoreElements()){
         System.out.println(days.nextElement()); 
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;位集合bitset&#34;&gt;位集合(BitSet)&lt;/h2&gt;
&lt;p&gt;该集合类实现了一组可以反赌设置和清除的位或是标志&lt;/p&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bitset(): 创建一个默认对象&lt;/li&gt;
&lt;li&gt;BitSet(int size): 指定初始大小，所有位初始为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BitSet中实现了Cloneable接口中定义的方法如下表所列：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/Opdi1H87kYStvF5.png&#34; alt=&#34;bitset方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.BitSet;
 
public class BitSetDemo {
 
  public static void main(String args[]) {
     BitSet bits1 = new BitSet(16);
     BitSet bits2 = new BitSet(16);
      
     // set some bits
     for(int i=0; i&amp;lt;16; i++) {
        if((i%2) == 0) bits1.set(i);
        if((i%5) != 0) bits2.set(i);
     }
     System.out.println(&amp;quot;Initial pattern in bits1: &amp;quot;);
     System.out.println(bits1);
     System.out.println(&amp;quot;\nInitial pattern in bits2: &amp;quot;);
     System.out.println(bits2);
 
     // AND bits
     bits2.and(bits1);
     System.out.println(&amp;quot;\nbits2 AND bits1: &amp;quot;);
     System.out.println(bits2);
 
     // OR bits
     bits2.or(bits1);
     System.out.println(&amp;quot;\nbits2 OR bits1: &amp;quot;);
     System.out.println(bits2);
 
     // XOR bits
     bits2.xor(bits1);
     System.out.println(&amp;quot;\nbits2 XOR bits1: &amp;quot;);
     System.out.println(bits2);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;向量vector&#34;&gt;向量(Vector)&lt;/h2&gt;
&lt;p&gt;向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化&lt;/p&gt;
&lt;p&gt;Vector类实现了动态数组&lt;/p&gt;
&lt;p&gt;和ArrayList的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vector 是同步访问的&lt;/li&gt;
&lt;li&gt;Vector 包含了许多传统的方法，这些方法不属于集合框架&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vector(): 创建默认向量，大小为10&lt;/li&gt;
&lt;li&gt;Vector(int size): 创建指定大小的向量&lt;/li&gt;
&lt;li&gt;Vector(int size, int incr): 创建指定大小和增量的向量&lt;/li&gt;
&lt;li&gt;Vector(Collection c): 创建一个包含集合c元素的向量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vector定义的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/Ix78Va9vgHWzupO.png&#34; alt=&#34;vector方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

public class VectorDemo {

    public static void main(String args[]) {
        // initial size is 3, increment is 2
        Vector v = new Vector(3, 2);
        System.out.println(&amp;quot;Initial size: &amp;quot; + v.size());
        System.out.println(&amp;quot;Initial capacity: &amp;quot; + v.capacity());
        v.addElement(new Integer(1));
        v.addElement(new Integer(2));
        v.addElement(new Integer(3));
        v.addElement(new Integer(4));
        System.out.println(&amp;quot;Capacity after four additions: &amp;quot; + v.capacity());

        v.addElement(new Double(5.45));
        System.out.println(&amp;quot;Current capacity: &amp;quot; + v.capacity());
        v.addElement(new Double(6.08));
        v.addElement(new Integer(7));
        System.out.println(&amp;quot;Current capacity: &amp;quot; + v.capacity());
        v.addElement(new Float(9.4));
        v.addElement(new Integer(10));
        System.out.println(&amp;quot;Current capacity: &amp;quot; + v.capacity());
        v.addElement(new Integer(11));
        v.addElement(new Integer(12));
        System.out.println(&amp;quot;First element: &amp;quot; + (Integer)v.firstElement());
        System.out.println(&amp;quot;Last element: &amp;quot; + (Integer)v.lastElement());
        if(v.contains(new Integer(3)))
            System.out.println(&amp;quot;Vector contains 3.&amp;quot;);
        // enumerate the elements in the vector.
        Enumeration vEnum = v.elements();
        System.out.println(&amp;quot;\nElements in vector:&amp;quot;);
        while(vEnum.hasMoreElements())
            System.out.print(vEnum.nextElement() + &amp;quot; &amp;quot;);
        System.out.println();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;栈stack&#34;&gt;栈(Stack)&lt;/h2&gt;
&lt;p&gt;Stack是Vector的一个子类，实现一个标准的后进先出的栈&lt;/p&gt;
&lt;p&gt;栈只定义了默认构造方法&lt;code&gt;Stack()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;栈继承了Vector的所有方法，也自定义了一些方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/hDHF4MXg6wuzA9T.png&#34; alt=&#34;Stack方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
 
public class StackDemo {
 
    static void showpush(Stack&amp;lt;Integer&amp;gt; st, int a) {
        st.push(new Integer(a));
        System.out.println(&amp;quot;push(&amp;quot; + a + &amp;quot;)&amp;quot;);
        System.out.println(&amp;quot;stack: &amp;quot; + st);
    }
 
    static void showpop(Stack&amp;lt;Integer&amp;gt; st) {
        System.out.print(&amp;quot;pop -&amp;gt; &amp;quot;);
        Integer a = (Integer) st.pop();
        System.out.println(a);
        System.out.println(&amp;quot;stack: &amp;quot; + st);
    }
 
    public static void main(String args[]) {
        Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;Integer&amp;gt;();
        System.out.println(&amp;quot;stack: &amp;quot; + st);
        showpush(st, 42);
        showpush(st, 66);
        showpush(st, 99);
        showpop(st);
        showpop(st);
        showpop(st);
        try {
            showpop(st);
        } catch (EmptyStackException e) {
            System.out.println(&amp;quot;empty stack&amp;quot;);
        }
    }
}


// stack: [ ]
// push(42)
// stack: [42]
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;字典dictionary&#34;&gt;字典(Dictionary)&lt;/h2&gt;
&lt;p&gt;Dictionary类是一个抽象类，用来存储键值对，作用和实现Map接口相似&lt;/p&gt;
&lt;p&gt;字典已经被实现Map接口取代&lt;/p&gt;
&lt;p&gt;Dictionary类定义的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/FUGb2d5tAr6OIQo.png&#34; alt=&#34;dictionary方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;map接口&#34;&gt;Map接口&lt;/h3&gt;
&lt;p&gt;抛出异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值&lt;/li&gt;
&lt;li&gt;当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常&lt;/li&gt;
&lt;li&gt;当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常&lt;/li&gt;
&lt;li&gt;当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常&lt;/li&gt;
&lt;li&gt;当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Map定义的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/sHt8IeSNJ7AuTGa.png&#34; alt=&#34;Map方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

public class CollectionsDemo {

    public static void main(String[] args) {
        Map m1 = new HashMap(); 
        m1.put(&amp;quot;Zara&amp;quot;, &amp;quot;8&amp;quot;);
        m1.put(&amp;quot;Mahnaz&amp;quot;, &amp;quot;31&amp;quot;);
        m1.put(&amp;quot;Ayan&amp;quot;, &amp;quot;12&amp;quot;);
        m1.put(&amp;quot;Daisy&amp;quot;, &amp;quot;14&amp;quot;);
        System.out.println();
        System.out.println(&amp;quot; Map Elements&amp;quot;);
        System.out.print(&amp;quot;\t&amp;quot; + m1);
    }
}


// Map Elements
//         {Mahnaz=31, Ayan=12, Daisy=14, Zara=8}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;哈希表hashtable&#34;&gt;哈希表(Hashtable)&lt;/h2&gt;
&lt;p&gt;Hashtable现在集成到了集合框架中，和HashMap类很相似，但支持同步&lt;/p&gt;
&lt;p&gt;Hashtable在哈希表中存储键值对&lt;/p&gt;
&lt;p&gt;当使用一个哈希表时，要指定用作键的对象，以及链接到该键的值&lt;/p&gt;
&lt;p&gt;该键经过哈希处理，所得的散列码被用作存储在该表中值的索引&lt;/p&gt;
&lt;p&gt;Hashtable类定义的构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hashtable()&lt;/li&gt;
&lt;li&gt;Hashtable(int size): 创建指定大小的哈希表&lt;/li&gt;
&lt;li&gt;Hashtable(int size, float fillRation): 创建指定大小和填充比例的哈希表&lt;/li&gt;
&lt;li&gt;Hashtable(Map m): 创建一个以M重元素未初始化元素的哈希表，其容量被设置为M的两倍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hashtable除了Map接口中定义的方法，还有自定义了：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/ol1hWptzTmU3d58.png&#34; alt=&#34;hashtable方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

public class HashTableDemo {

   public static void main(String args[]) {
      // Create a hash map
      Hashtable balance = new Hashtable();
      Enumeration names;
      String str;
      double bal;

      balance.put(&amp;quot;Zara&amp;quot;, new Double(3434.34));
      balance.put(&amp;quot;Mahnaz&amp;quot;, new Double(123.22));
      balance.put(&amp;quot;Ayan&amp;quot;, new Double(1378.00));
      balance.put(&amp;quot;Daisy&amp;quot;, new Double(99.22));
      balance.put(&amp;quot;Qadir&amp;quot;, new Double(-19.08));

      // Show all balances in hash table.
      names = balance.keys();
      while(names.hasMoreElements()) {
         str = (String) names.nextElement();
         System.out.println(str + &amp;quot;: &amp;quot; +
         balance.get(str));
      }
      System.out.println();
      // Deposit 1,000 into Zara&#39;s account
      bal = ((Double)balance.get(&amp;quot;Zara&amp;quot;)).doubleValue();
      balance.put(&amp;quot;Zara&amp;quot;, new Double(bal+1000));
      System.out.println(&amp;quot;Zara&#39;s new balance: &amp;quot; +
      balance.get(&amp;quot;Zara&amp;quot;));
   }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;属性properties&#34;&gt;属性(Properties)&lt;/h2&gt;
&lt;p&gt;Properties 继承于 Hashtable, Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串&lt;/p&gt;
&lt;p&gt;Properties 定义如下实例变量.这个变量持有一个 Properties 对象相关的默认属性列表：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Properties defaults;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Properties()&lt;/li&gt;
&lt;li&gt;Properties(Properties propDefault)   // 两种情况下 ，属性列表都为空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Properties类除了继承Hashtable中的方法，自定义了：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/hXfoCp9qtLHmejz.png&#34; alt=&#34;properties方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
 
public class PropDemo {
 
    public static void main(String args[]) {
        Properties capitals = new Properties();
        Set states;
        String str;
        
        capitals.put(&amp;quot;Illinois&amp;quot;, &amp;quot;Springfield&amp;quot;);
        capitals.put(&amp;quot;Missouri&amp;quot;, &amp;quot;Jefferson City&amp;quot;);
        capitals.put(&amp;quot;Washington&amp;quot;, &amp;quot;Olympia&amp;quot;);
        capitals.put(&amp;quot;California&amp;quot;, &amp;quot;Sacramento&amp;quot;);
        capitals.put(&amp;quot;Indiana&amp;quot;, &amp;quot;Indianapolis&amp;quot;);
    
        // Show all states and capitals in hashtable.
        states = capitals.keySet(); // get set-view of keys
        Iterator itr = states.iterator();
        while(itr.hasNext()) {
            str = (String) itr.next();
            System.out.println(&amp;quot;The capital of &amp;quot; + str + &amp;quot; is &amp;quot; + capitals.getProperty(str) + &amp;quot;.&amp;quot;);
        }
        System.out.println();
    
        // look for state not in list -- specify default
        str = capitals.getProperty(&amp;quot;Florida&amp;quot;, &amp;quot;Not Found&amp;quot;);
        System.out.println(&amp;quot;The capital of Florida is &amp;quot; + str + &amp;quot;.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;以上这些类是传统遗留的，后面引入新的框架--集合框架(Collection)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;集合框架&#34;&gt;集合框架&lt;/h2&gt;
&lt;p&gt;上述的类缺少一个核心的、统一的主题，不同类的使用方法有着很大的不同&lt;/p&gt;
&lt;p&gt;集合框架的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的&lt;/li&gt;
&lt;li&gt;该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性&lt;/li&gt;
&lt;li&gt;对一个集合的扩展和适应必须是简单的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，集合框架就围绕一组标准接口而设计&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/7WgzAt2Px9dpDJB.png&#34; alt=&#34;集合框架图.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Java集合框架主要包括两种类型容器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合(Collection)：存储一个元素&lt;/li&gt;
&lt;li&gt;图(Map)：存储键值对映射&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集合框架都包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集合框架接口&#34;&gt;集合框架接口：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/LFs54yEOK3WJMlp.png&#34; alt=&#34;集合框架接口.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;集合实现类集合类&#34;&gt;集合实现类（集合类）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/of3lVvQ2G6bXen8.png&#34; alt=&#34;集合实现类.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;迭代器iterator&#34;&gt;迭代器(Iterator)&lt;/h3&gt;
&lt;p&gt;迭代器是一种访问集合的方法&lt;/p&gt;
&lt;p&gt;Iterator是迭代器最简单的实现，ListIterator是Collection API中的接口，拓展了Iterator接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import java.util.Iterator; // 引入 Iterator 类&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态&lt;/li&gt;
&lt;li&gt;it.hasNext() 用于检测集合中是否还有元素&lt;/li&gt;
&lt;li&gt;it.remove() 将迭代器返回的元素删除&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;获取迭代器&#34;&gt;获取迭代器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;iterator()&lt;/code&gt;方法&lt;/p&gt;
&lt;h4 id=&#34;循环集合元素&#34;&gt;循环集合元素&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while(it.hasNext()) {
    System.out.println(it.next());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除集合元素&#34;&gt;删除集合元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;remove()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.ArrayList;
import java.util.Iterator;

public class RunoobTest {
    public static void main(String[] args) {
        ArrayList&amp;lt;Integer&amp;gt; numbers = new ArrayList&amp;lt;Integer&amp;gt;();
        numbers.add(12);
        numbers.add(8);
        numbers.add(2);
        numbers.add(23);
        Iterator&amp;lt;Integer&amp;gt; it = numbers.iterator();
        while(it.hasNext()) {
            Integer i = it.next();
            if(i &amp;lt; 10) {  
                it.remove();  // 删除小于 10 的元素
            }
        }
        System.out.println(numbers);
    }
}

// [12, 23]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;遍历arraylist&#34;&gt;遍历ArrayList&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
 
public class Test{
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;String&amp;gt;();
        list.add(&amp;quot;Hello&amp;quot;);
        list.add(&amp;quot;World&amp;quot;);
        list.add(&amp;quot;HAHAHAHA&amp;quot;);
        //第一种遍历方法使用 For-Each 遍历 List
        for (String str : list) {            //也可以改写 for(int i=0;i&amp;lt;list.size();i++) 这种形式
            System.out.println(str);
        }
    
        //第二种遍历，把链表变为数组相关的内容进行遍历
        String[] strArray=new String[list.size()];
        list.toArray(strArray);
        for(int i=0;i&amp;lt;strArray.length;i++) //这里也可以改写为  for(String str:strArray) 这种形式
        {
            System.out.println(strArray[i]);
        }
        
        //第三种遍历 使用迭代器进行相关遍历
        
        Iterator&amp;lt;String&amp;gt; ite=list.iterator();
        while(ite.hasNext())//判断下一个元素之后有值
        {
            System.out.println(ite.next());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;遍历map&#34;&gt;遍历Map&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
 
public class Test{
    public static void main(String[] args) {
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
        map.put(&amp;quot;1&amp;quot;, &amp;quot;value1&amp;quot;);
        map.put(&amp;quot;2&amp;quot;, &amp;quot;value2&amp;quot;);
        map.put(&amp;quot;3&amp;quot;, &amp;quot;value3&amp;quot;);
        
        //第一种：普遍使用，二次取值
        System.out.println(&amp;quot;通过Map.keySet遍历key和value：&amp;quot;);
        for (String key : map.keySet()) {
        System.out.println(&amp;quot;key= &amp;quot;+ key + &amp;quot; and value= &amp;quot; + map.get(key));
        }
        
        //第二种
        System.out.println(&amp;quot;通过Map.entrySet使用iterator遍历key和value：&amp;quot;);
        Iterator&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; it = map.entrySet().iterator();
        while (it.hasNext()) {
        Map.Entry&amp;lt;String, String&amp;gt; entry = it.next();
        System.out.println(&amp;quot;key= &amp;quot; + entry.getKey() + &amp;quot; and value= &amp;quot; + entry.getValue());
        }
        
        //第三种：推荐，尤其是容量大时
        System.out.println(&amp;quot;通过Map.entrySet遍历key和value&amp;quot;);
        for (Map.Entry&amp;lt;String, String&amp;gt; entry : map.entrySet()) {
        System.out.println(&amp;quot;key= &amp;quot; + entry.getKey() + &amp;quot; and value= &amp;quot; + entry.getValue());
        }
        
        //第四种
        System.out.println(&amp;quot;通过Map.values()遍历所有的value，但不能遍历key&amp;quot;);
        for (String v : map.values()) {
        System.out.println(&amp;quot;value= &amp;quot; + v);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;比较器&#34;&gt;比较器&lt;/h3&gt;
&lt;p&gt;Comparator接口定义了两个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;compare()&lt;/li&gt;
&lt;li&gt;equals()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;int compare(Object obj1, Object obj2)&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;arraylist-类&#34;&gt;ArrayList 类&lt;/h2&gt;
&lt;p&gt;ArrayList类是一个可以动态修改的数组&lt;/p&gt;
&lt;p&gt;继承了AbstractList，并实现了List接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt; objectName =new ArrayList&amp;lt;&amp;gt;();　 // 初始化&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ArrayList常用方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/6QiPYmqj2pxoAeG.png&#34; alt=&#34;ArrayList常用方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;linkedlist-类链表&#34;&gt;LinkedList 类（链表）&lt;/h2&gt;
&lt;p&gt;链表是一种线性表，在每个节点里存放下一节点的地址&lt;/p&gt;
&lt;p&gt;可分为&lt;code&gt;单链表&lt;/code&gt;和&lt;code&gt;双链表&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;单链表包含当前结点的值和指向后节点的链接两个值&lt;/p&gt;
&lt;p&gt;双链表多了向后结点的链接&lt;/p&gt;
&lt;p&gt;与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低&lt;/p&gt;
&lt;p&gt;ArrayList：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;频繁访问列表中的某一个元素&lt;/li&gt;
&lt;li&gt;只需要在列表末尾进行添加和删除元素操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LinkedList：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要通过循环迭代来访问列表中的某些元素&lt;/li&gt;
&lt;li&gt;需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LinkedList 继承了 AbstractSequentialList 类&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 Queue 接口，可作为队列使用&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 List 接口，可进行列表的相关操作&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 Deque 接口，可作为队列使用&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 Cloneable 接口，可实现克隆&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;LinkedList&amp;lt;E&amp;gt; list = new LinkedList&amp;lt;E&amp;gt;();   // 普通创建方法
或者
LinkedList&amp;lt;E&amp;gt; list = new LinkedList(Collection&amp;lt;? extends E&amp;gt; c); // 使用集合创建链表
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/TvVpFPnZl87XC1w.png&#34; alt=&#34;LinkedList常用方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;hashset&#34;&gt;HashSet&lt;/h2&gt;
&lt;p&gt;HashSet是一个不允许有重复元素的集合，允许有null值&lt;/p&gt;
&lt;p&gt;无序的&lt;/p&gt;
&lt;p&gt;非线程安全&lt;/p&gt;
&lt;p&gt;实现了Set接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashSet&amp;lt;String&amp;gt; sites = new HashSet&amp;lt;String&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/32voSbfi9wck5dR.png&#34; alt=&#34;HashSet方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;hashmap&#34;&gt;HashMap&lt;/h2&gt;
&lt;p&gt;HashMap是一个散列表，存储了键值对的映射&lt;/p&gt;
&lt;p&gt;实现了Map接口&lt;/p&gt;
&lt;p&gt;最多允许一条记录的键位null，不支持线程同步&lt;/p&gt;
&lt;p&gt;无序的&lt;/p&gt;
&lt;p&gt;继承了AbstractMap，实现了Map、Cloneable、java.io.Serializable接口&lt;/p&gt;
&lt;p&gt;HashMap的key与value的类型可以不同&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&amp;lt;Integer, String&amp;gt; Sites = new HashMap&amp;lt;Integer, String&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/14/QULCFrKElsuIfX8.png&#34; alt=&#34;HashMap方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
">数据结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/mian-xiang-dui-xiang/"" data-c="
          &lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;继承就是子类继承父类的特征和行为，使得子类对象（实例）具有弗雷德实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为&lt;/p&gt;
&lt;p&gt;继承格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class 父类 {
}
 
class 子类 extends 父类 {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;继承类型&#34;&gt;继承类型&lt;/h3&gt;
&lt;p&gt;Java不支持多继承，但支持多重继承&lt;/p&gt;
&lt;p&gt;1.单继承&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;多重继承&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt; &amp;lt;-- ...&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;不同类继承同一个类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;多继承（不支持）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class B&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;集成的特性&#34;&gt;集成的特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;子类拥有父类非 private 的属性、方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类可以拥有自己的属性和方法，即子类可以对父类进行扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类可以用自己的方式实现父类的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 的继承是单继承，但是可以多重继承&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;继承关键字&#34;&gt;继承关键字&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;extends&lt;/li&gt;
&lt;li&gt;implements&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;extends关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类的继承是单一继承，extends只能继承一个类&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;implements关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}
 
public class C implements A,B {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;super 和 this关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this关键字：指向自己的引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;final关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写&lt;/p&gt;
&lt;h3 id=&#34;构造器&#34;&gt;构造器&lt;/h3&gt;
&lt;p&gt;子类不继承父类的构造器，只是通过&lt;code&gt;super&lt;/code&gt;关键字调用&lt;/p&gt;
&lt;p&gt;如果父类构造器没有参数，系统自动调用父类的无参数构造器&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;重写override与重载overload&#34;&gt;重写（Override）与重载（Overload）&lt;/h2&gt;
&lt;p&gt;方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现&lt;/p&gt;
&lt;h3 id=&#34;override&#34;&gt;Override&lt;/h3&gt;
&lt;p&gt;重写是子类在不改变形参的前提下，重新编写父类方法的实现过程&lt;/p&gt;
&lt;p&gt;重写方法不能抛出新的异常或是申明更宽泛的异常&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Animal{
   public void move(){
      System.out.println(&amp;quot;动物可以移动&amp;quot;);
   }
}
 
class Dog extends Animal{
   public void move(){
      System.out.println(&amp;quot;狗可以跑和走&amp;quot;);
   }
}
 
public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象
 
      a.move();// 执行 Animal 类的方法
 
      b.move();//执行 Dog 类的方法
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法的重写规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数列表与被重写方法的参数列表必须完全相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父类的成员方法只能被它的子类重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明为 final 的方法不能被重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明为 static 的方法不能被重写，但是能够被再次声明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造方法不能被重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不能继承一个类，则不能重写该类的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;overload&#34;&gt;Overload&lt;/h3&gt;
&lt;p&gt;重载是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同&lt;/p&gt;
&lt;p&gt;重载规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被重载的方法必须改变参数列表(参数个数或类型不一样)&lt;/li&gt;
&lt;li&gt;被重载的方法可以改变返回类型&lt;/li&gt;
&lt;li&gt;被重载的方法可以改变访问修饰符&lt;/li&gt;
&lt;li&gt;被重载的方法可以声明新的或更广的检查异常&lt;/li&gt;
&lt;li&gt;方法能够在同一个类中或者在一个子类中被重载&lt;/li&gt;
&lt;li&gt;无法以返回值类型作为重载函数的区分标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Overloading {
    public int test(){
        System.out.println(&amp;quot;test1&amp;quot;);
        return 1;
    }
 
    public void test(int a){
        System.out.println(&amp;quot;test2&amp;quot;);
    }   
 
    //以下两个参数类型顺序不同
    public String test(int a,String s){
        System.out.println(s);
        return &amp;quot;return&amp;quot; + s;
    }   
 
    public String test(String s,int a){
        System.out.println(s);
        return &amp;quot;return&amp;quot; + s;
    }   
 
    public static void main(String[] args){
        Overloading o = new Overloading();
        System.out.println(o.test());
        o.test(1);
        System.out.println(o.test(1,&amp;quot;test3&amp;quot;));
        System.out.println(o.test(&amp;quot;test4&amp;quot;,1));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;override-和overload之间的区别&#34;&gt;Override 和Overload之间的区别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;区别点&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;重载&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;重写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;参数列表&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;必须修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;异常&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以减少或删除，不能增加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;访问&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以降低限制，不能更严格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;多态&#34;&gt;多态&lt;/h2&gt;
&lt;p&gt;多态是一个行为有多个不同表现形式或形态的能力&lt;/p&gt;
&lt;p&gt;多态就是同一个接口，使用不同的实例执行不同的操作&lt;/p&gt;
&lt;p&gt;多态的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除类型之间的耦合关系&lt;/li&gt;
&lt;li&gt;可替换性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;接口性&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;li&gt;简化性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多态存在的必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象：&lt;code&gt;Parent p = new Child();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        show(new Cat());  // 以 Cat 对象调用 show 方法
        show(new Dog());  // 以 Dog 对象调用 show 方法
                    
        Animal a = new Cat();  // 向上转型  
        a.eat();               // 调用的是 Cat 的 eat
        Cat c = (Cat)a;        // 向下转型  
        c.work();        // 调用的是 Cat 的 work
    }  
            
    public static void show(Animal a)  {
        a.eat();  
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情 
            Cat c = (Cat)a;  
            c.work();  
        } else if (a instanceof Dog) { // 狗做的事情 
            Dog c = (Dog)a;  
            c.work();  
        }  
    }  
}
 
abstract class Animal {  
    abstract void eat();  
}  
  
class Cat extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃鱼&amp;quot;);  
    }  
    public void work() {  
        System.out.println(&amp;quot;抓老鼠&amp;quot;);  
    }  
}  
  
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃骨头&amp;quot;);  
    }  
    public void work() {  
        System.out.println(&amp;quot;看家&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;虚函数&#34;&gt;虚函数&lt;/h3&gt;
&lt;p&gt;Java没有虚函数的概念，其普通函数默认就相当于C++的虚函数，加上final关键字可以声明该函数不具有虚函数特性&lt;/p&gt;
&lt;p&gt;虚拟方法调用：&lt;/p&gt;
&lt;p&gt;实例时，编译时使用父类的方法进行，运行时调用重写的方法&lt;/p&gt;
&lt;h3 id=&#34;多态的实现方式&#34;&gt;多态的实现方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;抽象类和抽象方法&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;抽象类&#34;&gt;抽象类&lt;/h2&gt;
&lt;p&gt;抽象类没有包含足够的信息来描绘一个对象&lt;/p&gt;
&lt;p&gt;所以不能实例化对象&lt;/p&gt;
&lt;p&gt;抽象类必须被继承，才能被使用&lt;/p&gt;
&lt;p&gt;抽象类是用来捕捉子类的通用特性的，是被用来创建继承层级里子类的模板。 现实中有些父类中的方法确实没有必要写，因为各个子类中的这个方法肯定会有不同；而写成抽象类，这样看代码时，就知道这是抽象方法，而知道这个方法是在子类中实现的，所以有提示作用&lt;/p&gt;
&lt;h3 id=&#34;抽象类-2&#34;&gt;抽象类&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;abstract class&lt;/code&gt;来定义抽象类&lt;/p&gt;
&lt;h3 id=&#34;继承抽象类&#34;&gt;继承抽象类&lt;/h3&gt;
&lt;h3 id=&#34;抽象方法&#34;&gt;抽象方法&lt;/h3&gt;
&lt;p&gt;抽象方法也用&lt;code&gt;abstract&lt;/code&gt;来声明&lt;/p&gt;
&lt;p&gt;抽象方法只包含一个方法名，而没有方法体，即方法的具体由子类确定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public abstract double computePay(); // 方法名后直接跟分号&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具有抽象方法的抽象类，其子类必须重写父类的抽象方法，或者也声明为抽象类&lt;/p&gt;
&lt;p&gt;构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;封装&#34;&gt;封装&lt;/h2&gt;
&lt;p&gt;封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法&lt;/p&gt;
&lt;p&gt;可理解为一个保护，防止该类的代码和数据被外部类定义的代码随机访问&lt;/p&gt;
&lt;p&gt;封装的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;良好的封装能够减少耦合&lt;/li&gt;
&lt;li&gt;类内部的结构可以自由修改&lt;/li&gt;
&lt;li&gt;可以对成员变量进行更精确的控制&lt;/li&gt;
&lt;li&gt;隐藏信息，实现细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现封装的步骤&#34;&gt;实现封装的步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改属性的可见性来限制对属性的访问（一般限制为private）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对每个值属性提供对外的公共方法访问，即创建一对赋取值方法，用于对私有属性的访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EncapTest{
 
    private String name;
    private String idNum;
    private int age;
    
    public int getAge(){
        return age;
    }
    
    public String getName(){
        return name;
    }
    
    public String getIdNum(){
        return idNum;
    }
    
    public void setAge( int newAge){
        age = newAge;
    }
    
    public void setName(String newName){
        name = newName;
    }
    
    public void setIdNum( String newId){
        idNum = newId;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RunEncap{
    public static void main(String args[]){
        EncapTest encap = new EncapTest();
        encap.setName(&amp;quot;James&amp;quot;);
        encap.setAge(20);
        encap.setIdNum(&amp;quot;12343ms&amp;quot;);

        System.out.print(&amp;quot;Name : &amp;quot; + encap.getName()+ &amp;quot; Age : &amp;quot;+ encap.getAge());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口interface&#34;&gt;接口（Interface）&lt;/h2&gt;
&lt;p&gt;接口是抽象方法的集合&lt;/p&gt;
&lt;p&gt;通常以&lt;code&gt;interface&lt;/code&gt;声明&lt;/p&gt;
&lt;p&gt;一个类通过继承接口的方式来继承接口的抽象方法&lt;/p&gt;
&lt;p&gt;类描述对象的属性和方法，接口包含类要实现的方法&lt;/p&gt;
&lt;p&gt;实现接口的类要定义接口中的所有方法，除非是抽象类&lt;/p&gt;
&lt;p&gt;接口不能实例化，但可以被实现&lt;/p&gt;
&lt;p&gt;接口与类相似点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个接口可以有多个方法&lt;/li&gt;
&lt;li&gt;接口文件保存在 .java 结尾的文件中，文件名使用接口名&lt;/li&gt;
&lt;li&gt;接口的字节码文件保存在 .class 结尾的文件中&lt;/li&gt;
&lt;li&gt;接口相应的字节码文件必须在与包名称相匹配的目录结构中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口与类的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口不能用于实例化对象。&lt;/li&gt;
&lt;li&gt;接口没有构造方法。&lt;/li&gt;
&lt;li&gt;接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。&lt;/li&gt;
&lt;li&gt;接口不能包含成员变量，除了 static 和 final 变量。&lt;/li&gt;
&lt;li&gt;接口不是被类继承了，而是要被类实现。&lt;/li&gt;
&lt;li&gt;接口支持多继承&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽象类和接口的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 &lt;code&gt;public static final&lt;/code&gt; 类型的&lt;/li&gt;
&lt;li&gt;一个类只能继承一个抽象类，可以实现多个接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;接口的声明&#34;&gt;接口的声明&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;[可见度] interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Animal {
   public void eat();
   public void travel();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的实现&#34;&gt;接口的实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MammalInt implements Animal{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的继承&#34;&gt;接口的继承&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 文件名: Sports.java
public interface Sports
{
   public void setHomeTeam(String name);
   public void setVisitingTeam(String name);
}
 
// 文件名: Football.java
public interface Football extends Sports
{
   public void homeTeamScored(int points);
   public void visitingTeamScored(int points);
   public void endOfQuarter(int quarter);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的多继承&#34;&gt;接口的多继承&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public interface Hockey extends Sports, Event&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;标记接口&#34;&gt;标记接口&lt;/h3&gt;
&lt;p&gt;没有任何方法的接口被称为标记接口&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立一个公共的父接口&lt;/li&gt;
&lt;li&gt;向一个类添加数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;枚举enum&#34;&gt;枚举（enum）&lt;/h2&gt;
&lt;p&gt;枚举是一个特殊的类，一般表示一组常量&lt;/p&gt;
&lt;p&gt;所有的枚举值都是 public static final&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
 
public class Test
{
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}


//RED
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部类中使用枚举&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test
{
    enum Color
    {
        RED, GREEN, BLUE;
    }
 
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;迭代枚举元素&#34;&gt;迭代枚举元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
public class MyClass {
  public static void main(String[] args) {
    for (Color myVar : Color.values()) {
      System.out.println(myVar);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;values-ordinal-valueof方法&#34;&gt;values(), ordinal(), valueOf()方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;values() 返回枚举类中所有的值&lt;/li&gt;
&lt;li&gt;ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样&lt;/li&gt;
&lt;li&gt;valueOf()方法返回指定字符串值的枚举常量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
 
public class Test
{
    public static void main(String[] args)
    {
        // 调用 values()
        Color[] arr = Color.values();
 
        // 迭代枚举
        for (Color col : arr)
        {
            // 查看索引
            System.out.println(col + &amp;quot; at index &amp;quot; + col.ordinal());
        }
 
        // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException
        System.out.println(Color.valueOf(&amp;quot;RED&amp;quot;));
        // System.out.println(Color.valueOf(&amp;quot;WHITE&amp;quot;));
    }
}


// RED at index 0
// GREEN at index 1
// BLUE at index 2
// RED
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;枚举类成员&#34;&gt;枚举类成员&lt;/h3&gt;
&lt;p&gt;枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符&lt;/p&gt;
&lt;p&gt;枚举既可以包含具体方法，也可以包含抽象方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
 
    // 构造函数
    private Color()
    {
        System.out.println(&amp;quot;Constructor called for : &amp;quot; + this.toString());
    }
 
    public void colorInfo()
    {
        System.out.println(&amp;quot;Universal Color&amp;quot;);
    }
}
 
public class Test
{    
    // 输出
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
        c1.colorInfo();
    }
}


// Constructor called for : RED
// Constructor called for : GREEN
// Constructor called for : BLUE
// RED
// Universal Color
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;包package&#34;&gt;包（package）&lt;/h2&gt;
&lt;p&gt;包的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把功能相似的类或接口组织在一个包中，方便查找和使用&lt;/li&gt;
&lt;li&gt;避免名字冲突&lt;/li&gt;
&lt;li&gt;包也限定了访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.lang-打包基础的类&lt;/li&gt;
&lt;li&gt;java.io-包含输入输出功能的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;创建包&#34;&gt;创建包&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;package pkg1[．pkg2[．pkg3…]];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;包的声明放在这个源文件的开头&lt;/p&gt;
&lt;h3 id=&#34;import关键字&#34;&gt;import关键字&lt;/h3&gt;
&lt;p&gt;import语句导入包&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import package1[.package2…].(classname|*);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;任意数量import 声明必须在包声明之后，类声明之前&lt;/p&gt;
&lt;h3 id=&#34;package的目录结构&#34;&gt;package的目录结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;包名成为类名的一部分，正如我们前面讨论的一样。&lt;/li&gt;
&lt;li&gt;包名必须与相应的字节码所在的目录结构相吻合&lt;/li&gt;
&lt;/ul&gt;
">面向对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/ji-chu-yu-fa/"" data-c="
          &lt;h2 id=&#34;java基础语法&#34;&gt;Java基础语法&lt;/h2&gt;
&lt;p&gt;Java语言是面向对象的&lt;/p&gt;
&lt;p&gt;先介绍下类、对象、方法和实例变量的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象：是类的一个实例，有状态有行为。eg：对象（一条狗），状态（名字、品种、颜色等），行为（叫、吃、摇尾巴等）&lt;/li&gt;
&lt;li&gt;类：类是一个模板，描述一类对象的行为和状态&lt;/li&gt;
&lt;li&gt;方法：方法就是行为，一个类可以有很多方法&lt;/li&gt;
&lt;li&gt;实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;包名：多单词都小写&lt;/p&gt;
&lt;p&gt;类名、接口名：所有单词首字母大写&lt;/p&gt;
&lt;p&gt;变量名、方法名：第一个单词首字母小写，后面大写&lt;/p&gt;
&lt;p&gt;常量名：所有字母都大写，多单词用下划线连接(eg:XXX_YYY_ZZZ)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;源文件名必须与类名相同&lt;/li&gt;
&lt;li&gt;一个源文件只能有一个public类，可以有若干个非public类&lt;/li&gt;
&lt;li&gt;主方法入口：&lt;code&gt;public static void main(String[] args)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;public static void main(String[] args)&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;public：访问修饰符&lt;br&gt;
static：关键字&lt;br&gt;
void：返回类型&lt;br&gt;
main：方法名&lt;br&gt;
String：String类&lt;br&gt;
args：字符串数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;标识符&#34;&gt;标识符&lt;/h3&gt;
&lt;p&gt;Java所有的组成部分都需要名字。&lt;/p&gt;
&lt;p&gt;标识符：类名、变量名、方法名&lt;/p&gt;
&lt;p&gt;标识符规范：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首字符：字母、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;其&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;他&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;符&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;母&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;、_
其他字符：字母、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.15em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:-0.15em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord cjk_fallback mtight&#34;&gt;其&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;他&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;符&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;母&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、_、数字&lt;br&gt;
大小写敏感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;修饰符&#34;&gt;修饰符&lt;/h3&gt;
&lt;p&gt;Java用修饰符来修饰类中的方法和属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问控制修饰符：default、public、protected、private&lt;/li&gt;
&lt;li&gt;非访问控制修饰符：final、abstract、static、synchronized&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java变量&#34;&gt;Java变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;li&gt;类变量（静态变量）&lt;/li&gt;
&lt;li&gt;成员变量（非静态变量）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java关键字&#34;&gt;Java关键字&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/08/Pnm1sC7QRDZG4z6.png&#34; alt=&#34;Java关键字.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-对象和类&#34;&gt;Java 对象和类&lt;/h2&gt;
&lt;p&gt;Java面向对象支持以下基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;li&gt;抽象&lt;/li&gt;
&lt;li&gt;类&lt;/li&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;li&gt;实例&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：改变对象的内部状态，对象的相互调用&lt;/p&gt;
&lt;p&gt;类中的变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部变量：在方法中定义的变量，随方法的结束而销毁&lt;/li&gt;
&lt;li&gt;成员变量：定义在类中、方法之外的变量，在创建对象时实例化，在类中可被访问&lt;/li&gt;
&lt;li&gt;类变量：声明在类中、方法块之外、必须声明为static类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造方法&#34;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;每个类都有一个或多个构造方法&lt;/p&gt;
&lt;p&gt;创建对象时，至少调用一个构造方法&lt;/p&gt;
&lt;p&gt;构造方法的名称必须与类同名&lt;/p&gt;
&lt;h3 id=&#34;创建对象&#34;&gt;创建对象&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;声明：对象的名称和类型&lt;/li&gt;
&lt;li&gt;实例化：使用关键字&lt;code&gt;new&lt;/code&gt;来创建一个对象&lt;/li&gt;
&lt;li&gt;初始化：使用&lt;code&gt;new&lt;/code&gt;创建对象时，会调用构造方法初始化对象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Puppy{

    // 该构造方法仅有一个参数：name
    public Puppy(String name){
        System.out.println(&amp;quot;The dog&#39;s name is : &amp;quot; + name);
    }

    public static void main(String[] args){
        Puppy myPuppy = new Puppy(&amp;quot;Tommy&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;访问实例变量和方法&#34;&gt;访问实例变量和方法&lt;/h3&gt;
&lt;p&gt;通过已创建的对象来访问成员变量和成员方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* 实例化对象 */
Object referenceVariable = new Constructor();
/* 访问类中的变量 */
referenceVariable.variableName;
/* 访问类中的方法 */
referenceVariable.methodName();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Puppy{
    int puppyAge;
    public Puppy(String name){
        System.out.println(&amp;quot;The dog&#39;s name is : &amp;quot; + name)；
    }

    public void setAge(int age){
        puppyAge = age;
    }

    public int getAge(){
        return puppyAge;
    }

    public static void main(String[] args){
        Puppy myPuppy = new Puppy(Tommy);

        myPuppy.setAge(2)
        System.out.println(&amp;quot;myPuppy&#39;s age is : &amp;quot; + myPuppy.getAge());
        System.out.println(&amp;quot;变量值：&amp;quot; + myPuppy.puppyAge);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java包&#34;&gt;Java包&lt;/h3&gt;
&lt;p&gt;包主要用来对类和接口进行分类&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java基本数据类型&#34;&gt;Java基本数据类型&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;内置数据类型&lt;/li&gt;
&lt;li&gt;引用数据类型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内置数据类型&#34;&gt;内置数据类型&lt;/h3&gt;
&lt;p&gt;8种基本类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;byte：8位,默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;short：16位，默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;int：32位，默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;long：64位，默认值&lt;code&gt;0L&lt;/code&gt;(L不区分大小写，最好大写区分1)&lt;/li&gt;
&lt;li&gt;float：单精度，32位，默认值&lt;code&gt;0.0f&lt;/code&gt;(不能表示精确的值)&lt;/li&gt;
&lt;li&gt;double：双精度，64位，默认值&lt;code&gt;0.0d&lt;/code&gt;(不能表示精确值)&lt;/li&gt;
&lt;li&gt;boolean：标志记录true/false，默认&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;char：单一的16位Unicode字符，&lt;code&gt;\u0000&lt;/code&gt;~&lt;code&gt;\uffff&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;引用数据类型&#34;&gt;引用数据类型&lt;/h3&gt;
&lt;p&gt;对象、数组都是引用数据类型&lt;/p&gt;
&lt;p&gt;默认值&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个引用变量可以用来引用任何与之兼容的类型&lt;/p&gt;
&lt;h3 id=&#34;java常量&#34;&gt;Java常量&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;final&lt;/code&gt;关键字来修饰常量&lt;/p&gt;
&lt;p&gt;eg：`final double PI = 3.14159265;&lt;/p&gt;
&lt;p&gt;常量名通常大写&lt;/p&gt;
&lt;p&gt;字符串常量：双引号之间的字符序列&lt;/p&gt;
&lt;p&gt;转义字符：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/08/Go2nVrQZF8Rpa9K.png&#34; alt=&#34;转义字符.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;自动类型转换&#34;&gt;自动类型转换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;low --------------------------------------&amp;gt; high
byte,short,char -&amp;gt; int -&amp;gt; long -&amp;gt; float -&amp;gt; double
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;boolean不能转换&lt;/li&gt;
&lt;li&gt;容量大的必须用强制转换才可以转换为容量小的&lt;/li&gt;
&lt;li&gt;浮点数舍弃小数转换得到整形&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java变量类型&#34;&gt;Java变量类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类变量&lt;/li&gt;
&lt;li&gt;实例变量&lt;/li&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Variable{
    static int allClicks=0;    // 类变量
 
    String str=&amp;quot;hello world&amp;quot;;  // 实例变量
 
    public void method(){
 
        int i =0;  // 局部变量
 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java局部变量&#34;&gt;java局部变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;局部变量声明在方法中&lt;/li&gt;
&lt;li&gt;不能用访问修饰符&lt;/li&gt;
&lt;li&gt;没有默认值，必须先初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java实例变量&#34;&gt;Java实例变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实例变量声明在一个类中，在方法、构造方法和语句块之外&lt;/li&gt;
&lt;li&gt;当一个对象被实例化之后，每个实例变量的值就跟着确定，对象被销毁的时候销毁&lt;/li&gt;
&lt;li&gt;实例变量的值应该至少被一个方法，使得外部能够通过这些方式获取实例变量信息&lt;/li&gt;
&lt;li&gt;可以声明在使用前或者使用后&lt;/li&gt;
&lt;li&gt;可用访问修饰符&lt;/li&gt;
&lt;li&gt;实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见&lt;/li&gt;
&lt;li&gt;有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定&lt;/li&gt;
&lt;li&gt;可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类变量静态变量&#34;&gt;类变量（静态变量）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在类中以 static 关键字声明，但必须在方法之外&lt;/li&gt;
&lt;li&gt;类只拥有类变量的一份拷贝&lt;/li&gt;
&lt;li&gt;静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。&lt;/li&gt;
&lt;li&gt;类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java修饰符&#34;&gt;java修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;访问修饰符&lt;/li&gt;
&lt;li&gt;非访问修饰符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修饰符用来定义类、方法或者变量，通常放在语句的最前端&lt;/p&gt;
&lt;h3 id=&#34;访问控制修饰符&#34;&gt;访问控制修饰符&lt;/h3&gt;
&lt;p&gt;用来保护对类、对象、方法的访问&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;default（默认，不写）：同一包内可见，不适用任何修饰符&lt;/li&gt;
&lt;li&gt;private：同一类内可见，不能修饰类（外部类）&lt;/li&gt;
&lt;li&gt;public：对所有类可见&lt;/li&gt;
&lt;li&gt;protected：对同一包内的类和子类可见，不能修饰类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口里的变量都隐式声明为&lt;code&gt;public static final&lt;/code&gt;，而接口里的方法默认为&lt;code&gt;public&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;私有访问修饰符--private&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Logger {
    private String format;
    public String getFormat() {
        return this.format;
    }
    public void setFormat(String format) {
        this.format = format;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;公有访问修饰符--public&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明为 public 的类、方法、构造方法和接口能够被任何其他类访问&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;受保护的访问修饰符--protected&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;子类与父类在同一包中：能被同一个包中的任何其他类访问&lt;/li&gt;
&lt;li&gt;子类与父类不在同一包中：在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;方法继承规则：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;父类-public，子类public&lt;/li&gt;
&lt;li&gt;父类-protected，子类public、protected&lt;/li&gt;
&lt;li&gt;父类-private，子类不能继承&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非访问修饰符&#34;&gt;非访问修饰符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;static：用来修饰类方法和类变量&lt;/li&gt;
&lt;li&gt;final：修饰类、方法、变量，修饰的类不能被继承，方法不能被重新定义，变量为常量，不可修改&lt;/li&gt;
&lt;li&gt;abstract：用来修饰抽象类和抽象方法&lt;/li&gt;
&lt;li&gt;synchronized和volatile：主要用于线程的编程&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;static修饰符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态变量：用来声明静态变量，只有一份拷贝&lt;/li&gt;
&lt;li&gt;静态方法：静态方法不能使用类的非静态变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final修饰符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;final变量：赋值后为常量&lt;/li&gt;
&lt;li&gt;final方法：可以被继承，但不能被子类重写&lt;/li&gt;
&lt;li&gt;final类：不能被继承&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;abstract修饰符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized修饰符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明的方法同一时间只能被一个线程访问&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;transient修饰符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java 虚拟机(JVM)跳过被 transient 修饰的实例变量&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;volatile修饰符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值,成员变量发生变化时，会强制线程将变化值回写到共享内存&lt;/p&gt;
&lt;p&gt;任何时刻，两个不同的线程总是看到某个成员变量的同一个值&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-运算符&#34;&gt;java 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;其他运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;/&lt;/code&gt;,&lt;code&gt;%&lt;/code&gt;,&lt;code&gt;++&lt;/code&gt;,&lt;code&gt;--&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算&lt;/li&gt;
&lt;li&gt;后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt;,&lt;code&gt;!=&lt;/code&gt;,&lt;code&gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;=&lt;/code&gt;,&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;,&lt;code&gt;|&lt;/code&gt;,&lt;code&gt;^&lt;/code&gt;,&lt;code&gt;~&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/09/SmKYWLxFpNgVylT.png&#34; alt=&#34;位运算符.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt;,&lt;code&gt;+=&lt;/code&gt;,&lt;code&gt;-=&lt;/code&gt;,&lt;code&gt;*=&lt;/code&gt;,&lt;code&gt;/=&lt;/code&gt;,&lt;code&gt;(%)=&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;,&lt;code&gt;&amp;amp;=&lt;/code&gt;,&lt;code&gt;^=&lt;/code&gt;,&lt;code&gt;|=&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;条件运算符（三元运算符）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;variable x = (expression) ? value if true : value if false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;code&gt;b = (a == 1) ? 20 : 30;&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;instanceof运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;( Object reference variable ) instanceof (class/interface type)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String name = &amp;quot;James&amp;quot;;
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/09/BfPx341d8E9zSwG.png&#34; alt=&#34;运算符优先级.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;java循环结构&#34;&gt;Java循环结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;while循环&lt;/li&gt;
&lt;li&gt;do...while循环&lt;/li&gt;
&lt;li&gt;for循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java增强for循环&#34;&gt;Java增强for循环&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for(声明语句 : 表达式)
{
    // 代码句子
}
// 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配
// 表达式：要访问的数组名，或者是返回值为数组的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test{
    public static void main(String[] args){
        String [] names = {&amp;quot;James&amp;quot;, &amp;quot;Larry&amp;quot;, &amp;quot;Tom&amp;quot;, &amp;quot;Lacy&amp;quot;};
        for(String name : names){
            System.out.print(name);
            System.out.print(&amp;quot;,&amp;quot;);
        }
    }
}

// James,Larry,Tom,Lacy,
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;break关键字&#34;&gt;break关键字&lt;/h3&gt;
&lt;p&gt;break 主要用在循环语句或者 switch 语句中，用来跳出语句块&lt;/p&gt;
&lt;h3 id=&#34;continue关键字&#34;&gt;continue关键字&lt;/h3&gt;
&lt;p&gt;让程序立刻跳转到下一次循环的迭代&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java条件语句&#34;&gt;Java条件语句&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;if语句&lt;/li&gt;
&lt;li&gt;if...else语句&lt;/li&gt;
&lt;li&gt;if..else if...else语句&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-switch-case语句&#34;&gt;Java switch case语句&lt;/h2&gt;
&lt;p&gt;switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出直至break语句出现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String args[]){
      int i = 1;
      switch(i){
         case 0:
            System.out.println(&amp;quot;0&amp;quot;);
         case 1:
            System.out.println(&amp;quot;1&amp;quot;);
         case 2:
            System.out.println(&amp;quot;2&amp;quot;);
         case 3:
            System.out.println(&amp;quot;3&amp;quot;); break;
         default:
            System.out.println(&amp;quot;default&amp;quot;);
      }
   }
}

// 1
// 2
// 3
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;h3 id=&#34;声明数组变量&#34;&gt;声明数组变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dataType[] arrayRefVar;   // 首选的方法
 
或
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建数组&#34;&gt;创建数组&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;arrayRefVar = new dataType[arraySize];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;数组变量的声明，和创建数组可以用一条语句完成:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dataType[] arrayRefVar = new dataType[arraySize];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其他：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dataType[] arrayRefVar = {value0, value1, ..., valuek};&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;数组作为方法的参数或返回值&#34;&gt;数组作为方法的参数或返回值&lt;/h3&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;printArray(new int[]{3, 1, 2, 6, 4, 2});&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;多维数组&#34;&gt;多维数组&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;String[][] str = new String[3][4];&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;arrays类&#34;&gt;Arrays类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;给数组赋值：通过 fill 方法&lt;/li&gt;
&lt;li&gt;对数组排序：通过 sort 方法,按升序&lt;/li&gt;
&lt;li&gt;比较数组：通过 equals 方法比较数组中元素值是否相等&lt;/li&gt;
&lt;li&gt;查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;日期和时间date类&#34;&gt;日期和时间（Date类）&lt;/h2&gt;
&lt;p&gt;实例化Date对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Date()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Date(long milliseconds)&lt;/code&gt;:该参数为1970.01.01起的毫秒数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;date对象方法&#34;&gt;Date对象方法：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/NuxSwZg4ChOGVKd.png&#34; alt=&#34;Date方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;使用simpledateformat格式化日期&#34;&gt;使用SimpleDateFormat格式化日期&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SimpleDateFormat ft = new SimpleDateFormat (&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用printf格式化日期&#34;&gt;使用printf格式化日期&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/DbGnxh2APTH9qfW.png&#34; alt=&#34;printf格式化日期.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;全部日期和时间信息：%tc%n&amp;quot;,date);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;%1$s %2$tB %2$td, %2$tY&amp;quot;, &amp;quot;Due date:&amp;quot;, date);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;%s %tB %&amp;lt;te, %&amp;lt;tY&amp;quot;, &amp;quot;Due date:&amp;quot;, date);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;java休眠sleep&#34;&gt;Java休眠（sleep）&lt;/h3&gt;
&lt;p&gt;sleep()阻塞当前进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
  
public class SleepDemo {
    public static void main(String[] args) {
        try { 
            System.out.println(new Date( ) + &amp;quot;\n&amp;quot;); 
            Thread.sleep(1000*3);   // 休眠3秒
            System.out.println(new Date( ) + &amp;quot;\n&amp;quot;); 
        } catch (Exception e) { 
            System.out.println(&amp;quot;Got an exception!&amp;quot;); 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测量时间&#34;&gt;测量时间&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
  
public class DiffDemo {
 
   public static void main(String[] args) {
      try {
         long start = System.currentTimeMillis( );
         System.out.println(new Date( ) + &amp;quot;\n&amp;quot;);
         Thread.sleep(5*60*10);
         System.out.println(new Date( ) + &amp;quot;\n&amp;quot;);
         long end = System.currentTimeMillis( );
         long diff = end - start;
         System.out.println(&amp;quot;Difference is : &amp;quot; + diff);
      } catch (Exception e) {
         System.out.println(&amp;quot;Got an exception!&amp;quot;);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;calendar类对日期进行操作&#34;&gt;Calendar类（对日期进行操作）&lt;/h3&gt;
&lt;p&gt;创建Calendar对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Calendar c = Calendar.getInstance();//默认是当前日期&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//创建一个代表2009年6月12日的Calendar对象&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Calendar c1 = Calendar.getInstance();&lt;/code&gt;&lt;br&gt;
&lt;code&gt;c1.set(2009, 6 - 1, 12);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象信息的设置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set设置：&lt;code&gt;public final void set(int year,int month,int date)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add设置：&lt;code&gt;c1.add(Calendar.DATE, 10);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象信息的获得:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int year = c1.get(Calendar.YEAR);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;gregoriancalendar类&#34;&gt;GregorianCalendar类&lt;/h3&gt;
&lt;p&gt;GregorianCalendar对象构造方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/Yomul6awe2RshgL.png&#34; alt=&#34;GregorianCalendar构造方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;GregorianCalendar对象常用方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/RxTBoJFD1AIplwq.png&#34; alt=&#34;GregorianCalendar常用方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java正则表达式&#34;&gt;Java正则表达式&lt;/h2&gt;
&lt;h3 id=&#34;正则表达式语法&#34;&gt;正则表达式语法：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/Mpk1wGBncSCRXOP.png&#34; alt=&#34;正则表达式语法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;regex包&#34;&gt;regex包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pattern类：Pattern对象是一个正则表达式的编译表示&lt;/li&gt;
&lt;li&gt;Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎&lt;/li&gt;
&lt;li&gt;PatternSyntaxException类：是一个非强制异常类，表示一个正则表达式模式中的语法错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;matcher类的方法&#34;&gt;Matcher类的方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/HKFdD3Gmsl7xXcI.png&#34; alt=&#34;matcher方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;patternsyntaxexception类的方法&#34;&gt;PatternSyntaxException类的方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/ji7tRZLYEQkwg31.png&#34; alt=&#34;patternsyntaxexception方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-流stream-文件file-io&#34;&gt;Java 流（stream）、文件（file）、IO&lt;/h2&gt;
&lt;p&gt;Java.io 包几乎包含了所有操作输入、输出需要的类&lt;/p&gt;
&lt;p&gt;一个流可以理解为一个数据的序列&lt;/p&gt;
&lt;p&gt;输入流表示从一个源读取数据，输出流表示向一个目标写数据&lt;/p&gt;
&lt;h3 id=&#34;读取控制台输入&#34;&gt;读取控制台输入&lt;/h3&gt;
&lt;p&gt;把System.in包装在一个BufferedReader对象中创建一个字符流&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BufferedReader br = new BufferedReader(new InputStreamReader(System.in));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;BufferedReader对象创建后，read()方法从控制台读取一个字符，readLine()方法从控制台读取一个字符串&lt;/p&gt;
&lt;p&gt;从控制台读取多字符输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int read( ) throws IOException&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用 BufferedReader 在控制台读取字符
 
import java.io.*;
 
public class BRRead {
    public static void main(String[] args) throws IOException {
        char c;
        // 使用 System.in 创建 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(&amp;quot;输入字符, 按下 &#39;q&#39; 键退出。&amp;quot;);
        // 读取字符
        do {
            c = (char) br.read();
            System.out.println(c);
        } while (c != &#39;q&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从控制台读取字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String readLine( ) throws IOException&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用 BufferedReader 在控制台读取字符
import java.io.*;
 
public class BRReadLines {
    public static void main(String[] args) throws IOException {
        // 使用 System.in 创建 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str;
        System.out.println(&amp;quot;Enter lines of text.&amp;quot;);
        System.out.println(&amp;quot;Enter &#39;end&#39; to quit.&amp;quot;);
        do {
            str = br.readLine();
            System.out.println(str);
        } while (!str.equals(&amp;quot;end&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;控制台输出&#34;&gt;控制台输出&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;System.out.print()&lt;/code&gt;, &lt;code&gt;System.out.println()&lt;/code&gt;, &lt;code&gt;System.out.write()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;读写文件&#34;&gt;读写文件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;FileInputStream&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该流用于读取数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用字符串类型的文件名来创建一个输入流对象来读取文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InputStream f = new FileInputStream(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用一个文件对象来创建一个输入流对象来读取文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File f = new File(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;InputStream in = new FileInputStream(f);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InputStream对象的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/3MpPyQUnLdIxrFD.png&#34; alt=&#34;InputStream方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该流用于创建一个文件并像文件中写入数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用字符串类型的文件名来创建一个输出流对象&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OutputStream f = new FileOutputStream(&amp;quot;C:/java/hello&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用一个文件对象来创建一个输出流来写文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File f = new File(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;OutputStream fOut = new FileOutputStream(f);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OutputStream对象的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/STUIgC2LF8MRcZ4.png&#34; alt=&#34;OutputStream方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其他输出流：&lt;code&gt;ByteArrayOutputStream&lt;/code&gt;、&lt;code&gt;DataOutputStream&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
 
public class fileStreamTest {
    public static void main(String[] args) {
        try {
            byte bWrite[] = { 11, 21, 3, 40, 5 };
            OutputStream os = new FileOutputStream(&amp;quot;test.txt&amp;quot;);
            for (int x = 0; x &amp;lt; bWrite.length; x++) {
                os.write(bWrite[x]); // writes the bytes
            }
            os.close();
 
            InputStream is = new FileInputStream(&amp;quot;test.txt&amp;quot;);
            int size = is.available();
 
            for (int i = 0; i &amp;lt; size; i++) {
                System.out.print((char) is.read() + &amp;quot;  &amp;quot;);
            }
            is.close();
        } catch (IOException e) {
            System.out.print(&amp;quot;Exception&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;关于文件和io的类&#34;&gt;关于文件和I/O的类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;File Class&lt;/li&gt;
&lt;li&gt;FileReader Class&lt;/li&gt;
&lt;li&gt;FileWriter Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mkdir()方法创建一个文件夹，成功返回true，失败返回false&lt;/li&gt;
&lt;li&gt;mkidrs()方法创建一个文件夹和它所有父类文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 
public class CreateDir {
    public static void main(String[] args) {
        String dirname = &amp;quot;/tmp/user/java/bin&amp;quot;;
        File d = new File(dirname);
        // 现在创建目录
        d.mkdirs();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;读取目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调用该对象的list()方法，提取目录包含的文件和文件夹列表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 
public class DirList {
    public static void main(String args[]) {
        String dirname = &amp;quot;/tmp&amp;quot;;
        File f1 = new File(dirname);
        if (f1.isDirectory()) {
            System.out.println(&amp;quot;目录 &amp;quot; + dirname);
            String s[] = f1.list();
            for (int i = 0; i &amp;lt; s.length; i++) {
                File f = new File(dirname + &amp;quot;/&amp;quot; + s[i]);
                if (f.isDirectory()) {
                    System.out.println(s[i] + &amp;quot; 是一个目录&amp;quot;);
                } else {
                    System.out.println(s[i] + &amp;quot; 是一个文件&amp;quot;);
                }
            }
        } else {
            System.out.println(dirname + &amp;quot; 不是一个目录&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;删除目录或文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;java.io.File.delete()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;删除某一目录时，必须保证该目录下没有其他文件&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;scanner-类&#34;&gt;Scanner 类&lt;/h2&gt;
&lt;p&gt;用于获取用户的输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Scanner s = new Scanner(System.in)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scanner类的next()和nextLine()获取输入的字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;next()以空白为结束符，不能得到带空格的字符串&lt;/li&gt;
&lt;li&gt;nextLine()以Enter为结束符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以读取其他类型的数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nextXxx()&lt;/code&gt;: 例如 f = scan.nextFloat()&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;异常发生的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户输入非法字符&lt;/li&gt;
&lt;li&gt;要打开的文件不存在&lt;/li&gt;
&lt;li&gt;网络通信连接中断，或者JVM内存溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种类型的异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查性异常&lt;/li&gt;
&lt;li&gt;运行时异常&lt;/li&gt;
&lt;li&gt;错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exception类有两个主要的子类：IOException类和RuntimeException类&lt;/p&gt;
&lt;h3 id=&#34;java-内置异常类&#34;&gt;java 内置异常类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/h7Vr2tE3Gi8vW19.png&#34; alt=&#34;内置异常类.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;异常方法&#34;&gt;异常方法&lt;/h3&gt;
&lt;h3 id=&#34;捕获异常&#34;&gt;捕获异常&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try
{
   // 程序代码
}catch(ExceptionName e1)
{
   //Catch 块
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;catch语句包含要捕获异常的声明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
public class ExcepTest{
 
   public static void main(String args[]){
      try{
         int a[] = new int[2];
         System.out.println(&amp;quot;Access element three :&amp;quot; + a[3]);
      }catch(ArrayIndexOutOfBoundsException e){
         System.out.println(&amp;quot;Exception thrown  :&amp;quot; + e);
      }
      System.out.println(&amp;quot;Out of the block&amp;quot;);
   }
}


//Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 2
//Out of the block
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多重捕获块&#34;&gt;多重捕获块&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try{
   // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}catch(异常类型3 异常的变量名3){
  // 程序代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;throwsthrow关键字&#34;&gt;throws/throw关键字&lt;/h3&gt;
&lt;p&gt;如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws/throw 关键字来声明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void withdraw(double amount) throws RemoteException InsufficientFundsException&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;finally-关键字&#34;&gt;finally 关键字&lt;/h3&gt;
&lt;p&gt;无论是否发生异常，finally 代码块中的代码总会被执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try{
  // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}finally{
  // 程序代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;声明自定义异常&#34;&gt;声明自定义异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有异常都必须是 Throwable 的子类&lt;/li&gt;
&lt;li&gt;如果希望写一个检查性异常类，则需要继承 Exception 类&lt;/li&gt;
&lt;li&gt;如果你想写一个运行时异常类，那么需要继承 RuntimeException 类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用异常&#34;&gt;通用异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JVM异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类&lt;/li&gt;
&lt;li&gt;程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类&lt;/li&gt;
&lt;/ul&gt;
">基础语法</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






  <div class="snow-container"></div>
  <script color="0,205,205" pointer-events="auto" zIndex="-1" opacity='0.7' count="99" src="/media/js/bg/canvas-nest.js"></script>

</html>