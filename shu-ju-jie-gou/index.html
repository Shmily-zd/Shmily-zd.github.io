<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="1">
<meta name="theme-color" content="#868e96">
<title>数据结构 | zd_blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1647323526970">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/atom-one-dark.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="数据结构" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>zd_blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">等风来 or 追风去</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top/archives" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top/tags" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">zd</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">1</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%9E%9A%E4%B8%BEenumeration">枚举(Enumeration)</a></li>
<li><a href="#%E4%BD%8D%E9%9B%86%E5%90%88bitset">位集合(BitSet)</a></li>
<li><a href="#%E5%90%91%E9%87%8Fvector">向量(Vector)</a></li>
<li><a href="#%E6%A0%88stack">栈(Stack)</a></li>
<li><a href="#%E5%AD%97%E5%85%B8dictionary">字典(Dictionary)</a>
<ul>
<li><a href="#map%E6%8E%A5%E5%8F%A3">Map接口</a></li>
</ul>
</li>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8hashtable">哈希表(Hashtable)</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7properties">属性(Properties)</a></li>
<li><a href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">集合框架</a>
<ul>
<li><a href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%8E%A5%E5%8F%A3">集合框架接口：</a></li>
<li><a href="#%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB%E9%9B%86%E5%90%88%E7%B1%BB">集合实现类（集合类）</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8iterator">迭代器(Iterator)</a>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8">获取迭代器</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0">循环集合元素</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0">删除集合元素</a></li>
<li><a href="#%E9%81%8D%E5%8E%86arraylist">遍历ArrayList</a></li>
<li><a href="#%E9%81%8D%E5%8E%86map">遍历Map</a></li>
</ul>
</li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%99%A8">比较器</a></li>
</ul>
</li>
<li><a href="#arraylist-%E7%B1%BB">ArrayList 类</a></li>
<li><a href="#linkedlist-%E7%B1%BB%E9%93%BE%E8%A1%A8">LinkedList 类（链表）</a></li>
<li><a href="#hashset">HashSet</a></li>
<li><a href="#hashmap">HashMap</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://zdblog.top/shu-ju-jie-gou/"> 数据结构 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-03-15 13:47:00">2022-03-15</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >16<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >3237<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/shu-ju-jie-gou/"
      data-flag-title="数据结构"
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <h2 id="枚举enumeration">枚举(Enumeration)</h2>
<p>枚举接口本身不属于数据结构</p>
<p>枚举接口定义了一种从数据结构中取回连续元素的方法</p>
<p>已被迭代器取代</p>
<p>Enumeration声明的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean hasMoreElements()</td>
<td style="text-align:left">测试此枚举是否包含更多的元素</td>
</tr>
<tr>
<td style="text-align:left">Object nextElements()</td>
<td style="text-align:left">如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素</td>
</tr>
</tbody>
</table>
<p>eg:</p>
<pre><code class="language-java">import java.util.Vector;
import java.util.Enumeration;
 
public class EnumerationTester {
 
   public static void main(String args[]) {
      Enumeration&lt;String&gt; days;
      Vector&lt;String&gt; dayNames = new Vector&lt;String&gt;();
      dayNames.add(&quot;Sunday&quot;);
      dayNames.add(&quot;Monday&quot;);
      dayNames.add(&quot;Tuesday&quot;);
      dayNames.add(&quot;Wednesday&quot;);
      dayNames.add(&quot;Thursday&quot;);
      dayNames.add(&quot;Friday&quot;);
      dayNames.add(&quot;Saturday&quot;);
      days = dayNames.elements();
      while (days.hasMoreElements()){
         System.out.println(days.nextElement()); 
      }
   }
}
</code></pre>
<hr>
<h2 id="位集合bitset">位集合(BitSet)</h2>
<p>该集合类实现了一组可以反赌设置和清除的位或是标志</p>
<p>构造方法：</p>
<ul>
<li>Bitset(): 创建一个默认对象</li>
<li>BitSet(int size): 指定初始大小，所有位初始为0</li>
</ul>
<p>BitSet中实现了Cloneable接口中定义的方法如下表所列：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/03/13/Opdi1H87kYStvF5.png" alt="bitset方法.png" loading="lazy"></figure>
<p>eg:</p>
<pre><code class="language-java">import java.util.BitSet;
 
public class BitSetDemo {
 
  public static void main(String args[]) {
     BitSet bits1 = new BitSet(16);
     BitSet bits2 = new BitSet(16);
      
     // set some bits
     for(int i=0; i&lt;16; i++) {
        if((i%2) == 0) bits1.set(i);
        if((i%5) != 0) bits2.set(i);
     }
     System.out.println(&quot;Initial pattern in bits1: &quot;);
     System.out.println(bits1);
     System.out.println(&quot;\nInitial pattern in bits2: &quot;);
     System.out.println(bits2);
 
     // AND bits
     bits2.and(bits1);
     System.out.println(&quot;\nbits2 AND bits1: &quot;);
     System.out.println(bits2);
 
     // OR bits
     bits2.or(bits1);
     System.out.println(&quot;\nbits2 OR bits1: &quot;);
     System.out.println(bits2);
 
     // XOR bits
     bits2.xor(bits1);
     System.out.println(&quot;\nbits2 XOR bits1: &quot;);
     System.out.println(bits2);
  }
}
</code></pre>
<hr>
<h2 id="向量vector">向量(Vector)</h2>
<p>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化</p>
<p>Vector类实现了动态数组</p>
<p>和ArrayList的区别：</p>
<ul>
<li>Vector 是同步访问的</li>
<li>Vector 包含了许多传统的方法，这些方法不属于集合框架</li>
</ul>
<p>构造方法：</p>
<ul>
<li>Vector(): 创建默认向量，大小为10</li>
<li>Vector(int size): 创建指定大小的向量</li>
<li>Vector(int size, int incr): 创建指定大小和增量的向量</li>
<li>Vector(Collection c): 创建一个包含集合c元素的向量</li>
</ul>
<p>Vector定义的方法：</p>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/03/13/Ix78Va9vgHWzupO.png" alt="vector方法.png" loading="lazy"></figure>
<pre><code class="language-java">import java.util.*;

public class VectorDemo {

    public static void main(String args[]) {
        // initial size is 3, increment is 2
        Vector v = new Vector(3, 2);
        System.out.println(&quot;Initial size: &quot; + v.size());
        System.out.println(&quot;Initial capacity: &quot; + v.capacity());
        v.addElement(new Integer(1));
        v.addElement(new Integer(2));
        v.addElement(new Integer(3));
        v.addElement(new Integer(4));
        System.out.println(&quot;Capacity after four additions: &quot; + v.capacity());

        v.addElement(new Double(5.45));
        System.out.println(&quot;Current capacity: &quot; + v.capacity());
        v.addElement(new Double(6.08));
        v.addElement(new Integer(7));
        System.out.println(&quot;Current capacity: &quot; + v.capacity());
        v.addElement(new Float(9.4));
        v.addElement(new Integer(10));
        System.out.println(&quot;Current capacity: &quot; + v.capacity());
        v.addElement(new Integer(11));
        v.addElement(new Integer(12));
        System.out.println(&quot;First element: &quot; + (Integer)v.firstElement());
        System.out.println(&quot;Last element: &quot; + (Integer)v.lastElement());
        if(v.contains(new Integer(3)))
            System.out.println(&quot;Vector contains 3.&quot;);
        // enumerate the elements in the vector.
        Enumeration vEnum = v.elements();
        System.out.println(&quot;\nElements in vector:&quot;);
        while(vEnum.hasMoreElements())
            System.out.print(vEnum.nextElement() + &quot; &quot;);
        System.out.println();
    }
}
</code></pre>
<hr>
<h2 id="栈stack">栈(Stack)</h2>
<p>Stack是Vector的一个子类，实现一个标准的后进先出的栈</p>
<p>栈只定义了默认构造方法<code>Stack()</code></p>
<p>栈继承了Vector的所有方法，也自定义了一些方法：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/03/13/hDHF4MXg6wuzA9T.png" alt="Stack方法.png" loading="lazy"></figure>
<pre><code class="language-java">import java.util.*;
 
public class StackDemo {
 
    static void showpush(Stack&lt;Integer&gt; st, int a) {
        st.push(new Integer(a));
        System.out.println(&quot;push(&quot; + a + &quot;)&quot;);
        System.out.println(&quot;stack: &quot; + st);
    }
 
    static void showpop(Stack&lt;Integer&gt; st) {
        System.out.print(&quot;pop -&gt; &quot;);
        Integer a = (Integer) st.pop();
        System.out.println(a);
        System.out.println(&quot;stack: &quot; + st);
    }
 
    public static void main(String args[]) {
        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();
        System.out.println(&quot;stack: &quot; + st);
        showpush(st, 42);
        showpush(st, 66);
        showpush(st, 99);
        showpop(st);
        showpop(st);
        showpop(st);
        try {
            showpop(st);
        } catch (EmptyStackException e) {
            System.out.println(&quot;empty stack&quot;);
        }
    }
}


// stack: [ ]
// push(42)
// stack: [42]
// ...
</code></pre>
<hr>
<h2 id="字典dictionary">字典(Dictionary)</h2>
<p>Dictionary类是一个抽象类，用来存储键值对，作用和实现Map接口相似</p>
<p>字典已经被实现Map接口取代</p>
<p>Dictionary类定义的方法：</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/03/13/FUGb2d5tAr6OIQo.png" alt="dictionary方法.png" loading="lazy"></figure>
<h3 id="map接口">Map接口</h3>
<p>抛出异常：</p>
<ul>
<li>给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值</li>
<li>当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常</li>
<li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常</li>
<li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常</li>
<li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常</li>
</ul>
<p>Map定义的方法：</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/03/13/sHt8IeSNJ7AuTGa.png" alt="Map方法.png" loading="lazy"></figure>
<p>eg：</p>
<pre><code class="language-java">import java.util.*;

public class CollectionsDemo {

    public static void main(String[] args) {
        Map m1 = new HashMap(); 
        m1.put(&quot;Zara&quot;, &quot;8&quot;);
        m1.put(&quot;Mahnaz&quot;, &quot;31&quot;);
        m1.put(&quot;Ayan&quot;, &quot;12&quot;);
        m1.put(&quot;Daisy&quot;, &quot;14&quot;);
        System.out.println();
        System.out.println(&quot; Map Elements&quot;);
        System.out.print(&quot;\t&quot; + m1);
    }
}


// Map Elements
//         {Mahnaz=31, Ayan=12, Daisy=14, Zara=8}
</code></pre>
<hr>
<h2 id="哈希表hashtable">哈希表(Hashtable)</h2>
<p>Hashtable现在集成到了集合框架中，和HashMap类很相似，但支持同步</p>
<p>Hashtable在哈希表中存储键值对</p>
<p>当使用一个哈希表时，要指定用作键的对象，以及链接到该键的值</p>
<p>该键经过哈希处理，所得的散列码被用作存储在该表中值的索引</p>
<p>Hashtable类定义的构造方法：</p>
<ul>
<li>Hashtable()</li>
<li>Hashtable(int size): 创建指定大小的哈希表</li>
<li>Hashtable(int size, float fillRation): 创建指定大小和填充比例的哈希表</li>
<li>Hashtable(Map m): 创建一个以M重元素未初始化元素的哈希表，其容量被设置为M的两倍</li>
</ul>
<p>Hashtable除了Map接口中定义的方法，还有自定义了：</p>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/03/13/ol1hWptzTmU3d58.png" alt="hashtable方法.png" loading="lazy"></figure>
<p>eg:</p>
<pre><code class="language-java">import java.util.*;

public class HashTableDemo {

   public static void main(String args[]) {
      // Create a hash map
      Hashtable balance = new Hashtable();
      Enumeration names;
      String str;
      double bal;

      balance.put(&quot;Zara&quot;, new Double(3434.34));
      balance.put(&quot;Mahnaz&quot;, new Double(123.22));
      balance.put(&quot;Ayan&quot;, new Double(1378.00));
      balance.put(&quot;Daisy&quot;, new Double(99.22));
      balance.put(&quot;Qadir&quot;, new Double(-19.08));

      // Show all balances in hash table.
      names = balance.keys();
      while(names.hasMoreElements()) {
         str = (String) names.nextElement();
         System.out.println(str + &quot;: &quot; +
         balance.get(str));
      }
      System.out.println();
      // Deposit 1,000 into Zara's account
      bal = ((Double)balance.get(&quot;Zara&quot;)).doubleValue();
      balance.put(&quot;Zara&quot;, new Double(bal+1000));
      System.out.println(&quot;Zara's new balance: &quot; +
      balance.get(&quot;Zara&quot;));
   }
}

</code></pre>
<hr>
<h2 id="属性properties">属性(Properties)</h2>
<p>Properties 继承于 Hashtable, Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串</p>
<p>Properties 定义如下实例变量.这个变量持有一个 Properties 对象相关的默认属性列表：</p>
<p><code>Properties defaults;</code></p>
<p>构造方法：</p>
<ul>
<li>Properties()</li>
<li>Properties(Properties propDefault)   // 两种情况下 ，属性列表都为空</li>
</ul>
<p>Properties类除了继承Hashtable中的方法，自定义了：</p>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/03/13/hXfoCp9qtLHmejz.png" alt="properties方法.png" loading="lazy"></figure>
<p>eg:</p>
<pre><code class="language-java">import java.util.*;
 
public class PropDemo {
 
    public static void main(String args[]) {
        Properties capitals = new Properties();
        Set states;
        String str;
        
        capitals.put(&quot;Illinois&quot;, &quot;Springfield&quot;);
        capitals.put(&quot;Missouri&quot;, &quot;Jefferson City&quot;);
        capitals.put(&quot;Washington&quot;, &quot;Olympia&quot;);
        capitals.put(&quot;California&quot;, &quot;Sacramento&quot;);
        capitals.put(&quot;Indiana&quot;, &quot;Indianapolis&quot;);
    
        // Show all states and capitals in hashtable.
        states = capitals.keySet(); // get set-view of keys
        Iterator itr = states.iterator();
        while(itr.hasNext()) {
            str = (String) itr.next();
            System.out.println(&quot;The capital of &quot; + str + &quot; is &quot; + capitals.getProperty(str) + &quot;.&quot;);
        }
        System.out.println();
    
        // look for state not in list -- specify default
        str = capitals.getProperty(&quot;Florida&quot;, &quot;Not Found&quot;);
        System.out.println(&quot;The capital of Florida is &quot; + str + &quot;.&quot;);
    }
}
</code></pre>
<hr>
<p><strong>以上这些类是传统遗留的，后面引入新的框架--集合框架(Collection)</strong></p>
<hr>
<h2 id="集合框架">集合框架</h2>
<p>上述的类缺少一个核心的、统一的主题，不同类的使用方法有着很大的不同</p>
<p>集合框架的要求：</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性</li>
<li>对一个集合的扩展和适应必须是简单的</li>
</ul>
<p>所以，集合框架就围绕一组标准接口而设计</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/03/13/7WgzAt2Px9dpDJB.png" alt="集合框架图.png" loading="lazy"></figure>
<p>Java集合框架主要包括两种类型容器：</p>
<ul>
<li>集合(Collection)：存储一个元素</li>
<li>图(Map)：存储键值对映射</li>
</ul>
<p>集合框架都包含：</p>
<ul>
<li>
<p>接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</p>
</li>
<li>
<p>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap</p>
</li>
<li>
<p>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现</p>
</li>
</ul>
<h3 id="集合框架接口">集合框架接口：</h3>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/03/13/LFs54yEOK3WJMlp.png" alt="集合框架接口.png" loading="lazy"></figure>
<h3 id="集合实现类集合类">集合实现类（集合类）</h3>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/03/13/of3lVvQ2G6bXen8.png" alt="集合实现类.png" loading="lazy"></figure>
<h3 id="迭代器iterator">迭代器(Iterator)</h3>
<p>迭代器是一种访问集合的方法</p>
<p>Iterator是迭代器最简单的实现，ListIterator是Collection API中的接口，拓展了Iterator接口</p>
<p><code>import java.util.Iterator; // 引入 Iterator 类</code></p>
<ul>
<li>it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态</li>
<li>it.hasNext() 用于检测集合中是否还有元素</li>
<li>it.remove() 将迭代器返回的元素删除</li>
</ul>
<h4 id="获取迭代器">获取迭代器</h4>
<p><code>iterator()</code>方法</p>
<h4 id="循环集合元素">循环集合元素</h4>
<pre><code class="language-java">while(it.hasNext()) {
    System.out.println(it.next());
}
</code></pre>
<h4 id="删除集合元素">删除集合元素</h4>
<p><code>remove()</code>方法</p>
<p>eg:</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Iterator;

public class RunoobTest {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
        numbers.add(12);
        numbers.add(8);
        numbers.add(2);
        numbers.add(23);
        Iterator&lt;Integer&gt; it = numbers.iterator();
        while(it.hasNext()) {
            Integer i = it.next();
            if(i &lt; 10) {  
                it.remove();  // 删除小于 10 的元素
            }
        }
        System.out.println(numbers);
    }
}

// [12, 23]
</code></pre>
<h4 id="遍历arraylist">遍历ArrayList</h4>
<pre><code class="language-java">import java.util.*;
 
public class Test{
    public static void main(String[] args) {
        List&lt;String&gt; list=new ArrayList&lt;String&gt;();
        list.add(&quot;Hello&quot;);
        list.add(&quot;World&quot;);
        list.add(&quot;HAHAHAHA&quot;);
        //第一种遍历方法使用 For-Each 遍历 List
        for (String str : list) {            //也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式
            System.out.println(str);
        }
    
        //第二种遍历，把链表变为数组相关的内容进行遍历
        String[] strArray=new String[list.size()];
        list.toArray(strArray);
        for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为  for(String str:strArray) 这种形式
        {
            System.out.println(strArray[i]);
        }
        
        //第三种遍历 使用迭代器进行相关遍历
        
        Iterator&lt;String&gt; ite=list.iterator();
        while(ite.hasNext())//判断下一个元素之后有值
        {
            System.out.println(ite.next());
        }
    }
}
</code></pre>
<h4 id="遍历map">遍历Map</h4>
<pre><code class="language-java">import java.util.*;
 
public class Test{
    public static void main(String[] args) {
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        map.put(&quot;1&quot;, &quot;value1&quot;);
        map.put(&quot;2&quot;, &quot;value2&quot;);
        map.put(&quot;3&quot;, &quot;value3&quot;);
        
        //第一种：普遍使用，二次取值
        System.out.println(&quot;通过Map.keySet遍历key和value：&quot;);
        for (String key : map.keySet()) {
        System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key));
        }
        
        //第二种
        System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;);
        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();
        while (it.hasNext()) {
        Map.Entry&lt;String, String&gt; entry = it.next();
        System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());
        }
        
        //第三种：推荐，尤其是容量大时
        System.out.println(&quot;通过Map.entrySet遍历key和value&quot;);
        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
        System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());
        }
        
        //第四种
        System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;);
        for (String v : map.values()) {
        System.out.println(&quot;value= &quot; + v);
        }
    }
}
</code></pre>
<h3 id="比较器">比较器</h3>
<p>Comparator接口定义了两个方法：</p>
<ul>
<li>compare()</li>
<li>equals()</li>
</ul>
<p><code>int compare(Object obj1, Object obj2)</code></p>
<hr>
<h2 id="arraylist-类">ArrayList 类</h2>
<p>ArrayList类是一个可以动态修改的数组</p>
<p>继承了AbstractList，并实现了List接口</p>
<p><code>ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;();　 // 初始化</code></p>
<p>ArrayList常用方法：</p>
<figure data-type="image" tabindex="11"><img src="https://s2.loli.net/2022/03/13/6QiPYmqj2pxoAeG.png" alt="ArrayList常用方法.png" loading="lazy"></figure>
<hr>
<h2 id="linkedlist-类链表">LinkedList 类（链表）</h2>
<p>链表是一种线性表，在每个节点里存放下一节点的地址</p>
<p>可分为<code>单链表</code>和<code>双链表</code></p>
<p>单链表包含当前结点的值和指向后节点的链接两个值</p>
<p>双链表多了向后结点的链接</p>
<p>与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低</p>
<p>ArrayList：</p>
<ul>
<li>频繁访问列表中的某一个元素</li>
<li>只需要在列表末尾进行添加和删除元素操作</li>
</ul>
<p>LinkedList：</p>
<ul>
<li>需要通过循环迭代来访问列表中的某些元素</li>
<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作</li>
</ul>
<p>LinkedList 继承了 AbstractSequentialList 类</p>
<p>LinkedList 实现了 Queue 接口，可作为队列使用</p>
<p>LinkedList 实现了 List 接口，可进行列表的相关操作</p>
<p>LinkedList 实现了 Deque 接口，可作为队列使用</p>
<p>LinkedList 实现了 Cloneable 接口，可实现克隆</p>
<p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输</p>
<pre><code class="language-java">LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;();   // 普通创建方法
或者
LinkedList&lt;E&gt; list = new LinkedList(Collection&lt;? extends E&gt; c); // 使用集合创建链表
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2022/03/13/TvVpFPnZl87XC1w.png" alt="LinkedList常用方法.png" loading="lazy"></figure>
<hr>
<h2 id="hashset">HashSet</h2>
<p>HashSet是一个不允许有重复元素的集合，允许有null值</p>
<p>无序的</p>
<p>非线程安全</p>
<p>实现了Set接口</p>
<p><code>HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;();</code></p>
<figure data-type="image" tabindex="13"><img src="https://s2.loli.net/2022/03/13/32voSbfi9wck5dR.png" alt="HashSet方法.png" loading="lazy"></figure>
<hr>
<h2 id="hashmap">HashMap</h2>
<p>HashMap是一个散列表，存储了键值对的映射</p>
<p>实现了Map接口</p>
<p>最多允许一条记录的键位null，不支持线程同步</p>
<p>无序的</p>
<p>继承了AbstractMap，实现了Map、Cloneable、java.io.Serializable接口</p>
<p>HashMap的key与value的类型可以不同</p>
<p><code>HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;();</code></p>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2022/03/14/QULCFrKElsuIfX8.png" alt="HashMap方法.png" loading="lazy"></figure>
<hr>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      zd
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://zdblog.top/shu-ju-jie-gou/" title="数据结构">https://zdblog.top/shu-ju-jie-gou/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="面向对象" href="https://zdblog.top/mian-xiang-dui-xiang/">面向对象</a>
        <a class="nav-mobile-next" title="面向对象" href="https://zdblog.top/mian-xiang-dui-xiang/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'E4xhzIEKDmAtoVnapYU5F67t-gzGzoHsz',
    appKey: 'Q1txwwJSaEmLcu4Oo8cHshbP',
    avatar: '',
    placeholder: '',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'true',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="\media\images\wallhaven-j5p6v5.jpg" />
              </div>
              
                
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/shu-ju-jie-gou/"" data-c="
          &lt;h2 id=&#34;枚举enumeration&#34;&gt;枚举(Enumeration)&lt;/h2&gt;
&lt;p&gt;枚举接口本身不属于数据结构&lt;/p&gt;
&lt;p&gt;枚举接口定义了一种从数据结构中取回连续元素的方法&lt;/p&gt;
&lt;p&gt;已被迭代器取代&lt;/p&gt;
&lt;p&gt;Enumeration声明的方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;boolean hasMoreElements()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测试此枚举是否包含更多的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Object nextElements()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.Vector;
import java.util.Enumeration;
 
public class EnumerationTester {
 
   public static void main(String args[]) {
      Enumeration&amp;lt;String&amp;gt; days;
      Vector&amp;lt;String&amp;gt; dayNames = new Vector&amp;lt;String&amp;gt;();
      dayNames.add(&amp;quot;Sunday&amp;quot;);
      dayNames.add(&amp;quot;Monday&amp;quot;);
      dayNames.add(&amp;quot;Tuesday&amp;quot;);
      dayNames.add(&amp;quot;Wednesday&amp;quot;);
      dayNames.add(&amp;quot;Thursday&amp;quot;);
      dayNames.add(&amp;quot;Friday&amp;quot;);
      dayNames.add(&amp;quot;Saturday&amp;quot;);
      days = dayNames.elements();
      while (days.hasMoreElements()){
         System.out.println(days.nextElement()); 
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;位集合bitset&#34;&gt;位集合(BitSet)&lt;/h2&gt;
&lt;p&gt;该集合类实现了一组可以反赌设置和清除的位或是标志&lt;/p&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bitset(): 创建一个默认对象&lt;/li&gt;
&lt;li&gt;BitSet(int size): 指定初始大小，所有位初始为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BitSet中实现了Cloneable接口中定义的方法如下表所列：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/Opdi1H87kYStvF5.png&#34; alt=&#34;bitset方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.BitSet;
 
public class BitSetDemo {
 
  public static void main(String args[]) {
     BitSet bits1 = new BitSet(16);
     BitSet bits2 = new BitSet(16);
      
     // set some bits
     for(int i=0; i&amp;lt;16; i++) {
        if((i%2) == 0) bits1.set(i);
        if((i%5) != 0) bits2.set(i);
     }
     System.out.println(&amp;quot;Initial pattern in bits1: &amp;quot;);
     System.out.println(bits1);
     System.out.println(&amp;quot;\nInitial pattern in bits2: &amp;quot;);
     System.out.println(bits2);
 
     // AND bits
     bits2.and(bits1);
     System.out.println(&amp;quot;\nbits2 AND bits1: &amp;quot;);
     System.out.println(bits2);
 
     // OR bits
     bits2.or(bits1);
     System.out.println(&amp;quot;\nbits2 OR bits1: &amp;quot;);
     System.out.println(bits2);
 
     // XOR bits
     bits2.xor(bits1);
     System.out.println(&amp;quot;\nbits2 XOR bits1: &amp;quot;);
     System.out.println(bits2);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;向量vector&#34;&gt;向量(Vector)&lt;/h2&gt;
&lt;p&gt;向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化&lt;/p&gt;
&lt;p&gt;Vector类实现了动态数组&lt;/p&gt;
&lt;p&gt;和ArrayList的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vector 是同步访问的&lt;/li&gt;
&lt;li&gt;Vector 包含了许多传统的方法，这些方法不属于集合框架&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vector(): 创建默认向量，大小为10&lt;/li&gt;
&lt;li&gt;Vector(int size): 创建指定大小的向量&lt;/li&gt;
&lt;li&gt;Vector(int size, int incr): 创建指定大小和增量的向量&lt;/li&gt;
&lt;li&gt;Vector(Collection c): 创建一个包含集合c元素的向量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vector定义的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/Ix78Va9vgHWzupO.png&#34; alt=&#34;vector方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

public class VectorDemo {

    public static void main(String args[]) {
        // initial size is 3, increment is 2
        Vector v = new Vector(3, 2);
        System.out.println(&amp;quot;Initial size: &amp;quot; + v.size());
        System.out.println(&amp;quot;Initial capacity: &amp;quot; + v.capacity());
        v.addElement(new Integer(1));
        v.addElement(new Integer(2));
        v.addElement(new Integer(3));
        v.addElement(new Integer(4));
        System.out.println(&amp;quot;Capacity after four additions: &amp;quot; + v.capacity());

        v.addElement(new Double(5.45));
        System.out.println(&amp;quot;Current capacity: &amp;quot; + v.capacity());
        v.addElement(new Double(6.08));
        v.addElement(new Integer(7));
        System.out.println(&amp;quot;Current capacity: &amp;quot; + v.capacity());
        v.addElement(new Float(9.4));
        v.addElement(new Integer(10));
        System.out.println(&amp;quot;Current capacity: &amp;quot; + v.capacity());
        v.addElement(new Integer(11));
        v.addElement(new Integer(12));
        System.out.println(&amp;quot;First element: &amp;quot; + (Integer)v.firstElement());
        System.out.println(&amp;quot;Last element: &amp;quot; + (Integer)v.lastElement());
        if(v.contains(new Integer(3)))
            System.out.println(&amp;quot;Vector contains 3.&amp;quot;);
        // enumerate the elements in the vector.
        Enumeration vEnum = v.elements();
        System.out.println(&amp;quot;\nElements in vector:&amp;quot;);
        while(vEnum.hasMoreElements())
            System.out.print(vEnum.nextElement() + &amp;quot; &amp;quot;);
        System.out.println();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;栈stack&#34;&gt;栈(Stack)&lt;/h2&gt;
&lt;p&gt;Stack是Vector的一个子类，实现一个标准的后进先出的栈&lt;/p&gt;
&lt;p&gt;栈只定义了默认构造方法&lt;code&gt;Stack()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;栈继承了Vector的所有方法，也自定义了一些方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/hDHF4MXg6wuzA9T.png&#34; alt=&#34;Stack方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
 
public class StackDemo {
 
    static void showpush(Stack&amp;lt;Integer&amp;gt; st, int a) {
        st.push(new Integer(a));
        System.out.println(&amp;quot;push(&amp;quot; + a + &amp;quot;)&amp;quot;);
        System.out.println(&amp;quot;stack: &amp;quot; + st);
    }
 
    static void showpop(Stack&amp;lt;Integer&amp;gt; st) {
        System.out.print(&amp;quot;pop -&amp;gt; &amp;quot;);
        Integer a = (Integer) st.pop();
        System.out.println(a);
        System.out.println(&amp;quot;stack: &amp;quot; + st);
    }
 
    public static void main(String args[]) {
        Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;Integer&amp;gt;();
        System.out.println(&amp;quot;stack: &amp;quot; + st);
        showpush(st, 42);
        showpush(st, 66);
        showpush(st, 99);
        showpop(st);
        showpop(st);
        showpop(st);
        try {
            showpop(st);
        } catch (EmptyStackException e) {
            System.out.println(&amp;quot;empty stack&amp;quot;);
        }
    }
}


// stack: [ ]
// push(42)
// stack: [42]
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;字典dictionary&#34;&gt;字典(Dictionary)&lt;/h2&gt;
&lt;p&gt;Dictionary类是一个抽象类，用来存储键值对，作用和实现Map接口相似&lt;/p&gt;
&lt;p&gt;字典已经被实现Map接口取代&lt;/p&gt;
&lt;p&gt;Dictionary类定义的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/FUGb2d5tAr6OIQo.png&#34; alt=&#34;dictionary方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;map接口&#34;&gt;Map接口&lt;/h3&gt;
&lt;p&gt;抛出异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值&lt;/li&gt;
&lt;li&gt;当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常&lt;/li&gt;
&lt;li&gt;当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常&lt;/li&gt;
&lt;li&gt;当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常&lt;/li&gt;
&lt;li&gt;当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Map定义的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/sHt8IeSNJ7AuTGa.png&#34; alt=&#34;Map方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

public class CollectionsDemo {

    public static void main(String[] args) {
        Map m1 = new HashMap(); 
        m1.put(&amp;quot;Zara&amp;quot;, &amp;quot;8&amp;quot;);
        m1.put(&amp;quot;Mahnaz&amp;quot;, &amp;quot;31&amp;quot;);
        m1.put(&amp;quot;Ayan&amp;quot;, &amp;quot;12&amp;quot;);
        m1.put(&amp;quot;Daisy&amp;quot;, &amp;quot;14&amp;quot;);
        System.out.println();
        System.out.println(&amp;quot; Map Elements&amp;quot;);
        System.out.print(&amp;quot;\t&amp;quot; + m1);
    }
}


// Map Elements
//         {Mahnaz=31, Ayan=12, Daisy=14, Zara=8}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;哈希表hashtable&#34;&gt;哈希表(Hashtable)&lt;/h2&gt;
&lt;p&gt;Hashtable现在集成到了集合框架中，和HashMap类很相似，但支持同步&lt;/p&gt;
&lt;p&gt;Hashtable在哈希表中存储键值对&lt;/p&gt;
&lt;p&gt;当使用一个哈希表时，要指定用作键的对象，以及链接到该键的值&lt;/p&gt;
&lt;p&gt;该键经过哈希处理，所得的散列码被用作存储在该表中值的索引&lt;/p&gt;
&lt;p&gt;Hashtable类定义的构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hashtable()&lt;/li&gt;
&lt;li&gt;Hashtable(int size): 创建指定大小的哈希表&lt;/li&gt;
&lt;li&gt;Hashtable(int size, float fillRation): 创建指定大小和填充比例的哈希表&lt;/li&gt;
&lt;li&gt;Hashtable(Map m): 创建一个以M重元素未初始化元素的哈希表，其容量被设置为M的两倍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hashtable除了Map接口中定义的方法，还有自定义了：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/ol1hWptzTmU3d58.png&#34; alt=&#34;hashtable方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

public class HashTableDemo {

   public static void main(String args[]) {
      // Create a hash map
      Hashtable balance = new Hashtable();
      Enumeration names;
      String str;
      double bal;

      balance.put(&amp;quot;Zara&amp;quot;, new Double(3434.34));
      balance.put(&amp;quot;Mahnaz&amp;quot;, new Double(123.22));
      balance.put(&amp;quot;Ayan&amp;quot;, new Double(1378.00));
      balance.put(&amp;quot;Daisy&amp;quot;, new Double(99.22));
      balance.put(&amp;quot;Qadir&amp;quot;, new Double(-19.08));

      // Show all balances in hash table.
      names = balance.keys();
      while(names.hasMoreElements()) {
         str = (String) names.nextElement();
         System.out.println(str + &amp;quot;: &amp;quot; +
         balance.get(str));
      }
      System.out.println();
      // Deposit 1,000 into Zara&#39;s account
      bal = ((Double)balance.get(&amp;quot;Zara&amp;quot;)).doubleValue();
      balance.put(&amp;quot;Zara&amp;quot;, new Double(bal+1000));
      System.out.println(&amp;quot;Zara&#39;s new balance: &amp;quot; +
      balance.get(&amp;quot;Zara&amp;quot;));
   }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;属性properties&#34;&gt;属性(Properties)&lt;/h2&gt;
&lt;p&gt;Properties 继承于 Hashtable, Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串&lt;/p&gt;
&lt;p&gt;Properties 定义如下实例变量.这个变量持有一个 Properties 对象相关的默认属性列表：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Properties defaults;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Properties()&lt;/li&gt;
&lt;li&gt;Properties(Properties propDefault)   // 两种情况下 ，属性列表都为空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Properties类除了继承Hashtable中的方法，自定义了：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/hXfoCp9qtLHmejz.png&#34; alt=&#34;properties方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
 
public class PropDemo {
 
    public static void main(String args[]) {
        Properties capitals = new Properties();
        Set states;
        String str;
        
        capitals.put(&amp;quot;Illinois&amp;quot;, &amp;quot;Springfield&amp;quot;);
        capitals.put(&amp;quot;Missouri&amp;quot;, &amp;quot;Jefferson City&amp;quot;);
        capitals.put(&amp;quot;Washington&amp;quot;, &amp;quot;Olympia&amp;quot;);
        capitals.put(&amp;quot;California&amp;quot;, &amp;quot;Sacramento&amp;quot;);
        capitals.put(&amp;quot;Indiana&amp;quot;, &amp;quot;Indianapolis&amp;quot;);
    
        // Show all states and capitals in hashtable.
        states = capitals.keySet(); // get set-view of keys
        Iterator itr = states.iterator();
        while(itr.hasNext()) {
            str = (String) itr.next();
            System.out.println(&amp;quot;The capital of &amp;quot; + str + &amp;quot; is &amp;quot; + capitals.getProperty(str) + &amp;quot;.&amp;quot;);
        }
        System.out.println();
    
        // look for state not in list -- specify default
        str = capitals.getProperty(&amp;quot;Florida&amp;quot;, &amp;quot;Not Found&amp;quot;);
        System.out.println(&amp;quot;The capital of Florida is &amp;quot; + str + &amp;quot;.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;以上这些类是传统遗留的，后面引入新的框架--集合框架(Collection)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;集合框架&#34;&gt;集合框架&lt;/h2&gt;
&lt;p&gt;上述的类缺少一个核心的、统一的主题，不同类的使用方法有着很大的不同&lt;/p&gt;
&lt;p&gt;集合框架的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的&lt;/li&gt;
&lt;li&gt;该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性&lt;/li&gt;
&lt;li&gt;对一个集合的扩展和适应必须是简单的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，集合框架就围绕一组标准接口而设计&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/7WgzAt2Px9dpDJB.png&#34; alt=&#34;集合框架图.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Java集合框架主要包括两种类型容器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合(Collection)：存储一个元素&lt;/li&gt;
&lt;li&gt;图(Map)：存储键值对映射&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集合框架都包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集合框架接口&#34;&gt;集合框架接口：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/LFs54yEOK3WJMlp.png&#34; alt=&#34;集合框架接口.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;集合实现类集合类&#34;&gt;集合实现类（集合类）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/of3lVvQ2G6bXen8.png&#34; alt=&#34;集合实现类.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;迭代器iterator&#34;&gt;迭代器(Iterator)&lt;/h3&gt;
&lt;p&gt;迭代器是一种访问集合的方法&lt;/p&gt;
&lt;p&gt;Iterator是迭代器最简单的实现，ListIterator是Collection API中的接口，拓展了Iterator接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import java.util.Iterator; // 引入 Iterator 类&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态&lt;/li&gt;
&lt;li&gt;it.hasNext() 用于检测集合中是否还有元素&lt;/li&gt;
&lt;li&gt;it.remove() 将迭代器返回的元素删除&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;获取迭代器&#34;&gt;获取迭代器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;iterator()&lt;/code&gt;方法&lt;/p&gt;
&lt;h4 id=&#34;循环集合元素&#34;&gt;循环集合元素&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while(it.hasNext()) {
    System.out.println(it.next());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除集合元素&#34;&gt;删除集合元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;remove()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.ArrayList;
import java.util.Iterator;

public class RunoobTest {
    public static void main(String[] args) {
        ArrayList&amp;lt;Integer&amp;gt; numbers = new ArrayList&amp;lt;Integer&amp;gt;();
        numbers.add(12);
        numbers.add(8);
        numbers.add(2);
        numbers.add(23);
        Iterator&amp;lt;Integer&amp;gt; it = numbers.iterator();
        while(it.hasNext()) {
            Integer i = it.next();
            if(i &amp;lt; 10) {  
                it.remove();  // 删除小于 10 的元素
            }
        }
        System.out.println(numbers);
    }
}

// [12, 23]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;遍历arraylist&#34;&gt;遍历ArrayList&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
 
public class Test{
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;String&amp;gt;();
        list.add(&amp;quot;Hello&amp;quot;);
        list.add(&amp;quot;World&amp;quot;);
        list.add(&amp;quot;HAHAHAHA&amp;quot;);
        //第一种遍历方法使用 For-Each 遍历 List
        for (String str : list) {            //也可以改写 for(int i=0;i&amp;lt;list.size();i++) 这种形式
            System.out.println(str);
        }
    
        //第二种遍历，把链表变为数组相关的内容进行遍历
        String[] strArray=new String[list.size()];
        list.toArray(strArray);
        for(int i=0;i&amp;lt;strArray.length;i++) //这里也可以改写为  for(String str:strArray) 这种形式
        {
            System.out.println(strArray[i]);
        }
        
        //第三种遍历 使用迭代器进行相关遍历
        
        Iterator&amp;lt;String&amp;gt; ite=list.iterator();
        while(ite.hasNext())//判断下一个元素之后有值
        {
            System.out.println(ite.next());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;遍历map&#34;&gt;遍历Map&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
 
public class Test{
    public static void main(String[] args) {
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
        map.put(&amp;quot;1&amp;quot;, &amp;quot;value1&amp;quot;);
        map.put(&amp;quot;2&amp;quot;, &amp;quot;value2&amp;quot;);
        map.put(&amp;quot;3&amp;quot;, &amp;quot;value3&amp;quot;);
        
        //第一种：普遍使用，二次取值
        System.out.println(&amp;quot;通过Map.keySet遍历key和value：&amp;quot;);
        for (String key : map.keySet()) {
        System.out.println(&amp;quot;key= &amp;quot;+ key + &amp;quot; and value= &amp;quot; + map.get(key));
        }
        
        //第二种
        System.out.println(&amp;quot;通过Map.entrySet使用iterator遍历key和value：&amp;quot;);
        Iterator&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; it = map.entrySet().iterator();
        while (it.hasNext()) {
        Map.Entry&amp;lt;String, String&amp;gt; entry = it.next();
        System.out.println(&amp;quot;key= &amp;quot; + entry.getKey() + &amp;quot; and value= &amp;quot; + entry.getValue());
        }
        
        //第三种：推荐，尤其是容量大时
        System.out.println(&amp;quot;通过Map.entrySet遍历key和value&amp;quot;);
        for (Map.Entry&amp;lt;String, String&amp;gt; entry : map.entrySet()) {
        System.out.println(&amp;quot;key= &amp;quot; + entry.getKey() + &amp;quot; and value= &amp;quot; + entry.getValue());
        }
        
        //第四种
        System.out.println(&amp;quot;通过Map.values()遍历所有的value，但不能遍历key&amp;quot;);
        for (String v : map.values()) {
        System.out.println(&amp;quot;value= &amp;quot; + v);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;比较器&#34;&gt;比较器&lt;/h3&gt;
&lt;p&gt;Comparator接口定义了两个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;compare()&lt;/li&gt;
&lt;li&gt;equals()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;int compare(Object obj1, Object obj2)&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;arraylist-类&#34;&gt;ArrayList 类&lt;/h2&gt;
&lt;p&gt;ArrayList类是一个可以动态修改的数组&lt;/p&gt;
&lt;p&gt;继承了AbstractList，并实现了List接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt; objectName =new ArrayList&amp;lt;&amp;gt;();　 // 初始化&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ArrayList常用方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/6QiPYmqj2pxoAeG.png&#34; alt=&#34;ArrayList常用方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;linkedlist-类链表&#34;&gt;LinkedList 类（链表）&lt;/h2&gt;
&lt;p&gt;链表是一种线性表，在每个节点里存放下一节点的地址&lt;/p&gt;
&lt;p&gt;可分为&lt;code&gt;单链表&lt;/code&gt;和&lt;code&gt;双链表&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;单链表包含当前结点的值和指向后节点的链接两个值&lt;/p&gt;
&lt;p&gt;双链表多了向后结点的链接&lt;/p&gt;
&lt;p&gt;与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低&lt;/p&gt;
&lt;p&gt;ArrayList：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;频繁访问列表中的某一个元素&lt;/li&gt;
&lt;li&gt;只需要在列表末尾进行添加和删除元素操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LinkedList：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要通过循环迭代来访问列表中的某些元素&lt;/li&gt;
&lt;li&gt;需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LinkedList 继承了 AbstractSequentialList 类&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 Queue 接口，可作为队列使用&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 List 接口，可进行列表的相关操作&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 Deque 接口，可作为队列使用&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 Cloneable 接口，可实现克隆&lt;/p&gt;
&lt;p&gt;LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;LinkedList&amp;lt;E&amp;gt; list = new LinkedList&amp;lt;E&amp;gt;();   // 普通创建方法
或者
LinkedList&amp;lt;E&amp;gt; list = new LinkedList(Collection&amp;lt;? extends E&amp;gt; c); // 使用集合创建链表
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/TvVpFPnZl87XC1w.png&#34; alt=&#34;LinkedList常用方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;hashset&#34;&gt;HashSet&lt;/h2&gt;
&lt;p&gt;HashSet是一个不允许有重复元素的集合，允许有null值&lt;/p&gt;
&lt;p&gt;无序的&lt;/p&gt;
&lt;p&gt;非线程安全&lt;/p&gt;
&lt;p&gt;实现了Set接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashSet&amp;lt;String&amp;gt; sites = new HashSet&amp;lt;String&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/13/32voSbfi9wck5dR.png&#34; alt=&#34;HashSet方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;hashmap&#34;&gt;HashMap&lt;/h2&gt;
&lt;p&gt;HashMap是一个散列表，存储了键值对的映射&lt;/p&gt;
&lt;p&gt;实现了Map接口&lt;/p&gt;
&lt;p&gt;最多允许一条记录的键位null，不支持线程同步&lt;/p&gt;
&lt;p&gt;无序的&lt;/p&gt;
&lt;p&gt;继承了AbstractMap，实现了Map、Cloneable、java.io.Serializable接口&lt;/p&gt;
&lt;p&gt;HashMap的key与value的类型可以不同&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&amp;lt;Integer, String&amp;gt; Sites = new HashMap&amp;lt;Integer, String&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/14/QULCFrKElsuIfX8.png&#34; alt=&#34;HashMap方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
">数据结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/mian-xiang-dui-xiang/"" data-c="
          &lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;继承就是子类继承父类的特征和行为，使得子类对象（实例）具有弗雷德实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为&lt;/p&gt;
&lt;p&gt;继承格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class 父类 {
}
 
class 子类 extends 父类 {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;继承类型&#34;&gt;继承类型&lt;/h3&gt;
&lt;p&gt;Java不支持多继承，但支持多重继承&lt;/p&gt;
&lt;p&gt;1.单继承&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;多重继承&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt; &amp;lt;-- ...&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;不同类继承同一个类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;多继承（不支持）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class B&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;集成的特性&#34;&gt;集成的特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;子类拥有父类非 private 的属性、方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类可以拥有自己的属性和方法，即子类可以对父类进行扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类可以用自己的方式实现父类的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 的继承是单继承，但是可以多重继承&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;继承关键字&#34;&gt;继承关键字&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;extends&lt;/li&gt;
&lt;li&gt;implements&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;extends关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类的继承是单一继承，extends只能继承一个类&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;implements关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}
 
public class C implements A,B {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;super 和 this关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this关键字：指向自己的引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;final关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写&lt;/p&gt;
&lt;h3 id=&#34;构造器&#34;&gt;构造器&lt;/h3&gt;
&lt;p&gt;子类不继承父类的构造器，只是通过&lt;code&gt;super&lt;/code&gt;关键字调用&lt;/p&gt;
&lt;p&gt;如果父类构造器没有参数，系统自动调用父类的无参数构造器&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;重写override与重载overload&#34;&gt;重写（Override）与重载（Overload）&lt;/h2&gt;
&lt;p&gt;方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现&lt;/p&gt;
&lt;h3 id=&#34;override&#34;&gt;Override&lt;/h3&gt;
&lt;p&gt;重写是子类在不改变形参的前提下，重新编写父类方法的实现过程&lt;/p&gt;
&lt;p&gt;重写方法不能抛出新的异常或是申明更宽泛的异常&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Animal{
   public void move(){
      System.out.println(&amp;quot;动物可以移动&amp;quot;);
   }
}
 
class Dog extends Animal{
   public void move(){
      System.out.println(&amp;quot;狗可以跑和走&amp;quot;);
   }
}
 
public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象
 
      a.move();// 执行 Animal 类的方法
 
      b.move();//执行 Dog 类的方法
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法的重写规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数列表与被重写方法的参数列表必须完全相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父类的成员方法只能被它的子类重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明为 final 的方法不能被重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明为 static 的方法不能被重写，但是能够被再次声明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造方法不能被重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不能继承一个类，则不能重写该类的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;overload&#34;&gt;Overload&lt;/h3&gt;
&lt;p&gt;重载是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同&lt;/p&gt;
&lt;p&gt;重载规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被重载的方法必须改变参数列表(参数个数或类型不一样)&lt;/li&gt;
&lt;li&gt;被重载的方法可以改变返回类型&lt;/li&gt;
&lt;li&gt;被重载的方法可以改变访问修饰符&lt;/li&gt;
&lt;li&gt;被重载的方法可以声明新的或更广的检查异常&lt;/li&gt;
&lt;li&gt;方法能够在同一个类中或者在一个子类中被重载&lt;/li&gt;
&lt;li&gt;无法以返回值类型作为重载函数的区分标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Overloading {
    public int test(){
        System.out.println(&amp;quot;test1&amp;quot;);
        return 1;
    }
 
    public void test(int a){
        System.out.println(&amp;quot;test2&amp;quot;);
    }   
 
    //以下两个参数类型顺序不同
    public String test(int a,String s){
        System.out.println(s);
        return &amp;quot;return&amp;quot; + s;
    }   
 
    public String test(String s,int a){
        System.out.println(s);
        return &amp;quot;return&amp;quot; + s;
    }   
 
    public static void main(String[] args){
        Overloading o = new Overloading();
        System.out.println(o.test());
        o.test(1);
        System.out.println(o.test(1,&amp;quot;test3&amp;quot;));
        System.out.println(o.test(&amp;quot;test4&amp;quot;,1));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;override-和overload之间的区别&#34;&gt;Override 和Overload之间的区别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;区别点&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;重载&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;重写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;参数列表&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;必须修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;异常&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以减少或删除，不能增加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;访问&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以降低限制，不能更严格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;多态&#34;&gt;多态&lt;/h2&gt;
&lt;p&gt;多态是一个行为有多个不同表现形式或形态的能力&lt;/p&gt;
&lt;p&gt;多态就是同一个接口，使用不同的实例执行不同的操作&lt;/p&gt;
&lt;p&gt;多态的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除类型之间的耦合关系&lt;/li&gt;
&lt;li&gt;可替换性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;接口性&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;li&gt;简化性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多态存在的必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象：&lt;code&gt;Parent p = new Child();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        show(new Cat());  // 以 Cat 对象调用 show 方法
        show(new Dog());  // 以 Dog 对象调用 show 方法
                    
        Animal a = new Cat();  // 向上转型  
        a.eat();               // 调用的是 Cat 的 eat
        Cat c = (Cat)a;        // 向下转型  
        c.work();        // 调用的是 Cat 的 work
    }  
            
    public static void show(Animal a)  {
        a.eat();  
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情 
            Cat c = (Cat)a;  
            c.work();  
        } else if (a instanceof Dog) { // 狗做的事情 
            Dog c = (Dog)a;  
            c.work();  
        }  
    }  
}
 
abstract class Animal {  
    abstract void eat();  
}  
  
class Cat extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃鱼&amp;quot;);  
    }  
    public void work() {  
        System.out.println(&amp;quot;抓老鼠&amp;quot;);  
    }  
}  
  
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃骨头&amp;quot;);  
    }  
    public void work() {  
        System.out.println(&amp;quot;看家&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;虚函数&#34;&gt;虚函数&lt;/h3&gt;
&lt;p&gt;Java没有虚函数的概念，其普通函数默认就相当于C++的虚函数，加上final关键字可以声明该函数不具有虚函数特性&lt;/p&gt;
&lt;p&gt;虚拟方法调用：&lt;/p&gt;
&lt;p&gt;实例时，编译时使用父类的方法进行，运行时调用重写的方法&lt;/p&gt;
&lt;h3 id=&#34;多态的实现方式&#34;&gt;多态的实现方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;抽象类和抽象方法&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;抽象类&#34;&gt;抽象类&lt;/h2&gt;
&lt;p&gt;抽象类没有包含足够的信息来描绘一个对象&lt;/p&gt;
&lt;p&gt;所以不能实例化对象&lt;/p&gt;
&lt;p&gt;抽象类必须被继承，才能被使用&lt;/p&gt;
&lt;p&gt;抽象类是用来捕捉子类的通用特性的，是被用来创建继承层级里子类的模板。 现实中有些父类中的方法确实没有必要写，因为各个子类中的这个方法肯定会有不同；而写成抽象类，这样看代码时，就知道这是抽象方法，而知道这个方法是在子类中实现的，所以有提示作用&lt;/p&gt;
&lt;h3 id=&#34;抽象类-2&#34;&gt;抽象类&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;abstract class&lt;/code&gt;来定义抽象类&lt;/p&gt;
&lt;h3 id=&#34;继承抽象类&#34;&gt;继承抽象类&lt;/h3&gt;
&lt;h3 id=&#34;抽象方法&#34;&gt;抽象方法&lt;/h3&gt;
&lt;p&gt;抽象方法也用&lt;code&gt;abstract&lt;/code&gt;来声明&lt;/p&gt;
&lt;p&gt;抽象方法只包含一个方法名，而没有方法体，即方法的具体由子类确定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public abstract double computePay(); // 方法名后直接跟分号&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具有抽象方法的抽象类，其子类必须重写父类的抽象方法，或者也声明为抽象类&lt;/p&gt;
&lt;p&gt;构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;封装&#34;&gt;封装&lt;/h2&gt;
&lt;p&gt;封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法&lt;/p&gt;
&lt;p&gt;可理解为一个保护，防止该类的代码和数据被外部类定义的代码随机访问&lt;/p&gt;
&lt;p&gt;封装的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;良好的封装能够减少耦合&lt;/li&gt;
&lt;li&gt;类内部的结构可以自由修改&lt;/li&gt;
&lt;li&gt;可以对成员变量进行更精确的控制&lt;/li&gt;
&lt;li&gt;隐藏信息，实现细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现封装的步骤&#34;&gt;实现封装的步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改属性的可见性来限制对属性的访问（一般限制为private）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对每个值属性提供对外的公共方法访问，即创建一对赋取值方法，用于对私有属性的访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EncapTest{
 
    private String name;
    private String idNum;
    private int age;
    
    public int getAge(){
        return age;
    }
    
    public String getName(){
        return name;
    }
    
    public String getIdNum(){
        return idNum;
    }
    
    public void setAge( int newAge){
        age = newAge;
    }
    
    public void setName(String newName){
        name = newName;
    }
    
    public void setIdNum( String newId){
        idNum = newId;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RunEncap{
    public static void main(String args[]){
        EncapTest encap = new EncapTest();
        encap.setName(&amp;quot;James&amp;quot;);
        encap.setAge(20);
        encap.setIdNum(&amp;quot;12343ms&amp;quot;);

        System.out.print(&amp;quot;Name : &amp;quot; + encap.getName()+ &amp;quot; Age : &amp;quot;+ encap.getAge());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口interface&#34;&gt;接口（Interface）&lt;/h2&gt;
&lt;p&gt;接口是抽象方法的集合&lt;/p&gt;
&lt;p&gt;通常以&lt;code&gt;interface&lt;/code&gt;声明&lt;/p&gt;
&lt;p&gt;一个类通过继承接口的方式来继承接口的抽象方法&lt;/p&gt;
&lt;p&gt;类描述对象的属性和方法，接口包含类要实现的方法&lt;/p&gt;
&lt;p&gt;实现接口的类要定义接口中的所有方法，除非是抽象类&lt;/p&gt;
&lt;p&gt;接口不能实例化，但可以被实现&lt;/p&gt;
&lt;p&gt;接口与类相似点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个接口可以有多个方法&lt;/li&gt;
&lt;li&gt;接口文件保存在 .java 结尾的文件中，文件名使用接口名&lt;/li&gt;
&lt;li&gt;接口的字节码文件保存在 .class 结尾的文件中&lt;/li&gt;
&lt;li&gt;接口相应的字节码文件必须在与包名称相匹配的目录结构中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口与类的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口不能用于实例化对象。&lt;/li&gt;
&lt;li&gt;接口没有构造方法。&lt;/li&gt;
&lt;li&gt;接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。&lt;/li&gt;
&lt;li&gt;接口不能包含成员变量，除了 static 和 final 变量。&lt;/li&gt;
&lt;li&gt;接口不是被类继承了，而是要被类实现。&lt;/li&gt;
&lt;li&gt;接口支持多继承&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽象类和接口的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 &lt;code&gt;public static final&lt;/code&gt; 类型的&lt;/li&gt;
&lt;li&gt;一个类只能继承一个抽象类，可以实现多个接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;接口的声明&#34;&gt;接口的声明&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;[可见度] interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Animal {
   public void eat();
   public void travel();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的实现&#34;&gt;接口的实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MammalInt implements Animal{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的继承&#34;&gt;接口的继承&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 文件名: Sports.java
public interface Sports
{
   public void setHomeTeam(String name);
   public void setVisitingTeam(String name);
}
 
// 文件名: Football.java
public interface Football extends Sports
{
   public void homeTeamScored(int points);
   public void visitingTeamScored(int points);
   public void endOfQuarter(int quarter);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的多继承&#34;&gt;接口的多继承&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public interface Hockey extends Sports, Event&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;标记接口&#34;&gt;标记接口&lt;/h3&gt;
&lt;p&gt;没有任何方法的接口被称为标记接口&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立一个公共的父接口&lt;/li&gt;
&lt;li&gt;向一个类添加数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;枚举enum&#34;&gt;枚举（enum）&lt;/h2&gt;
&lt;p&gt;枚举是一个特殊的类，一般表示一组常量&lt;/p&gt;
&lt;p&gt;所有的枚举值都是 public static final&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
 
public class Test
{
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}


//RED
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部类中使用枚举&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test
{
    enum Color
    {
        RED, GREEN, BLUE;
    }
 
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;迭代枚举元素&#34;&gt;迭代枚举元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
public class MyClass {
  public static void main(String[] args) {
    for (Color myVar : Color.values()) {
      System.out.println(myVar);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;values-ordinal-valueof方法&#34;&gt;values(), ordinal(), valueOf()方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;values() 返回枚举类中所有的值&lt;/li&gt;
&lt;li&gt;ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样&lt;/li&gt;
&lt;li&gt;valueOf()方法返回指定字符串值的枚举常量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
 
public class Test
{
    public static void main(String[] args)
    {
        // 调用 values()
        Color[] arr = Color.values();
 
        // 迭代枚举
        for (Color col : arr)
        {
            // 查看索引
            System.out.println(col + &amp;quot; at index &amp;quot; + col.ordinal());
        }
 
        // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException
        System.out.println(Color.valueOf(&amp;quot;RED&amp;quot;));
        // System.out.println(Color.valueOf(&amp;quot;WHITE&amp;quot;));
    }
}


// RED at index 0
// GREEN at index 1
// BLUE at index 2
// RED
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;枚举类成员&#34;&gt;枚举类成员&lt;/h3&gt;
&lt;p&gt;枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符&lt;/p&gt;
&lt;p&gt;枚举既可以包含具体方法，也可以包含抽象方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
 
    // 构造函数
    private Color()
    {
        System.out.println(&amp;quot;Constructor called for : &amp;quot; + this.toString());
    }
 
    public void colorInfo()
    {
        System.out.println(&amp;quot;Universal Color&amp;quot;);
    }
}
 
public class Test
{    
    // 输出
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
        c1.colorInfo();
    }
}


// Constructor called for : RED
// Constructor called for : GREEN
// Constructor called for : BLUE
// RED
// Universal Color
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;包package&#34;&gt;包（package）&lt;/h2&gt;
&lt;p&gt;包的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把功能相似的类或接口组织在一个包中，方便查找和使用&lt;/li&gt;
&lt;li&gt;避免名字冲突&lt;/li&gt;
&lt;li&gt;包也限定了访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.lang-打包基础的类&lt;/li&gt;
&lt;li&gt;java.io-包含输入输出功能的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;创建包&#34;&gt;创建包&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;package pkg1[．pkg2[．pkg3…]];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;包的声明放在这个源文件的开头&lt;/p&gt;
&lt;h3 id=&#34;import关键字&#34;&gt;import关键字&lt;/h3&gt;
&lt;p&gt;import语句导入包&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import package1[.package2…].(classname|*);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;任意数量import 声明必须在包声明之后，类声明之前&lt;/p&gt;
&lt;h3 id=&#34;package的目录结构&#34;&gt;package的目录结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;包名成为类名的一部分，正如我们前面讨论的一样。&lt;/li&gt;
&lt;li&gt;包名必须与相应的字节码所在的目录结构相吻合&lt;/li&gt;
&lt;/ul&gt;
">面向对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/ji-chu-yu-fa/"" data-c="
          &lt;h2 id=&#34;java基础语法&#34;&gt;Java基础语法&lt;/h2&gt;
&lt;p&gt;Java语言是面向对象的&lt;/p&gt;
&lt;p&gt;先介绍下类、对象、方法和实例变量的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象：是类的一个实例，有状态有行为。eg：对象（一条狗），状态（名字、品种、颜色等），行为（叫、吃、摇尾巴等）&lt;/li&gt;
&lt;li&gt;类：类是一个模板，描述一类对象的行为和状态&lt;/li&gt;
&lt;li&gt;方法：方法就是行为，一个类可以有很多方法&lt;/li&gt;
&lt;li&gt;实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;包名：多单词都小写&lt;/p&gt;
&lt;p&gt;类名、接口名：所有单词首字母大写&lt;/p&gt;
&lt;p&gt;变量名、方法名：第一个单词首字母小写，后面大写&lt;/p&gt;
&lt;p&gt;常量名：所有字母都大写，多单词用下划线连接(eg:XXX_YYY_ZZZ)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;源文件名必须与类名相同&lt;/li&gt;
&lt;li&gt;一个源文件只能有一个public类，可以有若干个非public类&lt;/li&gt;
&lt;li&gt;主方法入口：&lt;code&gt;public static void main(String[] args)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;public static void main(String[] args)&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;public：访问修饰符&lt;br&gt;
static：关键字&lt;br&gt;
void：返回类型&lt;br&gt;
main：方法名&lt;br&gt;
String：String类&lt;br&gt;
args：字符串数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;标识符&#34;&gt;标识符&lt;/h3&gt;
&lt;p&gt;Java所有的组成部分都需要名字。&lt;/p&gt;
&lt;p&gt;标识符：类名、变量名、方法名&lt;/p&gt;
&lt;p&gt;标识符规范：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首字符：字母、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;其&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;他&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;符&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;母&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;、_
其他字符：字母、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.15em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:-0.15em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord cjk_fallback mtight&#34;&gt;其&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;他&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;符&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;母&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、_、数字&lt;br&gt;
大小写敏感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;修饰符&#34;&gt;修饰符&lt;/h3&gt;
&lt;p&gt;Java用修饰符来修饰类中的方法和属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问控制修饰符：default、public、protected、private&lt;/li&gt;
&lt;li&gt;非访问控制修饰符：final、abstract、static、synchronized&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java变量&#34;&gt;Java变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;li&gt;类变量（静态变量）&lt;/li&gt;
&lt;li&gt;成员变量（非静态变量）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java关键字&#34;&gt;Java关键字&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/08/Pnm1sC7QRDZG4z6.png&#34; alt=&#34;Java关键字.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-对象和类&#34;&gt;Java 对象和类&lt;/h2&gt;
&lt;p&gt;Java面向对象支持以下基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;li&gt;抽象&lt;/li&gt;
&lt;li&gt;类&lt;/li&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;li&gt;实例&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：改变对象的内部状态，对象的相互调用&lt;/p&gt;
&lt;p&gt;类中的变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部变量：在方法中定义的变量，随方法的结束而销毁&lt;/li&gt;
&lt;li&gt;成员变量：定义在类中、方法之外的变量，在创建对象时实例化，在类中可被访问&lt;/li&gt;
&lt;li&gt;类变量：声明在类中、方法块之外、必须声明为static类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造方法&#34;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;每个类都有一个或多个构造方法&lt;/p&gt;
&lt;p&gt;创建对象时，至少调用一个构造方法&lt;/p&gt;
&lt;p&gt;构造方法的名称必须与类同名&lt;/p&gt;
&lt;h3 id=&#34;创建对象&#34;&gt;创建对象&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;声明：对象的名称和类型&lt;/li&gt;
&lt;li&gt;实例化：使用关键字&lt;code&gt;new&lt;/code&gt;来创建一个对象&lt;/li&gt;
&lt;li&gt;初始化：使用&lt;code&gt;new&lt;/code&gt;创建对象时，会调用构造方法初始化对象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Puppy{

    // 该构造方法仅有一个参数：name
    public Puppy(String name){
        System.out.println(&amp;quot;The dog&#39;s name is : &amp;quot; + name);
    }

    public static void main(String[] args){
        Puppy myPuppy = new Puppy(&amp;quot;Tommy&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;访问实例变量和方法&#34;&gt;访问实例变量和方法&lt;/h3&gt;
&lt;p&gt;通过已创建的对象来访问成员变量和成员方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* 实例化对象 */
Object referenceVariable = new Constructor();
/* 访问类中的变量 */
referenceVariable.variableName;
/* 访问类中的方法 */
referenceVariable.methodName();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Puppy{
    int puppyAge;
    public Puppy(String name){
        System.out.println(&amp;quot;The dog&#39;s name is : &amp;quot; + name)；
    }

    public void setAge(int age){
        puppyAge = age;
    }

    public int getAge(){
        return puppyAge;
    }

    public static void main(String[] args){
        Puppy myPuppy = new Puppy(Tommy);

        myPuppy.setAge(2)
        System.out.println(&amp;quot;myPuppy&#39;s age is : &amp;quot; + myPuppy.getAge());
        System.out.println(&amp;quot;变量值：&amp;quot; + myPuppy.puppyAge);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java包&#34;&gt;Java包&lt;/h3&gt;
&lt;p&gt;包主要用来对类和接口进行分类&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java基本数据类型&#34;&gt;Java基本数据类型&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;内置数据类型&lt;/li&gt;
&lt;li&gt;引用数据类型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内置数据类型&#34;&gt;内置数据类型&lt;/h3&gt;
&lt;p&gt;8种基本类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;byte：8位,默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;short：16位，默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;int：32位，默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;long：64位，默认值&lt;code&gt;0L&lt;/code&gt;(L不区分大小写，最好大写区分1)&lt;/li&gt;
&lt;li&gt;float：单精度，32位，默认值&lt;code&gt;0.0f&lt;/code&gt;(不能表示精确的值)&lt;/li&gt;
&lt;li&gt;double：双精度，64位，默认值&lt;code&gt;0.0d&lt;/code&gt;(不能表示精确值)&lt;/li&gt;
&lt;li&gt;boolean：标志记录true/false，默认&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;char：单一的16位Unicode字符，&lt;code&gt;\u0000&lt;/code&gt;~&lt;code&gt;\uffff&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;引用数据类型&#34;&gt;引用数据类型&lt;/h3&gt;
&lt;p&gt;对象、数组都是引用数据类型&lt;/p&gt;
&lt;p&gt;默认值&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个引用变量可以用来引用任何与之兼容的类型&lt;/p&gt;
&lt;h3 id=&#34;java常量&#34;&gt;Java常量&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;final&lt;/code&gt;关键字来修饰常量&lt;/p&gt;
&lt;p&gt;eg：`final double PI = 3.14159265;&lt;/p&gt;
&lt;p&gt;常量名通常大写&lt;/p&gt;
&lt;p&gt;字符串常量：双引号之间的字符序列&lt;/p&gt;
&lt;p&gt;转义字符：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/08/Go2nVrQZF8Rpa9K.png&#34; alt=&#34;转义字符.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;自动类型转换&#34;&gt;自动类型转换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;low --------------------------------------&amp;gt; high
byte,short,char -&amp;gt; int -&amp;gt; long -&amp;gt; float -&amp;gt; double
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;boolean不能转换&lt;/li&gt;
&lt;li&gt;容量大的必须用强制转换才可以转换为容量小的&lt;/li&gt;
&lt;li&gt;浮点数舍弃小数转换得到整形&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java变量类型&#34;&gt;Java变量类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类变量&lt;/li&gt;
&lt;li&gt;实例变量&lt;/li&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Variable{
    static int allClicks=0;    // 类变量
 
    String str=&amp;quot;hello world&amp;quot;;  // 实例变量
 
    public void method(){
 
        int i =0;  // 局部变量
 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java局部变量&#34;&gt;java局部变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;局部变量声明在方法中&lt;/li&gt;
&lt;li&gt;不能用访问修饰符&lt;/li&gt;
&lt;li&gt;没有默认值，必须先初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java实例变量&#34;&gt;Java实例变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实例变量声明在一个类中，在方法、构造方法和语句块之外&lt;/li&gt;
&lt;li&gt;当一个对象被实例化之后，每个实例变量的值就跟着确定，对象被销毁的时候销毁&lt;/li&gt;
&lt;li&gt;实例变量的值应该至少被一个方法，使得外部能够通过这些方式获取实例变量信息&lt;/li&gt;
&lt;li&gt;可以声明在使用前或者使用后&lt;/li&gt;
&lt;li&gt;可用访问修饰符&lt;/li&gt;
&lt;li&gt;实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见&lt;/li&gt;
&lt;li&gt;有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定&lt;/li&gt;
&lt;li&gt;可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类变量静态变量&#34;&gt;类变量（静态变量）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在类中以 static 关键字声明，但必须在方法之外&lt;/li&gt;
&lt;li&gt;类只拥有类变量的一份拷贝&lt;/li&gt;
&lt;li&gt;静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。&lt;/li&gt;
&lt;li&gt;类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java修饰符&#34;&gt;java修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;访问修饰符&lt;/li&gt;
&lt;li&gt;非访问修饰符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修饰符用来定义类、方法或者变量，通常放在语句的最前端&lt;/p&gt;
&lt;h3 id=&#34;访问控制修饰符&#34;&gt;访问控制修饰符&lt;/h3&gt;
&lt;p&gt;用来保护对类、对象、方法的访问&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;default（默认，不写）：同一包内可见，不适用任何修饰符&lt;/li&gt;
&lt;li&gt;private：同一类内可见，不能修饰类（外部类）&lt;/li&gt;
&lt;li&gt;public：对所有类可见&lt;/li&gt;
&lt;li&gt;protected：对同一包内的类和子类可见，不能修饰类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口里的变量都隐式声明为&lt;code&gt;public static final&lt;/code&gt;，而接口里的方法默认为&lt;code&gt;public&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;私有访问修饰符--private&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Logger {
    private String format;
    public String getFormat() {
        return this.format;
    }
    public void setFormat(String format) {
        this.format = format;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;公有访问修饰符--public&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明为 public 的类、方法、构造方法和接口能够被任何其他类访问&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;受保护的访问修饰符--protected&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;子类与父类在同一包中：能被同一个包中的任何其他类访问&lt;/li&gt;
&lt;li&gt;子类与父类不在同一包中：在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;方法继承规则：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;父类-public，子类public&lt;/li&gt;
&lt;li&gt;父类-protected，子类public、protected&lt;/li&gt;
&lt;li&gt;父类-private，子类不能继承&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非访问修饰符&#34;&gt;非访问修饰符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;static：用来修饰类方法和类变量&lt;/li&gt;
&lt;li&gt;final：修饰类、方法、变量，修饰的类不能被继承，方法不能被重新定义，变量为常量，不可修改&lt;/li&gt;
&lt;li&gt;abstract：用来修饰抽象类和抽象方法&lt;/li&gt;
&lt;li&gt;synchronized和volatile：主要用于线程的编程&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;static修饰符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态变量：用来声明静态变量，只有一份拷贝&lt;/li&gt;
&lt;li&gt;静态方法：静态方法不能使用类的非静态变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final修饰符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;final变量：赋值后为常量&lt;/li&gt;
&lt;li&gt;final方法：可以被继承，但不能被子类重写&lt;/li&gt;
&lt;li&gt;final类：不能被继承&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;abstract修饰符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized修饰符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明的方法同一时间只能被一个线程访问&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;transient修饰符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java 虚拟机(JVM)跳过被 transient 修饰的实例变量&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;volatile修饰符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值,成员变量发生变化时，会强制线程将变化值回写到共享内存&lt;/p&gt;
&lt;p&gt;任何时刻，两个不同的线程总是看到某个成员变量的同一个值&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-运算符&#34;&gt;java 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;其他运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;/&lt;/code&gt;,&lt;code&gt;%&lt;/code&gt;,&lt;code&gt;++&lt;/code&gt;,&lt;code&gt;--&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算&lt;/li&gt;
&lt;li&gt;后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt;,&lt;code&gt;!=&lt;/code&gt;,&lt;code&gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;=&lt;/code&gt;,&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;,&lt;code&gt;|&lt;/code&gt;,&lt;code&gt;^&lt;/code&gt;,&lt;code&gt;~&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/09/SmKYWLxFpNgVylT.png&#34; alt=&#34;位运算符.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt;,&lt;code&gt;+=&lt;/code&gt;,&lt;code&gt;-=&lt;/code&gt;,&lt;code&gt;*=&lt;/code&gt;,&lt;code&gt;/=&lt;/code&gt;,&lt;code&gt;(%)=&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;,&lt;code&gt;&amp;amp;=&lt;/code&gt;,&lt;code&gt;^=&lt;/code&gt;,&lt;code&gt;|=&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;条件运算符（三元运算符）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;variable x = (expression) ? value if true : value if false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;code&gt;b = (a == 1) ? 20 : 30;&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;instanceof运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;( Object reference variable ) instanceof (class/interface type)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String name = &amp;quot;James&amp;quot;;
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/09/BfPx341d8E9zSwG.png&#34; alt=&#34;运算符优先级.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;java循环结构&#34;&gt;Java循环结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;while循环&lt;/li&gt;
&lt;li&gt;do...while循环&lt;/li&gt;
&lt;li&gt;for循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java增强for循环&#34;&gt;Java增强for循环&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for(声明语句 : 表达式)
{
    // 代码句子
}
// 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配
// 表达式：要访问的数组名，或者是返回值为数组的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test{
    public static void main(String[] args){
        String [] names = {&amp;quot;James&amp;quot;, &amp;quot;Larry&amp;quot;, &amp;quot;Tom&amp;quot;, &amp;quot;Lacy&amp;quot;};
        for(String name : names){
            System.out.print(name);
            System.out.print(&amp;quot;,&amp;quot;);
        }
    }
}

// James,Larry,Tom,Lacy,
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;break关键字&#34;&gt;break关键字&lt;/h3&gt;
&lt;p&gt;break 主要用在循环语句或者 switch 语句中，用来跳出语句块&lt;/p&gt;
&lt;h3 id=&#34;continue关键字&#34;&gt;continue关键字&lt;/h3&gt;
&lt;p&gt;让程序立刻跳转到下一次循环的迭代&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java条件语句&#34;&gt;Java条件语句&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;if语句&lt;/li&gt;
&lt;li&gt;if...else语句&lt;/li&gt;
&lt;li&gt;if..else if...else语句&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-switch-case语句&#34;&gt;Java switch case语句&lt;/h2&gt;
&lt;p&gt;switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出直至break语句出现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String args[]){
      int i = 1;
      switch(i){
         case 0:
            System.out.println(&amp;quot;0&amp;quot;);
         case 1:
            System.out.println(&amp;quot;1&amp;quot;);
         case 2:
            System.out.println(&amp;quot;2&amp;quot;);
         case 3:
            System.out.println(&amp;quot;3&amp;quot;); break;
         default:
            System.out.println(&amp;quot;default&amp;quot;);
      }
   }
}

// 1
// 2
// 3
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;h3 id=&#34;声明数组变量&#34;&gt;声明数组变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dataType[] arrayRefVar;   // 首选的方法
 
或
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建数组&#34;&gt;创建数组&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;arrayRefVar = new dataType[arraySize];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;数组变量的声明，和创建数组可以用一条语句完成:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dataType[] arrayRefVar = new dataType[arraySize];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其他：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dataType[] arrayRefVar = {value0, value1, ..., valuek};&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;数组作为方法的参数或返回值&#34;&gt;数组作为方法的参数或返回值&lt;/h3&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;printArray(new int[]{3, 1, 2, 6, 4, 2});&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;多维数组&#34;&gt;多维数组&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;String[][] str = new String[3][4];&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;arrays类&#34;&gt;Arrays类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;给数组赋值：通过 fill 方法&lt;/li&gt;
&lt;li&gt;对数组排序：通过 sort 方法,按升序&lt;/li&gt;
&lt;li&gt;比较数组：通过 equals 方法比较数组中元素值是否相等&lt;/li&gt;
&lt;li&gt;查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;日期和时间date类&#34;&gt;日期和时间（Date类）&lt;/h2&gt;
&lt;p&gt;实例化Date对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Date()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Date(long milliseconds)&lt;/code&gt;:该参数为1970.01.01起的毫秒数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;date对象方法&#34;&gt;Date对象方法：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/NuxSwZg4ChOGVKd.png&#34; alt=&#34;Date方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;使用simpledateformat格式化日期&#34;&gt;使用SimpleDateFormat格式化日期&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SimpleDateFormat ft = new SimpleDateFormat (&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用printf格式化日期&#34;&gt;使用printf格式化日期&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/DbGnxh2APTH9qfW.png&#34; alt=&#34;printf格式化日期.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;全部日期和时间信息：%tc%n&amp;quot;,date);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;%1$s %2$tB %2$td, %2$tY&amp;quot;, &amp;quot;Due date:&amp;quot;, date);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;%s %tB %&amp;lt;te, %&amp;lt;tY&amp;quot;, &amp;quot;Due date:&amp;quot;, date);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;java休眠sleep&#34;&gt;Java休眠（sleep）&lt;/h3&gt;
&lt;p&gt;sleep()阻塞当前进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
  
public class SleepDemo {
    public static void main(String[] args) {
        try { 
            System.out.println(new Date( ) + &amp;quot;\n&amp;quot;); 
            Thread.sleep(1000*3);   // 休眠3秒
            System.out.println(new Date( ) + &amp;quot;\n&amp;quot;); 
        } catch (Exception e) { 
            System.out.println(&amp;quot;Got an exception!&amp;quot;); 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测量时间&#34;&gt;测量时间&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
  
public class DiffDemo {
 
   public static void main(String[] args) {
      try {
         long start = System.currentTimeMillis( );
         System.out.println(new Date( ) + &amp;quot;\n&amp;quot;);
         Thread.sleep(5*60*10);
         System.out.println(new Date( ) + &amp;quot;\n&amp;quot;);
         long end = System.currentTimeMillis( );
         long diff = end - start;
         System.out.println(&amp;quot;Difference is : &amp;quot; + diff);
      } catch (Exception e) {
         System.out.println(&amp;quot;Got an exception!&amp;quot;);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;calendar类对日期进行操作&#34;&gt;Calendar类（对日期进行操作）&lt;/h3&gt;
&lt;p&gt;创建Calendar对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Calendar c = Calendar.getInstance();//默认是当前日期&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//创建一个代表2009年6月12日的Calendar对象&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Calendar c1 = Calendar.getInstance();&lt;/code&gt;&lt;br&gt;
&lt;code&gt;c1.set(2009, 6 - 1, 12);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象信息的设置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set设置：&lt;code&gt;public final void set(int year,int month,int date)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add设置：&lt;code&gt;c1.add(Calendar.DATE, 10);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象信息的获得:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int year = c1.get(Calendar.YEAR);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;gregoriancalendar类&#34;&gt;GregorianCalendar类&lt;/h3&gt;
&lt;p&gt;GregorianCalendar对象构造方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/Yomul6awe2RshgL.png&#34; alt=&#34;GregorianCalendar构造方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;GregorianCalendar对象常用方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/RxTBoJFD1AIplwq.png&#34; alt=&#34;GregorianCalendar常用方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java正则表达式&#34;&gt;Java正则表达式&lt;/h2&gt;
&lt;h3 id=&#34;正则表达式语法&#34;&gt;正则表达式语法：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/Mpk1wGBncSCRXOP.png&#34; alt=&#34;正则表达式语法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;regex包&#34;&gt;regex包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pattern类：Pattern对象是一个正则表达式的编译表示&lt;/li&gt;
&lt;li&gt;Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎&lt;/li&gt;
&lt;li&gt;PatternSyntaxException类：是一个非强制异常类，表示一个正则表达式模式中的语法错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;matcher类的方法&#34;&gt;Matcher类的方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/HKFdD3Gmsl7xXcI.png&#34; alt=&#34;matcher方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;patternsyntaxexception类的方法&#34;&gt;PatternSyntaxException类的方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/ji7tRZLYEQkwg31.png&#34; alt=&#34;patternsyntaxexception方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-流stream-文件file-io&#34;&gt;Java 流（stream）、文件（file）、IO&lt;/h2&gt;
&lt;p&gt;Java.io 包几乎包含了所有操作输入、输出需要的类&lt;/p&gt;
&lt;p&gt;一个流可以理解为一个数据的序列&lt;/p&gt;
&lt;p&gt;输入流表示从一个源读取数据，输出流表示向一个目标写数据&lt;/p&gt;
&lt;h3 id=&#34;读取控制台输入&#34;&gt;读取控制台输入&lt;/h3&gt;
&lt;p&gt;把System.in包装在一个BufferedReader对象中创建一个字符流&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BufferedReader br = new BufferedReader(new InputStreamReader(System.in));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;BufferedReader对象创建后，read()方法从控制台读取一个字符，readLine()方法从控制台读取一个字符串&lt;/p&gt;
&lt;p&gt;从控制台读取多字符输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int read( ) throws IOException&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用 BufferedReader 在控制台读取字符
 
import java.io.*;
 
public class BRRead {
    public static void main(String[] args) throws IOException {
        char c;
        // 使用 System.in 创建 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(&amp;quot;输入字符, 按下 &#39;q&#39; 键退出。&amp;quot;);
        // 读取字符
        do {
            c = (char) br.read();
            System.out.println(c);
        } while (c != &#39;q&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从控制台读取字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String readLine( ) throws IOException&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用 BufferedReader 在控制台读取字符
import java.io.*;
 
public class BRReadLines {
    public static void main(String[] args) throws IOException {
        // 使用 System.in 创建 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str;
        System.out.println(&amp;quot;Enter lines of text.&amp;quot;);
        System.out.println(&amp;quot;Enter &#39;end&#39; to quit.&amp;quot;);
        do {
            str = br.readLine();
            System.out.println(str);
        } while (!str.equals(&amp;quot;end&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;控制台输出&#34;&gt;控制台输出&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;System.out.print()&lt;/code&gt;, &lt;code&gt;System.out.println()&lt;/code&gt;, &lt;code&gt;System.out.write()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;读写文件&#34;&gt;读写文件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;FileInputStream&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该流用于读取数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用字符串类型的文件名来创建一个输入流对象来读取文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InputStream f = new FileInputStream(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用一个文件对象来创建一个输入流对象来读取文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File f = new File(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;InputStream in = new FileInputStream(f);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InputStream对象的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/3MpPyQUnLdIxrFD.png&#34; alt=&#34;InputStream方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该流用于创建一个文件并像文件中写入数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用字符串类型的文件名来创建一个输出流对象&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OutputStream f = new FileOutputStream(&amp;quot;C:/java/hello&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用一个文件对象来创建一个输出流来写文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File f = new File(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;OutputStream fOut = new FileOutputStream(f);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OutputStream对象的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/STUIgC2LF8MRcZ4.png&#34; alt=&#34;OutputStream方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其他输出流：&lt;code&gt;ByteArrayOutputStream&lt;/code&gt;、&lt;code&gt;DataOutputStream&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
 
public class fileStreamTest {
    public static void main(String[] args) {
        try {
            byte bWrite[] = { 11, 21, 3, 40, 5 };
            OutputStream os = new FileOutputStream(&amp;quot;test.txt&amp;quot;);
            for (int x = 0; x &amp;lt; bWrite.length; x++) {
                os.write(bWrite[x]); // writes the bytes
            }
            os.close();
 
            InputStream is = new FileInputStream(&amp;quot;test.txt&amp;quot;);
            int size = is.available();
 
            for (int i = 0; i &amp;lt; size; i++) {
                System.out.print((char) is.read() + &amp;quot;  &amp;quot;);
            }
            is.close();
        } catch (IOException e) {
            System.out.print(&amp;quot;Exception&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;关于文件和io的类&#34;&gt;关于文件和I/O的类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;File Class&lt;/li&gt;
&lt;li&gt;FileReader Class&lt;/li&gt;
&lt;li&gt;FileWriter Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mkdir()方法创建一个文件夹，成功返回true，失败返回false&lt;/li&gt;
&lt;li&gt;mkidrs()方法创建一个文件夹和它所有父类文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 
public class CreateDir {
    public static void main(String[] args) {
        String dirname = &amp;quot;/tmp/user/java/bin&amp;quot;;
        File d = new File(dirname);
        // 现在创建目录
        d.mkdirs();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;读取目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调用该对象的list()方法，提取目录包含的文件和文件夹列表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 
public class DirList {
    public static void main(String args[]) {
        String dirname = &amp;quot;/tmp&amp;quot;;
        File f1 = new File(dirname);
        if (f1.isDirectory()) {
            System.out.println(&amp;quot;目录 &amp;quot; + dirname);
            String s[] = f1.list();
            for (int i = 0; i &amp;lt; s.length; i++) {
                File f = new File(dirname + &amp;quot;/&amp;quot; + s[i]);
                if (f.isDirectory()) {
                    System.out.println(s[i] + &amp;quot; 是一个目录&amp;quot;);
                } else {
                    System.out.println(s[i] + &amp;quot; 是一个文件&amp;quot;);
                }
            }
        } else {
            System.out.println(dirname + &amp;quot; 不是一个目录&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;删除目录或文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;java.io.File.delete()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;删除某一目录时，必须保证该目录下没有其他文件&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;scanner-类&#34;&gt;Scanner 类&lt;/h2&gt;
&lt;p&gt;用于获取用户的输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Scanner s = new Scanner(System.in)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scanner类的next()和nextLine()获取输入的字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;next()以空白为结束符，不能得到带空格的字符串&lt;/li&gt;
&lt;li&gt;nextLine()以Enter为结束符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以读取其他类型的数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nextXxx()&lt;/code&gt;: 例如 f = scan.nextFloat()&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;异常发生的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户输入非法字符&lt;/li&gt;
&lt;li&gt;要打开的文件不存在&lt;/li&gt;
&lt;li&gt;网络通信连接中断，或者JVM内存溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种类型的异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查性异常&lt;/li&gt;
&lt;li&gt;运行时异常&lt;/li&gt;
&lt;li&gt;错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exception类有两个主要的子类：IOException类和RuntimeException类&lt;/p&gt;
&lt;h3 id=&#34;java-内置异常类&#34;&gt;java 内置异常类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/h7Vr2tE3Gi8vW19.png&#34; alt=&#34;内置异常类.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;异常方法&#34;&gt;异常方法&lt;/h3&gt;
&lt;h3 id=&#34;捕获异常&#34;&gt;捕获异常&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try
{
   // 程序代码
}catch(ExceptionName e1)
{
   //Catch 块
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;catch语句包含要捕获异常的声明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
public class ExcepTest{
 
   public static void main(String args[]){
      try{
         int a[] = new int[2];
         System.out.println(&amp;quot;Access element three :&amp;quot; + a[3]);
      }catch(ArrayIndexOutOfBoundsException e){
         System.out.println(&amp;quot;Exception thrown  :&amp;quot; + e);
      }
      System.out.println(&amp;quot;Out of the block&amp;quot;);
   }
}


//Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 2
//Out of the block
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多重捕获块&#34;&gt;多重捕获块&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try{
   // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}catch(异常类型3 异常的变量名3){
  // 程序代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;throwsthrow关键字&#34;&gt;throws/throw关键字&lt;/h3&gt;
&lt;p&gt;如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws/throw 关键字来声明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void withdraw(double amount) throws RemoteException InsufficientFundsException&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;finally-关键字&#34;&gt;finally 关键字&lt;/h3&gt;
&lt;p&gt;无论是否发生异常，finally 代码块中的代码总会被执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try{
  // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}finally{
  // 程序代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;声明自定义异常&#34;&gt;声明自定义异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有异常都必须是 Throwable 的子类&lt;/li&gt;
&lt;li&gt;如果希望写一个检查性异常类，则需要继承 Exception 类&lt;/li&gt;
&lt;li&gt;如果你想写一个运行时异常类，那么需要继承 RuntimeException 类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用异常&#34;&gt;通用异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JVM异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类&lt;/li&gt;
&lt;li&gt;程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类&lt;/li&gt;
&lt;/ul&gt;
">基础语法</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>