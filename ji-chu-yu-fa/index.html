<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="1">
<meta name="theme-color" content="#868e96">
<title>基础语法 | zd_blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1647134497534">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/atom-one-dark.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="基础语法" />
  <meta name="keywords" content="java" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>zd_blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">等风来 or 追风去</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top/archives" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            
            <li class="nav-item ">
              
              
                <a href="https://zdblog.top/tags" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">zd</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">2</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">1</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">Java基础语法</a>
<ul>
<li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></li>
<li><a href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6">修饰符</a></li>
<li><a href="#java%E5%8F%98%E9%87%8F">Java变量</a></li>
<li><a href="#java%E5%85%B3%E9%94%AE%E5%AD%97">Java关键字</a></li>
</ul>
</li>
<li><a href="#java-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB">Java 对象和类</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">创建对象</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95">访问实例变量和方法</a></li>
<li><a href="#java%E5%8C%85">Java包</a></li>
</ul>
</li>
<li><a href="#java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Java基本数据类型</a>
<ul>
<li><a href="#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">内置数据类型</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">引用数据类型</a></li>
<li><a href="#java%E5%B8%B8%E9%87%8F">Java常量</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">自动类型转换</a></li>
</ul>
</li>
<li><a href="#java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">Java变量类型</a>
<ul>
<li><a href="#java%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">java局部变量</a></li>
<li><a href="#java%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F">Java实例变量</a></li>
<li><a href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">类变量（静态变量）</a></li>
</ul>
</li>
<li><a href="#java%E4%BF%AE%E9%A5%B0%E7%AC%A6">java修饰符</a>
<ul>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">访问控制修饰符</a></li>
<li><a href="#%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">非访问修饰符</a></li>
</ul>
</li>
<li><a href="#java-%E8%BF%90%E7%AE%97%E7%AC%A6">java 运算符</a>
<ul>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">运算符优先级</a></li>
</ul>
</li>
<li><a href="#java%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">Java循环结构</a>
<ul>
<li><a href="#java%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF">Java增强for循环</a></li>
<li><a href="#break%E5%85%B3%E9%94%AE%E5%AD%97">break关键字</a></li>
<li><a href="#continue%E5%85%B3%E9%94%AE%E5%AD%97">continue关键字</a></li>
</ul>
</li>
<li><a href="#java%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">Java条件语句</a></li>
<li><a href="#java-switch-case%E8%AF%AD%E5%8F%A5">Java switch case语句</a></li>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a>
<ul>
<li><a href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F">声明数组变量</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84">创建数组</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC">数组作为方法的参数或返回值</a></li>
<li><a href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a></li>
<li><a href="#arrays%E7%B1%BB">Arrays类</a></li>
</ul>
</li>
<li><a href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4date%E7%B1%BB">日期和时间（Date类）</a>
<ul>
<li><a href="#date%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95">Date对象方法：</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8simpledateformat%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F">使用SimpleDateFormat格式化日期</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F">使用printf格式化日期</a></li>
<li><a href="#java%E4%BC%91%E7%9C%A0sleep">Java休眠（sleep）</a></li>
<li><a href="#%E6%B5%8B%E9%87%8F%E6%97%B6%E9%97%B4">测量时间</a></li>
<li><a href="#calendar%E7%B1%BB%E5%AF%B9%E6%97%A5%E6%9C%9F%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">Calendar类（对日期进行操作）</a></li>
<li><a href="#gregoriancalendar%E7%B1%BB">GregorianCalendar类</a></li>
</ul>
</li>
<li><a href="#java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">Java正则表达式</a>
<ul>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95">正则表达式语法：</a></li>
<li><a href="#regex%E5%8C%85">regex包</a></li>
<li><a href="#matcher%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">Matcher类的方法</a></li>
<li><a href="#patternsyntaxexception%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">PatternSyntaxException类的方法</a></li>
</ul>
</li>
<li><a href="#java-%E6%B5%81stream-%E6%96%87%E4%BB%B6file-io">Java 流（stream）、文件（file）、IO</a>
<ul>
<li><a href="#%E8%AF%BB%E5%8F%96%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5">读取控制台输入</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA">控制台输出</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6">读写文件</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E5%92%8Cio%E7%9A%84%E7%B1%BB">关于文件和I/O的类</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
</ul>
</li>
<li><a href="#scanner-%E7%B1%BB">Scanner 类</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a>
<ul>
<li><a href="#java-%E5%86%85%E7%BD%AE%E5%BC%82%E5%B8%B8%E7%B1%BB">java 内置异常类</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E6%96%B9%E6%B3%95">异常方法</a></li>
<li><a href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">捕获异常</a></li>
<li><a href="#%E5%A4%9A%E9%87%8D%E6%8D%95%E8%8E%B7%E5%9D%97">多重捕获块</a></li>
<li><a href="#throwsthrow%E5%85%B3%E9%94%AE%E5%AD%97">throws/throw关键字</a></li>
<li><a href="#finally-%E5%85%B3%E9%94%AE%E5%AD%97">finally 关键字</a></li>
<li><a href="#%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">声明自定义异常</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E5%BC%82%E5%B8%B8">通用异常</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://zdblog.top/ji-chu-yu-fa/"> 基础语法 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-03-13 09:01:22">2022-03-13</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://zdblog.top/SLe3AwTIj/">
        <span>java</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >20<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >4798<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/ji-chu-yu-fa/"
      data-flag-title="基础语法"
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <h2 id="java基础语法">Java基础语法</h2>
<p>Java语言是面向对象的</p>
<p>先介绍下类、对象、方法和实例变量的概念</p>
<ul>
<li>对象：是类的一个实例，有状态有行为。eg：对象（一条狗），状态（名字、品种、颜色等），行为（叫、吃、摇尾巴等）</li>
<li>类：类是一个模板，描述一类对象的行为和状态</li>
<li>方法：方法就是行为，一个类可以有很多方法</li>
<li>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定</li>
</ul>
<p>注意：</p>
<ul>
<li>大小写敏感</li>
<li>
<blockquote>
<p>包名：多单词都小写</p>
<p>类名、接口名：所有单词首字母大写</p>
<p>变量名、方法名：第一个单词首字母小写，后面大写</p>
<p>常量名：所有字母都大写，多单词用下划线连接(eg:XXX_YYY_ZZZ)</p>
</blockquote>
</li>
<li>源文件名必须与类名相同</li>
<li>一个源文件只能有一个public类，可以有若干个非public类</li>
<li>主方法入口：<code>public static void main(String[] args)</code></li>
</ul>
<p><code>public static void main(String[] args)</code>:</p>
<blockquote>
<p>public：访问修饰符<br>
static：关键字<br>
void：返回类型<br>
main：方法名<br>
String：String类<br>
args：字符串数组</p>
</blockquote>
<h3 id="标识符">标识符</h3>
<p>Java所有的组成部分都需要名字。</p>
<p>标识符：类名、变量名、方法名</p>
<p>标识符规范：</p>
<blockquote>
<p>首字符：字母、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">、</mi><mi mathvariant="normal">其</mi></msub><mi mathvariant="normal">他</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">母</mi><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">、_
其他字符：字母、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.15em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord cjk_fallback">、</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">其</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">母</span><span class="mord cjk_fallback">、</span></span></span></span>、_、数字<br>
大小写敏感</p>
</blockquote>
<h3 id="修饰符">修饰符</h3>
<p>Java用修饰符来修饰类中的方法和属性</p>
<ul>
<li>访问控制修饰符：default、public、protected、private</li>
<li>非访问控制修饰符：final、abstract、static、synchronized</li>
</ul>
<h3 id="java变量">Java变量</h3>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h3 id="java关键字">Java关键字</h3>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/03/08/Pnm1sC7QRDZG4z6.png" alt="Java关键字.png" loading="lazy"></figure>
<hr>
<h2 id="java-对象和类">Java 对象和类</h2>
<p>Java面向对象支持以下基本概念：</p>
<ul>
<li>多态</li>
<li>继承</li>
<li>封装</li>
<li>抽象</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>重载</li>
</ul>
<p>方法：改变对象的内部状态，对象的相互调用</p>
<p>类中的变量：</p>
<ul>
<li>局部变量：在方法中定义的变量，随方法的结束而销毁</li>
<li>成员变量：定义在类中、方法之外的变量，在创建对象时实例化，在类中可被访问</li>
<li>类变量：声明在类中、方法块之外、必须声明为static类型</li>
</ul>
<h3 id="构造方法">构造方法</h3>
<p>每个类都有一个或多个构造方法</p>
<p>创建对象时，至少调用一个构造方法</p>
<p>构造方法的名称必须与类同名</p>
<h3 id="创建对象">创建对象</h3>
<ol>
<li>声明：对象的名称和类型</li>
<li>实例化：使用关键字<code>new</code>来创建一个对象</li>
<li>初始化：使用<code>new</code>创建对象时，会调用构造方法初始化对象</li>
</ol>
<pre><code class="language-java">public class Puppy{

    // 该构造方法仅有一个参数：name
    public Puppy(String name){
        System.out.println(&quot;The dog's name is : &quot; + name);
    }

    public static void main(String[] args){
        Puppy myPuppy = new Puppy(&quot;Tommy&quot;);
    }
}
</code></pre>
<h3 id="访问实例变量和方法">访问实例变量和方法</h3>
<p>通过已创建的对象来访问成员变量和成员方法</p>
<pre><code class="language-java">/* 实例化对象 */
Object referenceVariable = new Constructor();
/* 访问类中的变量 */
referenceVariable.variableName;
/* 访问类中的方法 */
referenceVariable.methodName();
</code></pre>
<p>eg:</p>
<pre><code class="language-java">public class Puppy{
    int puppyAge;
    public Puppy(String name){
        System.out.println(&quot;The dog's name is : &quot; + name)；
    }

    public void setAge(int age){
        puppyAge = age;
    }

    public int getAge(){
        return puppyAge;
    }

    public static void main(String[] args){
        Puppy myPuppy = new Puppy(Tommy);

        myPuppy.setAge(2)
        System.out.println(&quot;myPuppy's age is : &quot; + myPuppy.getAge());
        System.out.println(&quot;变量值：&quot; + myPuppy.puppyAge);
    }
}
</code></pre>
<h3 id="java包">Java包</h3>
<p>包主要用来对类和接口进行分类</p>
<hr>
<h2 id="java基本数据类型">Java基本数据类型</h2>
<ol>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ol>
<h3 id="内置数据类型">内置数据类型</h3>
<p>8种基本类型</p>
<ul>
<li>byte：8位,默认值<code>0</code></li>
<li>short：16位，默认值<code>0</code></li>
<li>int：32位，默认值<code>0</code></li>
<li>long：64位，默认值<code>0L</code>(L不区分大小写，最好大写区分1)</li>
<li>float：单精度，32位，默认值<code>0.0f</code>(不能表示精确的值)</li>
<li>double：双精度，64位，默认值<code>0.0d</code>(不能表示精确值)</li>
<li>boolean：标志记录true/false，默认<code>false</code></li>
<li>char：单一的16位Unicode字符，<code>\u0000</code>~<code>\uffff</code></li>
</ul>
<h3 id="引用数据类型">引用数据类型</h3>
<p>对象、数组都是引用数据类型</p>
<p>默认值<code>null</code></p>
<p>一个引用变量可以用来引用任何与之兼容的类型</p>
<h3 id="java常量">Java常量</h3>
<p>使用<code>final</code>关键字来修饰常量</p>
<p>eg：`final double PI = 3.14159265;</p>
<p>常量名通常大写</p>
<p>字符串常量：双引号之间的字符序列</p>
<p>转义字符：</p>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/03/08/Go2nVrQZF8Rpa9K.png" alt="转义字符.png" loading="lazy"></figure>
<h3 id="自动类型转换">自动类型转换</h3>
<pre><code>low --------------------------------------&gt; high
byte,short,char -&gt; int -&gt; long -&gt; float -&gt; double
</code></pre>
<ul>
<li>boolean不能转换</li>
<li>容量大的必须用强制转换才可以转换为容量小的</li>
<li>浮点数舍弃小数转换得到整形</li>
</ul>
<hr>
<h2 id="java变量类型">Java变量类型</h2>
<ul>
<li>类变量</li>
<li>实例变量</li>
<li>局部变量</li>
</ul>
<p>eg：</p>
<pre><code class="language-java">public class Variable{
    static int allClicks=0;    // 类变量
 
    String str=&quot;hello world&quot;;  // 实例变量
 
    public void method(){
 
        int i =0;  // 局部变量
 
    }
}
</code></pre>
<h3 id="java局部变量">java局部变量</h3>
<ul>
<li>局部变量声明在方法中</li>
<li>不能用访问修饰符</li>
<li>没有默认值，必须先初始化</li>
</ul>
<h3 id="java实例变量">Java实例变量</h3>
<ul>
<li>实例变量声明在一个类中，在方法、构造方法和语句块之外</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定，对象被销毁的时候销毁</li>
<li>实例变量的值应该至少被一个方法，使得外部能够通过这些方式获取实例变量信息</li>
<li>可以声明在使用前或者使用后</li>
<li>可用访问修饰符</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见</li>
<li>有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定</li>
<li>可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName</li>
</ul>
<h3 id="类变量静态变量">类变量（静态变量）</h3>
<ul>
<li>在类中以 static 关键字声明，但必须在方法之外</li>
<li>类只拥有类变量的一份拷贝</li>
<li>静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</li>
<li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母</li>
</ul>
<hr>
<h2 id="java修饰符">java修饰符</h2>
<ul>
<li>访问修饰符</li>
<li>非访问修饰符</li>
</ul>
<p>修饰符用来定义类、方法或者变量，通常放在语句的最前端</p>
<h3 id="访问控制修饰符">访问控制修饰符</h3>
<p>用来保护对类、对象、方法的访问</p>
<ul>
<li>default（默认，不写）：同一包内可见，不适用任何修饰符</li>
<li>private：同一类内可见，不能修饰类（外部类）</li>
<li>public：对所有类可见</li>
<li>protected：对同一包内的类和子类可见，不能修饰类</li>
</ul>
<p>接口里的变量都隐式声明为<code>public static final</code>，而接口里的方法默认为<code>public</code></p>
<ol>
<li>私有访问修饰符--private</li>
</ol>
<p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问</p>
<p>eg：</p>
<pre><code class="language-java">public class Logger {
    private String format;
    public String getFormat() {
        return this.format;
    }
    public void setFormat(String format) {
        this.format = format;
    }
}
</code></pre>
<ol start="2">
<li>公有访问修饰符--public</li>
</ol>
<p>声明为 public 的类、方法、构造方法和接口能够被任何其他类访问</p>
<ol start="3">
<li>受保护的访问修饰符--protected</li>
</ol>
<ul>
<li>子类与父类在同一包中：能被同一个包中的任何其他类访问</li>
<li>子类与父类不在同一包中：在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法</li>
</ul>
<ol start="4">
<li>方法继承规则：</li>
</ol>
<ul>
<li>父类-public，子类public</li>
<li>父类-protected，子类public、protected</li>
<li>父类-private，子类不能继承</li>
</ul>
<h3 id="非访问修饰符">非访问修饰符</h3>
<ul>
<li>static：用来修饰类方法和类变量</li>
<li>final：修饰类、方法、变量，修饰的类不能被继承，方法不能被重新定义，变量为常量，不可修改</li>
<li>abstract：用来修饰抽象类和抽象方法</li>
<li>synchronized和volatile：主要用于线程的编程</li>
</ul>
<ol>
<li>
<p>static修饰符</p>
<ul>
<li>静态变量：用来声明静态变量，只有一份拷贝</li>
<li>静态方法：静态方法不能使用类的非静态变量</li>
</ul>
</li>
<li>
<p>final修饰符</p>
<ul>
<li>final变量：赋值后为常量</li>
<li>final方法：可以被继承，但不能被子类重写</li>
<li>final类：不能被继承</li>
</ul>
</li>
<li>
<p>abstract修饰符</p>
</li>
<li>
<p>synchronized修饰符</p>
</li>
</ol>
<p>声明的方法同一时间只能被一个线程访问</p>
<ol start="5">
<li>transient修饰符</li>
</ol>
<p>java 虚拟机(JVM)跳过被 transient 修饰的实例变量</p>
<ol start="6">
<li>volatile修饰符</li>
</ol>
<p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值,成员变量发生变化时，会强制线程将变化值回写到共享内存</p>
<p>任何时刻，两个不同的线程总是看到某个成员变量的同一个值</p>
<hr>
<h2 id="java-运算符">java 运算符</h2>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<ol>
<li>算术运算符</li>
</ol>
<p><code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>,<code>++</code>,<code>--</code></p>
<ul>
<li>前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算</li>
<li>后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算</li>
</ul>
<ol start="2">
<li>关系运算符</li>
</ol>
<p><code>==</code>,<code>!=</code>,<code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>&lt;=</code></p>
<ol start="3">
<li>位运算符</li>
</ol>
<p><code>&amp;</code>,<code>|</code>,<code>^</code>,<code>~</code>,<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>&gt;&gt;&gt;</code>:</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/03/09/SmKYWLxFpNgVylT.png" alt="位运算符.png" loading="lazy"></figure>
<ol start="4">
<li>逻辑运算符</li>
</ol>
<p><code>&amp;&amp;</code>,<code>||</code>,<code>!</code></p>
<ol start="5">
<li>赋值运算符</li>
</ol>
<p><code>=</code>,<code>+=</code>,<code>-=</code>,<code>*=</code>,<code>/=</code>,<code>(%)=</code>,<code>&lt;&lt;=</code>,<code>&gt;&gt;=</code>,<code>&amp;=</code>,<code>^=</code>,<code>|=</code></p>
<ol start="6">
<li>条件运算符（三元运算符）</li>
</ol>
<p><code>variable x = (expression) ? value if true : value if false</code></p>
<p>eg:<code>b = (a == 1) ? 20 : 30;</code></p>
<ol start="7">
<li>instanceof运算符</li>
</ol>
<p>用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）</p>
<p><code>( Object reference variable ) instanceof (class/interface type)</code></p>
<p>eg:</p>
<pre><code class="language-java">String name = &quot;James&quot;;
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
</code></pre>
<h3 id="运算符优先级">运算符优先级</h3>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/03/09/BfPx341d8E9zSwG.png" alt="运算符优先级.png" loading="lazy"></figure>
<h2 id="java循环结构">Java循环结构</h2>
<ul>
<li>while循环</li>
<li>do...while循环</li>
<li>for循环</li>
</ul>
<h3 id="java增强for循环">Java增强for循环</h3>
<pre><code class="language-java">for(声明语句 : 表达式)
{
    // 代码句子
}
// 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配
// 表达式：要访问的数组名，或者是返回值为数组的方法
</code></pre>
<p>eg:</p>
<pre><code class="language-java">public class Test{
    public static void main(String[] args){
        String [] names = {&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;};
        for(String name : names){
            System.out.print(name);
            System.out.print(&quot;,&quot;);
        }
    }
}

// James,Larry,Tom,Lacy,
</code></pre>
<h3 id="break关键字">break关键字</h3>
<p>break 主要用在循环语句或者 switch 语句中，用来跳出语句块</p>
<h3 id="continue关键字">continue关键字</h3>
<p>让程序立刻跳转到下一次循环的迭代</p>
<hr>
<h2 id="java条件语句">Java条件语句</h2>
<ul>
<li>if语句</li>
<li>if...else语句</li>
<li>if..else if...else语句</li>
</ul>
<hr>
<h2 id="java-switch-case语句">Java switch case语句</h2>
<p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支</p>
<pre><code class="language-java">switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
</code></pre>
<p>如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出直至break语句出现</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int i = 1;
      switch(i){
         case 0:
            System.out.println(&quot;0&quot;);
         case 1:
            System.out.println(&quot;1&quot;);
         case 2:
            System.out.println(&quot;2&quot;);
         case 3:
            System.out.println(&quot;3&quot;); break;
         default:
            System.out.println(&quot;default&quot;);
      }
   }
}

// 1
// 2
// 3
</code></pre>
<hr>
<h2 id="数组">数组</h2>
<h3 id="声明数组变量">声明数组变量</h3>
<pre><code class="language-java">dataType[] arrayRefVar;   // 首选的方法
 
或
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
</code></pre>
<h3 id="创建数组">创建数组</h3>
<p><code>arrayRefVar = new dataType[arraySize];</code></p>
<p>数组变量的声明，和创建数组可以用一条语句完成:</p>
<p><code>dataType[] arrayRefVar = new dataType[arraySize];</code></p>
<p>其他：</p>
<p><code>dataType[] arrayRefVar = {value0, value1, ..., valuek};</code></p>
<h3 id="数组作为方法的参数或返回值">数组作为方法的参数或返回值</h3>
<p>eg:</p>
<p><code>printArray(new int[]{3, 1, 2, 6, 4, 2});</code></p>
<h3 id="多维数组">多维数组</h3>
<p><code>String[][] str = new String[3][4];</code></p>
<h3 id="arrays类">Arrays类</h3>
<ul>
<li>给数组赋值：通过 fill 方法</li>
<li>对数组排序：通过 sort 方法,按升序</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作</li>
</ul>
<hr>
<h2 id="日期和时间date类">日期和时间（Date类）</h2>
<p>实例化Date对象：</p>
<ul>
<li><code>Date()</code></li>
<li><code>Date(long milliseconds)</code>:该参数为1970.01.01起的毫秒数</li>
</ul>
<h3 id="date对象方法">Date对象方法：</h3>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/03/10/NuxSwZg4ChOGVKd.png" alt="Date方法.png" loading="lazy"></figure>
<h3 id="使用simpledateformat格式化日期">使用SimpleDateFormat格式化日期</h3>
<p><code>SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</code></p>
<h3 id="使用printf格式化日期">使用printf格式化日期</h3>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/03/10/DbGnxh2APTH9qfW.png" alt="printf格式化日期.png" loading="lazy"></figure>
<p>eg：</p>
<p><code>System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);</code></p>
<p><code>System.out.printf(&quot;%1$s %2$tB %2$td, %2$tY&quot;, &quot;Due date:&quot;, date);</code></p>
<p><code>System.out.printf(&quot;%s %tB %&lt;te, %&lt;tY&quot;, &quot;Due date:&quot;, date);</code></p>
<h3 id="java休眠sleep">Java休眠（sleep）</h3>
<p>sleep()阻塞当前进程</p>
<pre><code class="language-java">import java.util.*;
  
public class SleepDemo {
    public static void main(String[] args) {
        try { 
            System.out.println(new Date( ) + &quot;\n&quot;); 
            Thread.sleep(1000*3);   // 休眠3秒
            System.out.println(new Date( ) + &quot;\n&quot;); 
        } catch (Exception e) { 
            System.out.println(&quot;Got an exception!&quot;); 
        }
    }
}
</code></pre>
<h3 id="测量时间">测量时间</h3>
<pre><code class="language-java">import java.util.*;
  
public class DiffDemo {
 
   public static void main(String[] args) {
      try {
         long start = System.currentTimeMillis( );
         System.out.println(new Date( ) + &quot;\n&quot;);
         Thread.sleep(5*60*10);
         System.out.println(new Date( ) + &quot;\n&quot;);
         long end = System.currentTimeMillis( );
         long diff = end - start;
         System.out.println(&quot;Difference is : &quot; + diff);
      } catch (Exception e) {
         System.out.println(&quot;Got an exception!&quot;);
      }
   }
}
</code></pre>
<h3 id="calendar类对日期进行操作">Calendar类（对日期进行操作）</h3>
<p>创建Calendar对象：</p>
<ul>
<li><code>Calendar c = Calendar.getInstance();//默认是当前日期</code></li>
<li><code>//创建一个代表2009年6月12日的Calendar对象</code><br>
<code>Calendar c1 = Calendar.getInstance();</code><br>
<code>c1.set(2009, 6 - 1, 12);</code></li>
</ul>
<p>对象信息的设置:</p>
<ul>
<li>set设置：<code>public final void set(int year,int month,int date)</code></li>
<li>add设置：<code>c1.add(Calendar.DATE, 10);</code></li>
</ul>
<p>对象信息的获得:</p>
<p><code>int year = c1.get(Calendar.YEAR);</code></p>
<h3 id="gregoriancalendar类">GregorianCalendar类</h3>
<p>GregorianCalendar对象构造方法：</p>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/03/10/Yomul6awe2RshgL.png" alt="GregorianCalendar构造方法.png" loading="lazy"></figure>
<p>GregorianCalendar对象常用方法：</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/03/10/RxTBoJFD1AIplwq.png" alt="GregorianCalendar常用方法.png" loading="lazy"></figure>
<hr>
<h2 id="java正则表达式">Java正则表达式</h2>
<h3 id="正则表达式语法">正则表达式语法：</h3>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/03/11/Mpk1wGBncSCRXOP.png" alt="正则表达式语法.png" loading="lazy"></figure>
<h3 id="regex包">regex包</h3>
<ul>
<li>Pattern类：Pattern对象是一个正则表达式的编译表示</li>
<li>Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎</li>
<li>PatternSyntaxException类：是一个非强制异常类，表示一个正则表达式模式中的语法错误</li>
</ul>
<h3 id="matcher类的方法">Matcher类的方法</h3>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/03/11/HKFdD3Gmsl7xXcI.png" alt="matcher方法.png" loading="lazy"></figure>
<h3 id="patternsyntaxexception类的方法">PatternSyntaxException类的方法</h3>
<figure data-type="image" tabindex="11"><img src="https://s2.loli.net/2022/03/11/ji7tRZLYEQkwg31.png" alt="patternsyntaxexception方法.png" loading="lazy"></figure>
<hr>
<h2 id="java-流stream-文件file-io">Java 流（stream）、文件（file）、IO</h2>
<p>Java.io 包几乎包含了所有操作输入、输出需要的类</p>
<p>一个流可以理解为一个数据的序列</p>
<p>输入流表示从一个源读取数据，输出流表示向一个目标写数据</p>
<h3 id="读取控制台输入">读取控制台输入</h3>
<p>把System.in包装在一个BufferedReader对象中创建一个字符流</p>
<p><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</code></p>
<p>BufferedReader对象创建后，read()方法从控制台读取一个字符，readLine()方法从控制台读取一个字符串</p>
<p>从控制台读取多字符输入</p>
<p><code>int read( ) throws IOException</code></p>
<pre><code class="language-java">//使用 BufferedReader 在控制台读取字符
 
import java.io.*;
 
public class BRRead {
    public static void main(String[] args) throws IOException {
        char c;
        // 使用 System.in 创建 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(&quot;输入字符, 按下 'q' 键退出。&quot;);
        // 读取字符
        do {
            c = (char) br.read();
            System.out.println(c);
        } while (c != 'q');
    }
}
</code></pre>
<p>从控制台读取字符串</p>
<p><code>String readLine( ) throws IOException</code></p>
<pre><code class="language-java">//使用 BufferedReader 在控制台读取字符
import java.io.*;
 
public class BRReadLines {
    public static void main(String[] args) throws IOException {
        // 使用 System.in 创建 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str;
        System.out.println(&quot;Enter lines of text.&quot;);
        System.out.println(&quot;Enter 'end' to quit.&quot;);
        do {
            str = br.readLine();
            System.out.println(str);
        } while (!str.equals(&quot;end&quot;));
    }
}
</code></pre>
<h3 id="控制台输出">控制台输出</h3>
<p><code>System.out.print()</code>, <code>System.out.println()</code>, <code>System.out.write()</code></p>
<h3 id="读写文件">读写文件</h3>
<ol>
<li>FileInputStream</li>
</ol>
<p>该流用于读取数据</p>
<ul>
<li>
<p>使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>
<p><code>InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);</code></p>
</li>
<li>
<p>使用一个文件对象来创建一个输入流对象来读取文件</p>
<p><code>File f = new File(&quot;C:/java/hello&quot;);</code><br>
<code>InputStream in = new FileInputStream(f);</code></p>
</li>
</ul>
<p>InputStream对象的方法：</p>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2022/03/11/3MpPyQUnLdIxrFD.png" alt="InputStream方法.png" loading="lazy"></figure>
<ol start="2">
<li>FileOutputStream</li>
</ol>
<p>该流用于创建一个文件并像文件中写入数据</p>
<ul>
<li>
<p>使用字符串类型的文件名来创建一个输出流对象</p>
<p><code>OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</code></p>
</li>
<li>
<p>使用一个文件对象来创建一个输出流来写文件</p>
<p><code>File f = new File(&quot;C:/java/hello&quot;);</code><br>
<code>OutputStream fOut = new FileOutputStream(f);</code></p>
</li>
</ul>
<p>OutputStream对象的方法：</p>
<figure data-type="image" tabindex="13"><img src="https://s2.loli.net/2022/03/11/STUIgC2LF8MRcZ4.png" alt="OutputStream方法.png" loading="lazy"></figure>
<p>其他输出流：<code>ByteArrayOutputStream</code>、<code>DataOutputStream</code></p>
<p>eg：</p>
<pre><code class="language-java">import java.io.*;
 
public class fileStreamTest {
    public static void main(String[] args) {
        try {
            byte bWrite[] = { 11, 21, 3, 40, 5 };
            OutputStream os = new FileOutputStream(&quot;test.txt&quot;);
            for (int x = 0; x &lt; bWrite.length; x++) {
                os.write(bWrite[x]); // writes the bytes
            }
            os.close();
 
            InputStream is = new FileInputStream(&quot;test.txt&quot;);
            int size = is.available();
 
            for (int i = 0; i &lt; size; i++) {
                System.out.print((char) is.read() + &quot;  &quot;);
            }
            is.close();
        } catch (IOException e) {
            System.out.print(&quot;Exception&quot;);
        }
    }
}
</code></pre>
<h3 id="关于文件和io的类">关于文件和I/O的类</h3>
<ul>
<li>File Class</li>
<li>FileReader Class</li>
<li>FileWriter Class</li>
</ul>
<h3 id="目录">目录</h3>
<ol>
<li>
<p>创建目录：</p>
<ul>
<li>mkdir()方法创建一个文件夹，成功返回true，失败返回false</li>
<li>mkidrs()方法创建一个文件夹和它所有父类文件夹</li>
</ul>
</li>
</ol>
<pre><code class="language-java">import java.io.File;
 
public class CreateDir {
    public static void main(String[] args) {
        String dirname = &quot;/tmp/user/java/bin&quot;;
        File d = new File(dirname);
        // 现在创建目录
        d.mkdirs();
    }
}
</code></pre>
<ol start="2">
<li>读取目录</li>
</ol>
<p>调用该对象的list()方法，提取目录包含的文件和文件夹列表</p>
<pre><code class="language-java">import java.io.File;
 
public class DirList {
    public static void main(String args[]) {
        String dirname = &quot;/tmp&quot;;
        File f1 = new File(dirname);
        if (f1.isDirectory()) {
            System.out.println(&quot;目录 &quot; + dirname);
            String s[] = f1.list();
            for (int i = 0; i &lt; s.length; i++) {
                File f = new File(dirname + &quot;/&quot; + s[i]);
                if (f.isDirectory()) {
                    System.out.println(s[i] + &quot; 是一个目录&quot;);
                } else {
                    System.out.println(s[i] + &quot; 是一个文件&quot;);
                }
            }
        } else {
            System.out.println(dirname + &quot; 不是一个目录&quot;);
        }
    }
}
</code></pre>
<ol start="3">
<li>删除目录或文件</li>
</ol>
<p>使用<code>java.io.File.delete()</code>方法</p>
<p>删除某一目录时，必须保证该目录下没有其他文件</p>
<hr>
<h2 id="scanner-类">Scanner 类</h2>
<p>用于获取用户的输入</p>
<p><code>Scanner s = new Scanner(System.in)</code></p>
<p>Scanner类的next()和nextLine()获取输入的字符串</p>
<ul>
<li>next()以空白为结束符，不能得到带空格的字符串</li>
<li>nextLine()以Enter为结束符</li>
</ul>
<p>也可以读取其他类型的数据：</p>
<ul>
<li><code>nextXxx()</code>: 例如 f = scan.nextFloat()</li>
</ul>
<hr>
<h2 id="异常处理">异常处理</h2>
<p>异常发生的原因：</p>
<ul>
<li>用户输入非法字符</li>
<li>要打开的文件不存在</li>
<li>网络通信连接中断，或者JVM内存溢出</li>
</ul>
<p>三种类型的异常：</p>
<ul>
<li>检查性异常</li>
<li>运行时异常</li>
<li>错误</li>
</ul>
<p>Exception类有两个主要的子类：IOException类和RuntimeException类</p>
<h3 id="java-内置异常类">java 内置异常类</h3>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2022/03/11/h7Vr2tE3Gi8vW19.png" alt="内置异常类.png" loading="lazy"></figure>
<h3 id="异常方法">异常方法</h3>
<h3 id="捕获异常">捕获异常</h3>
<pre><code class="language-java">try
{
   // 程序代码
}catch(ExceptionName e1)
{
   //Catch 块
}
</code></pre>
<p>catch语句包含要捕获异常的声明</p>
<pre><code class="language-java">import java.io.*;
public class ExcepTest{
 
   public static void main(String args[]){
      try{
         int a[] = new int[2];
         System.out.println(&quot;Access element three :&quot; + a[3]);
      }catch(ArrayIndexOutOfBoundsException e){
         System.out.println(&quot;Exception thrown  :&quot; + e);
      }
      System.out.println(&quot;Out of the block&quot;);
   }
}


//Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 2
//Out of the block
</code></pre>
<h3 id="多重捕获块">多重捕获块</h3>
<pre><code class="language-java">try{
   // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}catch(异常类型3 异常的变量名3){
  // 程序代码
}
</code></pre>
<h3 id="throwsthrow关键字">throws/throw关键字</h3>
<p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws/throw 关键字来声明</p>
<p><code>public void withdraw(double amount) throws RemoteException InsufficientFundsException</code></p>
<h3 id="finally-关键字">finally 关键字</h3>
<p>无论是否发生异常，finally 代码块中的代码总会被执行</p>
<pre><code class="language-java">try{
  // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}finally{
  // 程序代码
}
</code></pre>
<h3 id="声明自定义异常">声明自定义异常</h3>
<ul>
<li>所有异常都必须是 Throwable 的子类</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类</li>
</ul>
<h3 id="通用异常">通用异常</h3>
<ul>
<li>JVM异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类</li>
<li>程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类</li>
</ul>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      zd
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://zdblog.top/ji-chu-yu-fa/" title="基础语法">https://zdblog.top/ji-chu-yu-fa/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://zdblog.top/SLe3AwTIj/"># java</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="面向对象" href="https://zdblog.top/mian-xiang-dui-xiang/">面向对象</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="面向对象" href="https://zdblog.top/mian-xiang-dui-xiang/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'E4xhzIEKDmAtoVnapYU5F67t-gzGzoHsz',
    appKey: 'Q1txwwJSaEmLcu4Oo8cHshbP',
    avatar: '',
    placeholder: '',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'true',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="\media\images\wallhaven-j5p6v5.jpg" />
              </div>
              
                
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/mian-xiang-dui-xiang/"" data-c="
          &lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;继承就是子类继承父类的特征和行为，使得子类对象（实例）具有弗雷德实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为&lt;/p&gt;
&lt;p&gt;继承格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class 父类 {
}
 
class 子类 extends 父类 {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;继承类型&#34;&gt;继承类型&lt;/h3&gt;
&lt;p&gt;Java不支持多继承，但支持多重继承&lt;/p&gt;
&lt;p&gt;1.单继承&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;多重继承&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt; &amp;lt;-- ...&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;不同类继承同一个类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class B&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;多继承（不支持）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Class A&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class B&lt;/code&gt; &amp;lt;-- &lt;code&gt;Class C&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;集成的特性&#34;&gt;集成的特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;子类拥有父类非 private 的属性、方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类可以拥有自己的属性和方法，即子类可以对父类进行扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类可以用自己的方式实现父类的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 的继承是单继承，但是可以多重继承&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;继承关键字&#34;&gt;继承关键字&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;extends&lt;/li&gt;
&lt;li&gt;implements&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;extends关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类的继承是单一继承，extends只能继承一个类&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;implements关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}
 
public class C implements A,B {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;super 和 this关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this关键字：指向自己的引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;final关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写&lt;/p&gt;
&lt;h3 id=&#34;构造器&#34;&gt;构造器&lt;/h3&gt;
&lt;p&gt;子类不继承父类的构造器，只是通过&lt;code&gt;super&lt;/code&gt;关键字调用&lt;/p&gt;
&lt;p&gt;如果父类构造器没有参数，系统自动调用父类的无参数构造器&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;重写override与重载overload&#34;&gt;重写（Override）与重载（Overload）&lt;/h2&gt;
&lt;p&gt;方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现&lt;/p&gt;
&lt;h3 id=&#34;override&#34;&gt;Override&lt;/h3&gt;
&lt;p&gt;重写是子类在不改变形参的前提下，重新编写父类方法的实现过程&lt;/p&gt;
&lt;p&gt;重写方法不能抛出新的异常或是申明更宽泛的异常&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Animal{
   public void move(){
      System.out.println(&amp;quot;动物可以移动&amp;quot;);
   }
}
 
class Dog extends Animal{
   public void move(){
      System.out.println(&amp;quot;狗可以跑和走&amp;quot;);
   }
}
 
public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象
 
      a.move();// 执行 Animal 类的方法
 
      b.move();//执行 Dog 类的方法
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法的重写规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数列表与被重写方法的参数列表必须完全相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父类的成员方法只能被它的子类重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明为 final 的方法不能被重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明为 static 的方法不能被重写，但是能够被再次声明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造方法不能被重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不能继承一个类，则不能重写该类的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;overload&#34;&gt;Overload&lt;/h3&gt;
&lt;p&gt;重载是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同&lt;/p&gt;
&lt;p&gt;重载规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被重载的方法必须改变参数列表(参数个数或类型不一样)&lt;/li&gt;
&lt;li&gt;被重载的方法可以改变返回类型&lt;/li&gt;
&lt;li&gt;被重载的方法可以改变访问修饰符&lt;/li&gt;
&lt;li&gt;被重载的方法可以声明新的或更广的检查异常&lt;/li&gt;
&lt;li&gt;方法能够在同一个类中或者在一个子类中被重载&lt;/li&gt;
&lt;li&gt;无法以返回值类型作为重载函数的区分标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Overloading {
    public int test(){
        System.out.println(&amp;quot;test1&amp;quot;);
        return 1;
    }
 
    public void test(int a){
        System.out.println(&amp;quot;test2&amp;quot;);
    }   
 
    //以下两个参数类型顺序不同
    public String test(int a,String s){
        System.out.println(s);
        return &amp;quot;return&amp;quot; + s;
    }   
 
    public String test(String s,int a){
        System.out.println(s);
        return &amp;quot;return&amp;quot; + s;
    }   
 
    public static void main(String[] args){
        Overloading o = new Overloading();
        System.out.println(o.test());
        o.test(1);
        System.out.println(o.test(1,&amp;quot;test3&amp;quot;));
        System.out.println(o.test(&amp;quot;test4&amp;quot;,1));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;override-和overload之间的区别&#34;&gt;Override 和Overload之间的区别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;区别点&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;重载&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;重写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;参数列表&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;必须修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不能修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;异常&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以减少或删除，不能增加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;访问&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以降低限制，不能更严格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;多态&#34;&gt;多态&lt;/h2&gt;
&lt;p&gt;多态是一个行为有多个不同表现形式或形态的能力&lt;/p&gt;
&lt;p&gt;多态就是同一个接口，使用不同的实例执行不同的操作&lt;/p&gt;
&lt;p&gt;多态的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除类型之间的耦合关系&lt;/li&gt;
&lt;li&gt;可替换性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;接口性&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;li&gt;简化性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多态存在的必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象：&lt;code&gt;Parent p = new Child();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        show(new Cat());  // 以 Cat 对象调用 show 方法
        show(new Dog());  // 以 Dog 对象调用 show 方法
                    
        Animal a = new Cat();  // 向上转型  
        a.eat();               // 调用的是 Cat 的 eat
        Cat c = (Cat)a;        // 向下转型  
        c.work();        // 调用的是 Cat 的 work
    }  
            
    public static void show(Animal a)  {
        a.eat();  
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情 
            Cat c = (Cat)a;  
            c.work();  
        } else if (a instanceof Dog) { // 狗做的事情 
            Dog c = (Dog)a;  
            c.work();  
        }  
    }  
}
 
abstract class Animal {  
    abstract void eat();  
}  
  
class Cat extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃鱼&amp;quot;);  
    }  
    public void work() {  
        System.out.println(&amp;quot;抓老鼠&amp;quot;);  
    }  
}  
  
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃骨头&amp;quot;);  
    }  
    public void work() {  
        System.out.println(&amp;quot;看家&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;虚函数&#34;&gt;虚函数&lt;/h3&gt;
&lt;p&gt;Java没有虚函数的概念，其普通函数默认就相当于C++的虚函数，加上final关键字可以声明该函数不具有虚函数特性&lt;/p&gt;
&lt;p&gt;虚拟方法调用：&lt;/p&gt;
&lt;p&gt;实例时，编译时使用父类的方法进行，运行时调用重写的方法&lt;/p&gt;
&lt;h3 id=&#34;多态的实现方式&#34;&gt;多态的实现方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;抽象类和抽象方法&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;抽象类&#34;&gt;抽象类&lt;/h2&gt;
&lt;p&gt;抽象类没有包含足够的信息来描绘一个对象&lt;/p&gt;
&lt;p&gt;所以不能实例化对象&lt;/p&gt;
&lt;p&gt;抽象类必须被继承，才能被使用&lt;/p&gt;
&lt;p&gt;抽象类是用来捕捉子类的通用特性的，是被用来创建继承层级里子类的模板。 现实中有些父类中的方法确实没有必要写，因为各个子类中的这个方法肯定会有不同；而写成抽象类，这样看代码时，就知道这是抽象方法，而知道这个方法是在子类中实现的，所以有提示作用&lt;/p&gt;
&lt;h3 id=&#34;抽象类-2&#34;&gt;抽象类&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;abstract class&lt;/code&gt;来定义抽象类&lt;/p&gt;
&lt;h3 id=&#34;继承抽象类&#34;&gt;继承抽象类&lt;/h3&gt;
&lt;h3 id=&#34;抽象方法&#34;&gt;抽象方法&lt;/h3&gt;
&lt;p&gt;抽象方法也用&lt;code&gt;abstract&lt;/code&gt;来声明&lt;/p&gt;
&lt;p&gt;抽象方法只包含一个方法名，而没有方法体，即方法的具体由子类确定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public abstract double computePay(); // 方法名后直接跟分号&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具有抽象方法的抽象类，其子类必须重写父类的抽象方法，或者也声明为抽象类&lt;/p&gt;
&lt;p&gt;构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;封装&#34;&gt;封装&lt;/h2&gt;
&lt;p&gt;封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法&lt;/p&gt;
&lt;p&gt;可理解为一个保护，防止该类的代码和数据被外部类定义的代码随机访问&lt;/p&gt;
&lt;p&gt;封装的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;良好的封装能够减少耦合&lt;/li&gt;
&lt;li&gt;类内部的结构可以自由修改&lt;/li&gt;
&lt;li&gt;可以对成员变量进行更精确的控制&lt;/li&gt;
&lt;li&gt;隐藏信息，实现细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现封装的步骤&#34;&gt;实现封装的步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改属性的可见性来限制对属性的访问（一般限制为private）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对每个值属性提供对外的公共方法访问，即创建一对赋取值方法，用于对私有属性的访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EncapTest{
 
    private String name;
    private String idNum;
    private int age;
    
    public int getAge(){
        return age;
    }
    
    public String getName(){
        return name;
    }
    
    public String getIdNum(){
        return idNum;
    }
    
    public void setAge( int newAge){
        age = newAge;
    }
    
    public void setName(String newName){
        name = newName;
    }
    
    public void setIdNum( String newId){
        idNum = newId;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RunEncap{
    public static void main(String args[]){
        EncapTest encap = new EncapTest();
        encap.setName(&amp;quot;James&amp;quot;);
        encap.setAge(20);
        encap.setIdNum(&amp;quot;12343ms&amp;quot;);

        System.out.print(&amp;quot;Name : &amp;quot; + encap.getName()+ &amp;quot; Age : &amp;quot;+ encap.getAge());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口interface&#34;&gt;接口（Interface）&lt;/h2&gt;
&lt;p&gt;接口是抽象方法的集合&lt;/p&gt;
&lt;p&gt;通常以&lt;code&gt;interface&lt;/code&gt;声明&lt;/p&gt;
&lt;p&gt;一个类通过继承接口的方式来继承接口的抽象方法&lt;/p&gt;
&lt;p&gt;类描述对象的属性和方法，接口包含类要实现的方法&lt;/p&gt;
&lt;p&gt;实现接口的类要定义接口中的所有方法，除非是抽象类&lt;/p&gt;
&lt;p&gt;接口不能实例化，但可以被实现&lt;/p&gt;
&lt;p&gt;接口与类相似点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个接口可以有多个方法&lt;/li&gt;
&lt;li&gt;接口文件保存在 .java 结尾的文件中，文件名使用接口名&lt;/li&gt;
&lt;li&gt;接口的字节码文件保存在 .class 结尾的文件中&lt;/li&gt;
&lt;li&gt;接口相应的字节码文件必须在与包名称相匹配的目录结构中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口与类的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口不能用于实例化对象。&lt;/li&gt;
&lt;li&gt;接口没有构造方法。&lt;/li&gt;
&lt;li&gt;接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。&lt;/li&gt;
&lt;li&gt;接口不能包含成员变量，除了 static 和 final 变量。&lt;/li&gt;
&lt;li&gt;接口不是被类继承了，而是要被类实现。&lt;/li&gt;
&lt;li&gt;接口支持多继承&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽象类和接口的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 &lt;code&gt;public static final&lt;/code&gt; 类型的&lt;/li&gt;
&lt;li&gt;一个类只能继承一个抽象类，可以实现多个接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;接口的声明&#34;&gt;接口的声明&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;[可见度] interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Animal {
   public void eat();
   public void travel();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的实现&#34;&gt;接口的实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MammalInt implements Animal{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的继承&#34;&gt;接口的继承&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 文件名: Sports.java
public interface Sports
{
   public void setHomeTeam(String name);
   public void setVisitingTeam(String name);
}
 
// 文件名: Football.java
public interface Football extends Sports
{
   public void homeTeamScored(int points);
   public void visitingTeamScored(int points);
   public void endOfQuarter(int quarter);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口的多继承&#34;&gt;接口的多继承&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public interface Hockey extends Sports, Event&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;标记接口&#34;&gt;标记接口&lt;/h3&gt;
&lt;p&gt;没有任何方法的接口被称为标记接口&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立一个公共的父接口&lt;/li&gt;
&lt;li&gt;向一个类添加数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;枚举enum&#34;&gt;枚举（enum）&lt;/h2&gt;
&lt;p&gt;枚举是一个特殊的类，一般表示一组常量&lt;/p&gt;
&lt;p&gt;所有的枚举值都是 public static final&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
 
public class Test
{
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}


//RED
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部类中使用枚举&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test
{
    enum Color
    {
        RED, GREEN, BLUE;
    }
 
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;迭代枚举元素&#34;&gt;迭代枚举元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
public class MyClass {
  public static void main(String[] args) {
    for (Color myVar : Color.values()) {
      System.out.println(myVar);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;values-ordinal-valueof方法&#34;&gt;values(), ordinal(), valueOf()方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;values() 返回枚举类中所有的值&lt;/li&gt;
&lt;li&gt;ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样&lt;/li&gt;
&lt;li&gt;valueOf()方法返回指定字符串值的枚举常量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
}
 
public class Test
{
    public static void main(String[] args)
    {
        // 调用 values()
        Color[] arr = Color.values();
 
        // 迭代枚举
        for (Color col : arr)
        {
            // 查看索引
            System.out.println(col + &amp;quot; at index &amp;quot; + col.ordinal());
        }
 
        // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException
        System.out.println(Color.valueOf(&amp;quot;RED&amp;quot;));
        // System.out.println(Color.valueOf(&amp;quot;WHITE&amp;quot;));
    }
}


// RED at index 0
// GREEN at index 1
// BLUE at index 2
// RED
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;枚举类成员&#34;&gt;枚举类成员&lt;/h3&gt;
&lt;p&gt;枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符&lt;/p&gt;
&lt;p&gt;枚举既可以包含具体方法，也可以包含抽象方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;enum Color
{
    RED, GREEN, BLUE;
 
    // 构造函数
    private Color()
    {
        System.out.println(&amp;quot;Constructor called for : &amp;quot; + this.toString());
    }
 
    public void colorInfo()
    {
        System.out.println(&amp;quot;Universal Color&amp;quot;);
    }
}
 
public class Test
{    
    // 输出
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
        c1.colorInfo();
    }
}


// Constructor called for : RED
// Constructor called for : GREEN
// Constructor called for : BLUE
// RED
// Universal Color
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;包package&#34;&gt;包（package）&lt;/h2&gt;
&lt;p&gt;包的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把功能相似的类或接口组织在一个包中，方便查找和使用&lt;/li&gt;
&lt;li&gt;避免名字冲突&lt;/li&gt;
&lt;li&gt;包也限定了访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.lang-打包基础的类&lt;/li&gt;
&lt;li&gt;java.io-包含输入输出功能的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;创建包&#34;&gt;创建包&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;package pkg1[．pkg2[．pkg3…]];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;包的声明放在这个源文件的开头&lt;/p&gt;
&lt;h3 id=&#34;import关键字&#34;&gt;import关键字&lt;/h3&gt;
&lt;p&gt;import语句导入包&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import package1[.package2…].(classname|*);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;任意数量import 声明必须在包声明之后，类声明之前&lt;/p&gt;
&lt;h3 id=&#34;package的目录结构&#34;&gt;package的目录结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;包名成为类名的一部分，正如我们前面讨论的一样。&lt;/li&gt;
&lt;li&gt;包名必须与相应的字节码所在的目录结构相吻合&lt;/li&gt;
&lt;/ul&gt;
">面向对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://zdblog.top/ji-chu-yu-fa/"" data-c="
          &lt;h2 id=&#34;java基础语法&#34;&gt;Java基础语法&lt;/h2&gt;
&lt;p&gt;Java语言是面向对象的&lt;/p&gt;
&lt;p&gt;先介绍下类、对象、方法和实例变量的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象：是类的一个实例，有状态有行为。eg：对象（一条狗），状态（名字、品种、颜色等），行为（叫、吃、摇尾巴等）&lt;/li&gt;
&lt;li&gt;类：类是一个模板，描述一类对象的行为和状态&lt;/li&gt;
&lt;li&gt;方法：方法就是行为，一个类可以有很多方法&lt;/li&gt;
&lt;li&gt;实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;包名：多单词都小写&lt;/p&gt;
&lt;p&gt;类名、接口名：所有单词首字母大写&lt;/p&gt;
&lt;p&gt;变量名、方法名：第一个单词首字母小写，后面大写&lt;/p&gt;
&lt;p&gt;常量名：所有字母都大写，多单词用下划线连接(eg:XXX_YYY_ZZZ)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;源文件名必须与类名相同&lt;/li&gt;
&lt;li&gt;一个源文件只能有一个public类，可以有若干个非public类&lt;/li&gt;
&lt;li&gt;主方法入口：&lt;code&gt;public static void main(String[] args)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;public static void main(String[] args)&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;public：访问修饰符&lt;br&gt;
static：关键字&lt;br&gt;
void：返回类型&lt;br&gt;
main：方法名&lt;br&gt;
String：String类&lt;br&gt;
args：字符串数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;标识符&#34;&gt;标识符&lt;/h3&gt;
&lt;p&gt;Java所有的组成部分都需要名字。&lt;/p&gt;
&lt;p&gt;标识符：类名、变量名、方法名&lt;/p&gt;
&lt;p&gt;标识符规范：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首字符：字母、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;其&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;他&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;符&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;母&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;、_
其他字符：字母、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.15em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:-0.15em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord cjk_fallback mtight&#34;&gt;其&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;他&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;符&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;母&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、_、数字&lt;br&gt;
大小写敏感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;修饰符&#34;&gt;修饰符&lt;/h3&gt;
&lt;p&gt;Java用修饰符来修饰类中的方法和属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问控制修饰符：default、public、protected、private&lt;/li&gt;
&lt;li&gt;非访问控制修饰符：final、abstract、static、synchronized&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java变量&#34;&gt;Java变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;li&gt;类变量（静态变量）&lt;/li&gt;
&lt;li&gt;成员变量（非静态变量）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java关键字&#34;&gt;Java关键字&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/08/Pnm1sC7QRDZG4z6.png&#34; alt=&#34;Java关键字.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-对象和类&#34;&gt;Java 对象和类&lt;/h2&gt;
&lt;p&gt;Java面向对象支持以下基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;li&gt;抽象&lt;/li&gt;
&lt;li&gt;类&lt;/li&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;li&gt;实例&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：改变对象的内部状态，对象的相互调用&lt;/p&gt;
&lt;p&gt;类中的变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部变量：在方法中定义的变量，随方法的结束而销毁&lt;/li&gt;
&lt;li&gt;成员变量：定义在类中、方法之外的变量，在创建对象时实例化，在类中可被访问&lt;/li&gt;
&lt;li&gt;类变量：声明在类中、方法块之外、必须声明为static类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造方法&#34;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;每个类都有一个或多个构造方法&lt;/p&gt;
&lt;p&gt;创建对象时，至少调用一个构造方法&lt;/p&gt;
&lt;p&gt;构造方法的名称必须与类同名&lt;/p&gt;
&lt;h3 id=&#34;创建对象&#34;&gt;创建对象&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;声明：对象的名称和类型&lt;/li&gt;
&lt;li&gt;实例化：使用关键字&lt;code&gt;new&lt;/code&gt;来创建一个对象&lt;/li&gt;
&lt;li&gt;初始化：使用&lt;code&gt;new&lt;/code&gt;创建对象时，会调用构造方法初始化对象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Puppy{

    // 该构造方法仅有一个参数：name
    public Puppy(String name){
        System.out.println(&amp;quot;The dog&#39;s name is : &amp;quot; + name);
    }

    public static void main(String[] args){
        Puppy myPuppy = new Puppy(&amp;quot;Tommy&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;访问实例变量和方法&#34;&gt;访问实例变量和方法&lt;/h3&gt;
&lt;p&gt;通过已创建的对象来访问成员变量和成员方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* 实例化对象 */
Object referenceVariable = new Constructor();
/* 访问类中的变量 */
referenceVariable.variableName;
/* 访问类中的方法 */
referenceVariable.methodName();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Puppy{
    int puppyAge;
    public Puppy(String name){
        System.out.println(&amp;quot;The dog&#39;s name is : &amp;quot; + name)；
    }

    public void setAge(int age){
        puppyAge = age;
    }

    public int getAge(){
        return puppyAge;
    }

    public static void main(String[] args){
        Puppy myPuppy = new Puppy(Tommy);

        myPuppy.setAge(2)
        System.out.println(&amp;quot;myPuppy&#39;s age is : &amp;quot; + myPuppy.getAge());
        System.out.println(&amp;quot;变量值：&amp;quot; + myPuppy.puppyAge);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java包&#34;&gt;Java包&lt;/h3&gt;
&lt;p&gt;包主要用来对类和接口进行分类&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java基本数据类型&#34;&gt;Java基本数据类型&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;内置数据类型&lt;/li&gt;
&lt;li&gt;引用数据类型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内置数据类型&#34;&gt;内置数据类型&lt;/h3&gt;
&lt;p&gt;8种基本类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;byte：8位,默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;short：16位，默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;int：32位，默认值&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;long：64位，默认值&lt;code&gt;0L&lt;/code&gt;(L不区分大小写，最好大写区分1)&lt;/li&gt;
&lt;li&gt;float：单精度，32位，默认值&lt;code&gt;0.0f&lt;/code&gt;(不能表示精确的值)&lt;/li&gt;
&lt;li&gt;double：双精度，64位，默认值&lt;code&gt;0.0d&lt;/code&gt;(不能表示精确值)&lt;/li&gt;
&lt;li&gt;boolean：标志记录true/false，默认&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;char：单一的16位Unicode字符，&lt;code&gt;\u0000&lt;/code&gt;~&lt;code&gt;\uffff&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;引用数据类型&#34;&gt;引用数据类型&lt;/h3&gt;
&lt;p&gt;对象、数组都是引用数据类型&lt;/p&gt;
&lt;p&gt;默认值&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个引用变量可以用来引用任何与之兼容的类型&lt;/p&gt;
&lt;h3 id=&#34;java常量&#34;&gt;Java常量&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;final&lt;/code&gt;关键字来修饰常量&lt;/p&gt;
&lt;p&gt;eg：`final double PI = 3.14159265;&lt;/p&gt;
&lt;p&gt;常量名通常大写&lt;/p&gt;
&lt;p&gt;字符串常量：双引号之间的字符序列&lt;/p&gt;
&lt;p&gt;转义字符：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/08/Go2nVrQZF8Rpa9K.png&#34; alt=&#34;转义字符.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;自动类型转换&#34;&gt;自动类型转换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;low --------------------------------------&amp;gt; high
byte,short,char -&amp;gt; int -&amp;gt; long -&amp;gt; float -&amp;gt; double
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;boolean不能转换&lt;/li&gt;
&lt;li&gt;容量大的必须用强制转换才可以转换为容量小的&lt;/li&gt;
&lt;li&gt;浮点数舍弃小数转换得到整形&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java变量类型&#34;&gt;Java变量类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类变量&lt;/li&gt;
&lt;li&gt;实例变量&lt;/li&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Variable{
    static int allClicks=0;    // 类变量
 
    String str=&amp;quot;hello world&amp;quot;;  // 实例变量
 
    public void method(){
 
        int i =0;  // 局部变量
 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java局部变量&#34;&gt;java局部变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;局部变量声明在方法中&lt;/li&gt;
&lt;li&gt;不能用访问修饰符&lt;/li&gt;
&lt;li&gt;没有默认值，必须先初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java实例变量&#34;&gt;Java实例变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实例变量声明在一个类中，在方法、构造方法和语句块之外&lt;/li&gt;
&lt;li&gt;当一个对象被实例化之后，每个实例变量的值就跟着确定，对象被销毁的时候销毁&lt;/li&gt;
&lt;li&gt;实例变量的值应该至少被一个方法，使得外部能够通过这些方式获取实例变量信息&lt;/li&gt;
&lt;li&gt;可以声明在使用前或者使用后&lt;/li&gt;
&lt;li&gt;可用访问修饰符&lt;/li&gt;
&lt;li&gt;实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见&lt;/li&gt;
&lt;li&gt;有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定&lt;/li&gt;
&lt;li&gt;可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类变量静态变量&#34;&gt;类变量（静态变量）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在类中以 static 关键字声明，但必须在方法之外&lt;/li&gt;
&lt;li&gt;类只拥有类变量的一份拷贝&lt;/li&gt;
&lt;li&gt;静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。&lt;/li&gt;
&lt;li&gt;类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java修饰符&#34;&gt;java修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;访问修饰符&lt;/li&gt;
&lt;li&gt;非访问修饰符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修饰符用来定义类、方法或者变量，通常放在语句的最前端&lt;/p&gt;
&lt;h3 id=&#34;访问控制修饰符&#34;&gt;访问控制修饰符&lt;/h3&gt;
&lt;p&gt;用来保护对类、对象、方法的访问&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;default（默认，不写）：同一包内可见，不适用任何修饰符&lt;/li&gt;
&lt;li&gt;private：同一类内可见，不能修饰类（外部类）&lt;/li&gt;
&lt;li&gt;public：对所有类可见&lt;/li&gt;
&lt;li&gt;protected：对同一包内的类和子类可见，不能修饰类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口里的变量都隐式声明为&lt;code&gt;public static final&lt;/code&gt;，而接口里的方法默认为&lt;code&gt;public&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;私有访问修饰符--private&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Logger {
    private String format;
    public String getFormat() {
        return this.format;
    }
    public void setFormat(String format) {
        this.format = format;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;公有访问修饰符--public&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明为 public 的类、方法、构造方法和接口能够被任何其他类访问&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;受保护的访问修饰符--protected&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;子类与父类在同一包中：能被同一个包中的任何其他类访问&lt;/li&gt;
&lt;li&gt;子类与父类不在同一包中：在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;方法继承规则：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;父类-public，子类public&lt;/li&gt;
&lt;li&gt;父类-protected，子类public、protected&lt;/li&gt;
&lt;li&gt;父类-private，子类不能继承&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非访问修饰符&#34;&gt;非访问修饰符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;static：用来修饰类方法和类变量&lt;/li&gt;
&lt;li&gt;final：修饰类、方法、变量，修饰的类不能被继承，方法不能被重新定义，变量为常量，不可修改&lt;/li&gt;
&lt;li&gt;abstract：用来修饰抽象类和抽象方法&lt;/li&gt;
&lt;li&gt;synchronized和volatile：主要用于线程的编程&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;static修饰符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态变量：用来声明静态变量，只有一份拷贝&lt;/li&gt;
&lt;li&gt;静态方法：静态方法不能使用类的非静态变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final修饰符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;final变量：赋值后为常量&lt;/li&gt;
&lt;li&gt;final方法：可以被继承，但不能被子类重写&lt;/li&gt;
&lt;li&gt;final类：不能被继承&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;abstract修饰符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized修饰符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;声明的方法同一时间只能被一个线程访问&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;transient修饰符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java 虚拟机(JVM)跳过被 transient 修饰的实例变量&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;volatile修饰符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值,成员变量发生变化时，会强制线程将变化值回写到共享内存&lt;/p&gt;
&lt;p&gt;任何时刻，两个不同的线程总是看到某个成员变量的同一个值&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-运算符&#34;&gt;java 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;其他运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;/&lt;/code&gt;,&lt;code&gt;%&lt;/code&gt;,&lt;code&gt;++&lt;/code&gt;,&lt;code&gt;--&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算&lt;/li&gt;
&lt;li&gt;后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt;,&lt;code&gt;!=&lt;/code&gt;,&lt;code&gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;=&lt;/code&gt;,&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;,&lt;code&gt;|&lt;/code&gt;,&lt;code&gt;^&lt;/code&gt;,&lt;code&gt;~&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/09/SmKYWLxFpNgVylT.png&#34; alt=&#34;位运算符.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt;,&lt;code&gt;+=&lt;/code&gt;,&lt;code&gt;-=&lt;/code&gt;,&lt;code&gt;*=&lt;/code&gt;,&lt;code&gt;/=&lt;/code&gt;,&lt;code&gt;(%)=&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;,&lt;code&gt;&amp;amp;=&lt;/code&gt;,&lt;code&gt;^=&lt;/code&gt;,&lt;code&gt;|=&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;条件运算符（三元运算符）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;variable x = (expression) ? value if true : value if false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;code&gt;b = (a == 1) ? 20 : 30;&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;instanceof运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;( Object reference variable ) instanceof (class/interface type)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String name = &amp;quot;James&amp;quot;;
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/09/BfPx341d8E9zSwG.png&#34; alt=&#34;运算符优先级.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;java循环结构&#34;&gt;Java循环结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;while循环&lt;/li&gt;
&lt;li&gt;do...while循环&lt;/li&gt;
&lt;li&gt;for循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java增强for循环&#34;&gt;Java增强for循环&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for(声明语句 : 表达式)
{
    // 代码句子
}
// 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配
// 表达式：要访问的数组名，或者是返回值为数组的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test{
    public static void main(String[] args){
        String [] names = {&amp;quot;James&amp;quot;, &amp;quot;Larry&amp;quot;, &amp;quot;Tom&amp;quot;, &amp;quot;Lacy&amp;quot;};
        for(String name : names){
            System.out.print(name);
            System.out.print(&amp;quot;,&amp;quot;);
        }
    }
}

// James,Larry,Tom,Lacy,
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;break关键字&#34;&gt;break关键字&lt;/h3&gt;
&lt;p&gt;break 主要用在循环语句或者 switch 语句中，用来跳出语句块&lt;/p&gt;
&lt;h3 id=&#34;continue关键字&#34;&gt;continue关键字&lt;/h3&gt;
&lt;p&gt;让程序立刻跳转到下一次循环的迭代&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java条件语句&#34;&gt;Java条件语句&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;if语句&lt;/li&gt;
&lt;li&gt;if...else语句&lt;/li&gt;
&lt;li&gt;if..else if...else语句&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-switch-case语句&#34;&gt;Java switch case语句&lt;/h2&gt;
&lt;p&gt;switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出直至break语句出现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
   public static void main(String args[]){
      int i = 1;
      switch(i){
         case 0:
            System.out.println(&amp;quot;0&amp;quot;);
         case 1:
            System.out.println(&amp;quot;1&amp;quot;);
         case 2:
            System.out.println(&amp;quot;2&amp;quot;);
         case 3:
            System.out.println(&amp;quot;3&amp;quot;); break;
         default:
            System.out.println(&amp;quot;default&amp;quot;);
      }
   }
}

// 1
// 2
// 3
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;h3 id=&#34;声明数组变量&#34;&gt;声明数组变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dataType[] arrayRefVar;   // 首选的方法
 
或
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建数组&#34;&gt;创建数组&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;arrayRefVar = new dataType[arraySize];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;数组变量的声明，和创建数组可以用一条语句完成:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dataType[] arrayRefVar = new dataType[arraySize];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其他：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dataType[] arrayRefVar = {value0, value1, ..., valuek};&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;数组作为方法的参数或返回值&#34;&gt;数组作为方法的参数或返回值&lt;/h3&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;printArray(new int[]{3, 1, 2, 6, 4, 2});&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;多维数组&#34;&gt;多维数组&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;String[][] str = new String[3][4];&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;arrays类&#34;&gt;Arrays类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;给数组赋值：通过 fill 方法&lt;/li&gt;
&lt;li&gt;对数组排序：通过 sort 方法,按升序&lt;/li&gt;
&lt;li&gt;比较数组：通过 equals 方法比较数组中元素值是否相等&lt;/li&gt;
&lt;li&gt;查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;日期和时间date类&#34;&gt;日期和时间（Date类）&lt;/h2&gt;
&lt;p&gt;实例化Date对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Date()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Date(long milliseconds)&lt;/code&gt;:该参数为1970.01.01起的毫秒数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;date对象方法&#34;&gt;Date对象方法：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/NuxSwZg4ChOGVKd.png&#34; alt=&#34;Date方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;使用simpledateformat格式化日期&#34;&gt;使用SimpleDateFormat格式化日期&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SimpleDateFormat ft = new SimpleDateFormat (&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用printf格式化日期&#34;&gt;使用printf格式化日期&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/DbGnxh2APTH9qfW.png&#34; alt=&#34;printf格式化日期.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;全部日期和时间信息：%tc%n&amp;quot;,date);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;%1$s %2$tB %2$td, %2$tY&amp;quot;, &amp;quot;Due date:&amp;quot;, date);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out.printf(&amp;quot;%s %tB %&amp;lt;te, %&amp;lt;tY&amp;quot;, &amp;quot;Due date:&amp;quot;, date);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;java休眠sleep&#34;&gt;Java休眠（sleep）&lt;/h3&gt;
&lt;p&gt;sleep()阻塞当前进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
  
public class SleepDemo {
    public static void main(String[] args) {
        try { 
            System.out.println(new Date( ) + &amp;quot;\n&amp;quot;); 
            Thread.sleep(1000*3);   // 休眠3秒
            System.out.println(new Date( ) + &amp;quot;\n&amp;quot;); 
        } catch (Exception e) { 
            System.out.println(&amp;quot;Got an exception!&amp;quot;); 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测量时间&#34;&gt;测量时间&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
  
public class DiffDemo {
 
   public static void main(String[] args) {
      try {
         long start = System.currentTimeMillis( );
         System.out.println(new Date( ) + &amp;quot;\n&amp;quot;);
         Thread.sleep(5*60*10);
         System.out.println(new Date( ) + &amp;quot;\n&amp;quot;);
         long end = System.currentTimeMillis( );
         long diff = end - start;
         System.out.println(&amp;quot;Difference is : &amp;quot; + diff);
      } catch (Exception e) {
         System.out.println(&amp;quot;Got an exception!&amp;quot;);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;calendar类对日期进行操作&#34;&gt;Calendar类（对日期进行操作）&lt;/h3&gt;
&lt;p&gt;创建Calendar对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Calendar c = Calendar.getInstance();//默认是当前日期&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//创建一个代表2009年6月12日的Calendar对象&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Calendar c1 = Calendar.getInstance();&lt;/code&gt;&lt;br&gt;
&lt;code&gt;c1.set(2009, 6 - 1, 12);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象信息的设置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set设置：&lt;code&gt;public final void set(int year,int month,int date)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add设置：&lt;code&gt;c1.add(Calendar.DATE, 10);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象信息的获得:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int year = c1.get(Calendar.YEAR);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;gregoriancalendar类&#34;&gt;GregorianCalendar类&lt;/h3&gt;
&lt;p&gt;GregorianCalendar对象构造方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/Yomul6awe2RshgL.png&#34; alt=&#34;GregorianCalendar构造方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;GregorianCalendar对象常用方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/10/RxTBoJFD1AIplwq.png&#34; alt=&#34;GregorianCalendar常用方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java正则表达式&#34;&gt;Java正则表达式&lt;/h2&gt;
&lt;h3 id=&#34;正则表达式语法&#34;&gt;正则表达式语法：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/Mpk1wGBncSCRXOP.png&#34; alt=&#34;正则表达式语法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;regex包&#34;&gt;regex包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pattern类：Pattern对象是一个正则表达式的编译表示&lt;/li&gt;
&lt;li&gt;Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎&lt;/li&gt;
&lt;li&gt;PatternSyntaxException类：是一个非强制异常类，表示一个正则表达式模式中的语法错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;matcher类的方法&#34;&gt;Matcher类的方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/HKFdD3Gmsl7xXcI.png&#34; alt=&#34;matcher方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;patternsyntaxexception类的方法&#34;&gt;PatternSyntaxException类的方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/ji7tRZLYEQkwg31.png&#34; alt=&#34;patternsyntaxexception方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-流stream-文件file-io&#34;&gt;Java 流（stream）、文件（file）、IO&lt;/h2&gt;
&lt;p&gt;Java.io 包几乎包含了所有操作输入、输出需要的类&lt;/p&gt;
&lt;p&gt;一个流可以理解为一个数据的序列&lt;/p&gt;
&lt;p&gt;输入流表示从一个源读取数据，输出流表示向一个目标写数据&lt;/p&gt;
&lt;h3 id=&#34;读取控制台输入&#34;&gt;读取控制台输入&lt;/h3&gt;
&lt;p&gt;把System.in包装在一个BufferedReader对象中创建一个字符流&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BufferedReader br = new BufferedReader(new InputStreamReader(System.in));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;BufferedReader对象创建后，read()方法从控制台读取一个字符，readLine()方法从控制台读取一个字符串&lt;/p&gt;
&lt;p&gt;从控制台读取多字符输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int read( ) throws IOException&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用 BufferedReader 在控制台读取字符
 
import java.io.*;
 
public class BRRead {
    public static void main(String[] args) throws IOException {
        char c;
        // 使用 System.in 创建 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(&amp;quot;输入字符, 按下 &#39;q&#39; 键退出。&amp;quot;);
        // 读取字符
        do {
            c = (char) br.read();
            System.out.println(c);
        } while (c != &#39;q&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从控制台读取字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String readLine( ) throws IOException&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用 BufferedReader 在控制台读取字符
import java.io.*;
 
public class BRReadLines {
    public static void main(String[] args) throws IOException {
        // 使用 System.in 创建 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str;
        System.out.println(&amp;quot;Enter lines of text.&amp;quot;);
        System.out.println(&amp;quot;Enter &#39;end&#39; to quit.&amp;quot;);
        do {
            str = br.readLine();
            System.out.println(str);
        } while (!str.equals(&amp;quot;end&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;控制台输出&#34;&gt;控制台输出&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;System.out.print()&lt;/code&gt;, &lt;code&gt;System.out.println()&lt;/code&gt;, &lt;code&gt;System.out.write()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;读写文件&#34;&gt;读写文件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;FileInputStream&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该流用于读取数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用字符串类型的文件名来创建一个输入流对象来读取文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InputStream f = new FileInputStream(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用一个文件对象来创建一个输入流对象来读取文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File f = new File(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;InputStream in = new FileInputStream(f);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InputStream对象的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/3MpPyQUnLdIxrFD.png&#34; alt=&#34;InputStream方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该流用于创建一个文件并像文件中写入数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用字符串类型的文件名来创建一个输出流对象&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OutputStream f = new FileOutputStream(&amp;quot;C:/java/hello&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用一个文件对象来创建一个输出流来写文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File f = new File(&amp;quot;C:/java/hello&amp;quot;);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;OutputStream fOut = new FileOutputStream(f);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OutputStream对象的方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/STUIgC2LF8MRcZ4.png&#34; alt=&#34;OutputStream方法.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其他输出流：&lt;code&gt;ByteArrayOutputStream&lt;/code&gt;、&lt;code&gt;DataOutputStream&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
 
public class fileStreamTest {
    public static void main(String[] args) {
        try {
            byte bWrite[] = { 11, 21, 3, 40, 5 };
            OutputStream os = new FileOutputStream(&amp;quot;test.txt&amp;quot;);
            for (int x = 0; x &amp;lt; bWrite.length; x++) {
                os.write(bWrite[x]); // writes the bytes
            }
            os.close();
 
            InputStream is = new FileInputStream(&amp;quot;test.txt&amp;quot;);
            int size = is.available();
 
            for (int i = 0; i &amp;lt; size; i++) {
                System.out.print((char) is.read() + &amp;quot;  &amp;quot;);
            }
            is.close();
        } catch (IOException e) {
            System.out.print(&amp;quot;Exception&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;关于文件和io的类&#34;&gt;关于文件和I/O的类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;File Class&lt;/li&gt;
&lt;li&gt;FileReader Class&lt;/li&gt;
&lt;li&gt;FileWriter Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mkdir()方法创建一个文件夹，成功返回true，失败返回false&lt;/li&gt;
&lt;li&gt;mkidrs()方法创建一个文件夹和它所有父类文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 
public class CreateDir {
    public static void main(String[] args) {
        String dirname = &amp;quot;/tmp/user/java/bin&amp;quot;;
        File d = new File(dirname);
        // 现在创建目录
        d.mkdirs();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;读取目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调用该对象的list()方法，提取目录包含的文件和文件夹列表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 
public class DirList {
    public static void main(String args[]) {
        String dirname = &amp;quot;/tmp&amp;quot;;
        File f1 = new File(dirname);
        if (f1.isDirectory()) {
            System.out.println(&amp;quot;目录 &amp;quot; + dirname);
            String s[] = f1.list();
            for (int i = 0; i &amp;lt; s.length; i++) {
                File f = new File(dirname + &amp;quot;/&amp;quot; + s[i]);
                if (f.isDirectory()) {
                    System.out.println(s[i] + &amp;quot; 是一个目录&amp;quot;);
                } else {
                    System.out.println(s[i] + &amp;quot; 是一个文件&amp;quot;);
                }
            }
        } else {
            System.out.println(dirname + &amp;quot; 不是一个目录&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;删除目录或文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;java.io.File.delete()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;删除某一目录时，必须保证该目录下没有其他文件&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;scanner-类&#34;&gt;Scanner 类&lt;/h2&gt;
&lt;p&gt;用于获取用户的输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Scanner s = new Scanner(System.in)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scanner类的next()和nextLine()获取输入的字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;next()以空白为结束符，不能得到带空格的字符串&lt;/li&gt;
&lt;li&gt;nextLine()以Enter为结束符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以读取其他类型的数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nextXxx()&lt;/code&gt;: 例如 f = scan.nextFloat()&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;异常发生的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户输入非法字符&lt;/li&gt;
&lt;li&gt;要打开的文件不存在&lt;/li&gt;
&lt;li&gt;网络通信连接中断，或者JVM内存溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种类型的异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查性异常&lt;/li&gt;
&lt;li&gt;运行时异常&lt;/li&gt;
&lt;li&gt;错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exception类有两个主要的子类：IOException类和RuntimeException类&lt;/p&gt;
&lt;h3 id=&#34;java-内置异常类&#34;&gt;java 内置异常类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s2.loli.net/2022/03/11/h7Vr2tE3Gi8vW19.png&#34; alt=&#34;内置异常类.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;异常方法&#34;&gt;异常方法&lt;/h3&gt;
&lt;h3 id=&#34;捕获异常&#34;&gt;捕获异常&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try
{
   // 程序代码
}catch(ExceptionName e1)
{
   //Catch 块
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;catch语句包含要捕获异常的声明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
public class ExcepTest{
 
   public static void main(String args[]){
      try{
         int a[] = new int[2];
         System.out.println(&amp;quot;Access element three :&amp;quot; + a[3]);
      }catch(ArrayIndexOutOfBoundsException e){
         System.out.println(&amp;quot;Exception thrown  :&amp;quot; + e);
      }
      System.out.println(&amp;quot;Out of the block&amp;quot;);
   }
}


//Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 2
//Out of the block
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多重捕获块&#34;&gt;多重捕获块&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try{
   // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}catch(异常类型3 异常的变量名3){
  // 程序代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;throwsthrow关键字&#34;&gt;throws/throw关键字&lt;/h3&gt;
&lt;p&gt;如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws/throw 关键字来声明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void withdraw(double amount) throws RemoteException InsufficientFundsException&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;finally-关键字&#34;&gt;finally 关键字&lt;/h3&gt;
&lt;p&gt;无论是否发生异常，finally 代码块中的代码总会被执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try{
  // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}finally{
  // 程序代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;声明自定义异常&#34;&gt;声明自定义异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有异常都必须是 Throwable 的子类&lt;/li&gt;
&lt;li&gt;如果希望写一个检查性异常类，则需要继承 Exception 类&lt;/li&gt;
&lt;li&gt;如果你想写一个运行时异常类，那么需要继承 RuntimeException 类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用异常&#34;&gt;通用异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JVM异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类&lt;/li&gt;
&lt;li&gt;程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类&lt;/li&gt;
&lt;/ul&gt;
">基础语法</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>